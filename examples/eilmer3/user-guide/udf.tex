% udf.tex
\section{User-defined functions for run-time customization}
\label{udf-sec}
User-defined functions (UDFs) are callable for both specialized boundary conditions and 
for the addition of custom source terms.\footnote{Note that the following information 
is likely to become dated with code changes,
so it is best to refer to the actual source code to see what is expected.
Look in \texttt{bc\_user\_defined.cxx} for the boundary condition functions and \texttt{main.cxx} for the 
functions related to source terms.}
When using the user-defined boundary conditions you need to instruct the code about 
what to do for the convective (inviscid) update and then, separately, for the viscous effects. 
The inviscid interaction at the boundary may be handled in two ways:
\begin{enumerate}
 \item Defining a \verb!ghost_cell()! function.\\
  In this case, you populate the properties of two ghost cells such that 
  they give the desired inviscid effect at the wall. 
  The ghost cells are abstract in that they do not exist in the simulated flow domain
  but do exist in the code data for each block boundary. 
  They are used in the interpolation phase of the convective update,
  for cell faces that lie along the boundary.
  For the case of a solid wall, you use the \verb!ghost_cell()! function 
  and reflect the normal velocity.
  Examples of this are in the test cases.
 \item Defining a \verb!flux()! function. \\
  This is an alternative to the \verb!ghost_cell()! function and
  allows you to directly specify the convective flux. 
  This function is only used if the \verb!use_udf_flag! is set in the boundary condition. 
  If it is set, the \verb!flux! function will override anything in the \verb!ghost_cell()! function
  Thus causing the \verb!ghost_cell()! function to have no effect. 
\end{enumerate}
The way viscous effects work in the code is that you set the properties at the interface directly
and, as part of the viscous update, the main code computes spatial derivatives from these specified
flow properties. 
For example, you could set a temperature at the interface and zero velocity for a no-slip wall
with the function called \verb!interface()!. 
Normally you do not directly control the viscous heat flux into the flow directly, 
however, control it indirectly by setting the temperature.


\subsection{Boundary conditions}
\index{boundary conditions!user defined}
%
When the user's (Python) input script calls up a \texttt{UserDefinedBC()} boundary condition,
a Lua file is specified.
This file is run at the time of boundary-condition instantiation and it needs to define the
Lua functions \texttt{ghost\_cell(args)} and \texttt{interface(args)} at a minimum.
These functions are later called, every time the boundary condition is applied during the simulation.
As well as providing the \textit{expected} functions, the Lua file may contain whatever else
the user wishes.
It may start up external processes, read data files, or any other suitable activity that
sets up data for later use in the boundary condition functions.

\medskip
The Lua execution environment provided to the file includes the following data:\\
\vspace{1mm}
\begin{tabular}{ll} 
 \hline \noalign{\smallskip}
 \texttt{block\_id} & \parbox{10cm}{index of the current block. 
                                   Boundary conditions exist in the context a block.
                                   This means that the information accessible from the UDFs is limited
                                   to that contained within the block plus a little bit of global data.
                                   This is particularly important for parallel (MPI) simulations
                                   because blocks exist is separate processes and the data in one
                                   block is not generally available in another.} \\ \hline
 \texttt{nsp} & number of species \\
 \texttt{nmodes} & number of energy storage modes (and temperatures) \\
 \texttt{nni,nnj,nnk} &  number of cells in each index direction for the current block \\
 \noalign{\smallskip} \hline \noalign{\smallskip}
 \texttt{NORTH} & \parbox{10cm}{index of the ``North'' boundary.
                               This index (and the following indices) will be handy for deciding which boundary we are
                               working on when the \texttt{ghost\_cell(args)} and \texttt{interface(args)} 
                               are called.}\\
 \texttt{EAST,SOUTH,WEST} &  \\
 \texttt{TOP,BOTTOM} &  \\
 \noalign{\smallskip} \hline \noalign{\smallskip}
\end{tabular}

\noindent
As well as the data, there are a couple of functions that can be called to get more information about
the flow at specific locations:\\
\begin{tabular}{ll} 
 \noalign{\smallskip} \hline \noalign{\smallskip}
 \texttt{sample\_flow(jb,i,j,k)} & \parbox{10cm}{a function that returns a table of 
                                      the flow state for a particular cell.  The data is the same as that
                                      listed for the \texttt{ghost\_cell} tables with the addition of \texttt{vol},
                                      the cell volume.  This function is not likely to work for a MPI simulation,
                                      where only one block is visible to the current process.

                                      This function may be called with indices which sample the properties
                                      in the ghost cells themselves. When this is the case, the flow properties
                                      in the ghost cells should not be relied on. The only useful data is
                                      the position (\texttt{x}, \texttt{y} and \texttt{z}) and the volume
                                      \texttt{vol}. These values are estimated by using a linear extrapolation
                                      from the nearby interior cells. The values of position and volume may
                                      be useful when setting the properties in the ghost cells (see for
                                      example the application in MMS case to give a first-order boundary
                                      condition).
                                                                             

} \\
 \noalign{\smallskip} \hline \noalign{\smallskip}
 \texttt{locate\_cell(x,y,z)} & \parbox{10cm}{a function that will search for the cell nearest 
                                      the specified coordinates and return the cell indices
                                      and the index of the containing block.  This function 
                                      is not likely to work for a MPI simulation,
                                      where only one block is visible to the current process.} \\
 \noalign{\smallskip} \hline \noalign{\smallskip}
\end{tabular}

\noindent
There is also a function \texttt{compute\_diffusion\_coefficient} which can be called upon
to get the actual diffusion coefficients at the boundary conditions.

\medskip
On being called at run time, the function \texttt{ghost\_cell(args)} returns two Lua tables. 
The first contains the flow state in the ghost cell nearest the boundary face, 
and the second contains the flow state for the ghost cell further away from the boundary face.
Items to appear in the returned tables are:\\
\begin{tabular}{lp{12cm}}
 \texttt{p} &  gas pressure \\
 \texttt{u,v,w} & velocity components in x,y,z-directions \\
 \texttt{massf} & table of \texttt{nsp} mass fractions. The zero entry, at least, must be specified. \\
 \texttt{T} & table of \texttt{nmodes} temperatures. The zero entry, at least, must be specified. \\
 \texttt{tke} &  turbulent kinetic energy \\
 \texttt{omega} &  $\omega$ for the $k-\omega$ turbulence model \\
 \texttt{mu\_t} &  turbulence viscosity \\
 \texttt{k\_t} &  turbulent heat conduction coefficient \\
 \texttt{sigma\_T} & variance of the local temperature (for Henrik's reacting flow) \\
 \texttt{sigma\_c} & variance of the local concentration (for Henrik's reacting flow) \\
 \texttt{S} & shock-detector value (1 or 0) \\
\end{tabular}\\
and the input \texttt{args} table contains:\\
\begin{tabular}{lp{12cm}}
 \texttt{t} &  the current simulation time, in seconds \\
 \texttt{x,y,z} &  coordinates of the midpoint of the interface\\
 \texttt{csX,csY,csZ} &  direction cosines for the interface\\
 \texttt{i,j,k} &  indices of the cell adjacent to the interface\\
 \texttt{which\_boundary} & index of the boundary (\texttt{NORTH},...) \\
\end{tabular}\\
Note that the \texttt{ghost\_cell} function is called once for every cell along the boundary,
so be mindful of the possibility of repeating calculations that remain fixed across the full boundary.
It may be efficient to do the calculation once, at the time the function is called for the first cell,
and store the resulting data in global variables so that they are ready for use in subsequent calls. 

\medskip
If viscous effects are active, the Lua function \texttt{interface(args)} is called to
get a few properties right at the bounding interface.
These properties are to be returned in a table containing:\\
\begin{tabular}{lp{12cm}}
 \texttt{massf} & table of \texttt{nsp} mass fractions. The zero entry, at least, must be specified. \\
 \texttt{T} & table of \texttt{nmodes} temperatures to be set at interface, possibly a wall.\\
 \texttt{u,v,w} & flow velocity at the interface \\
 \texttt{tke} &  turbulent kinetic energy \\
 \texttt{omega} &  $\omega$ for the $k-\omega$ turbulence model \\
\end{tabular}\\
On entry to the function, \texttt{args} contains the same attributes as for the call
to the \texttt{ghost\_cell} function.

\medskip
The functions are evaluated in the Lua interpreter environment that was set up
when the boundary condition was instantiated so any data that was stored then is
available to the functions now, possibly via global variables.

\medskip
The user may also provide a function \texttt{flux(args)} that returns a table specifying the interface fluxes
that can be used instead of the internally computed fluxes.
The table of fluxes returned contains the following entries:\\
\begin{tabular}{ll}
 \texttt{mass} &  mass flux per unit area of the interface \\
 \texttt{momentum\_x} & x-direction momentum flux per unit area \\
 \texttt{momentum\_y} & y-direction momentum flux per unit area \\
 \texttt{momentum\_z} & z-direction momentum flux per unit area \\
 \texttt{total\_energy } & flux of energy per unit area \\
 \texttt{romega} & flux of $\omega$ for the $k-\omega$ turbulence model \\
 \texttt{rtke} & flux of turbulent kinetic energy \\
 \texttt{species} & \parbox{12cm}{table of \texttt{nsp} species mass fluxes. The zero entry, at least, must be specified.} \\
 \texttt{renergies} & \parbox{12cm}{table of \texttt{nmodes} energy fluxes. The zero entry, at least, must be specified.} \\
\end{tabular}\\
and the input \texttt{args} table contains:\\
\begin{tabular}{ll}
 \texttt{t} &  the current simulation time, in seconds \\
 \texttt{x,y,z} &  coordinates of the midpoint of the interface\\
 \texttt{csX,csY,csZ} &  direction cosines for the interface\\
 \texttt{i,j,k} &  indices of the cell adjacent to the interface\\
 \texttt{which\_boundary} & index of the boundary (\texttt{NORTH},...) \\
\end{tabular}


\subsection{Source terms}
\index{source terms!user defined}
%
The Python input script can also specify the filename for a Lua file that contains functions
that can be called to specify additional source terms for each step of the simulation.
The functions \textit{expected} to be defined are \texttt{source\_vector(t, cell)},
\texttt{at\_timestep\_start(args)} and \texttt{at\_timestep\_end(args)}.
If you don't have any useful work for the latter two, just define them to return \texttt{nil}. 
The Lua execution environment provided provided to the file includes the following data:\\
\begin{tabular}{ll}
 \texttt{nsp} & number of species \\
 \texttt{nmodes} & number of energy storage modes (and temperatures) \\
 \texttt{sample\_flow} & \parbox{12cm}{a function that returns a table of 
                                      the flow state for a particular cell} \\
 \texttt{locate\_cell} & \parbox{12cm}{a function that will search for the cell nearest 
                                      the specified coordinates and return the cell indices
                                      and the index of the containing block} 
\end{tabular}
 
\bigskip
When activated, the function \texttt{source\_vector(t, cell)} will be called at each time step.
The first argument, \texttt{t}, is the current simulation time, in seconds.
The table \texttt{cell} contains:\\
\begin{tabular}{ll}
 \texttt{x,y,x} & coordinates of the cell centre \\
 \texttt{vol} & cell volume \\
 \texttt{p} & gas pressure \\
 \texttt{rho} & gas density \\
 \texttt{u,v,w} & gas velocity components \\
 \texttt{a} & speed of sound in gas \\
 \texttt{T} & table of \texttt{nmodes} temperatures \\
 \texttt{massf} & table of \texttt{nsp} mass fractions \\
\end{tabular}\\
On return, the table of source terms should contain:\\
\begin{tabular}{ll}
 \texttt{mass} &  rate of mass addition per unit volume\\
 \texttt{momentum\_x} & rate of x-momentum addition per unit volume\\
 \texttt{momentum\_y} & rate of y-momentum addition per unit volume\\
 \texttt{momentum\_z} & rate of z-momentum addition per unit volume\\
 \texttt{total\_energy} & rate of energy addition per unit volume\\
 \texttt{romega} & $d\omega/dt$ addition per unit volume\\
 \texttt{rtke} & rate of turbulent kinetic-energy addition per unit volume\\
 \texttt{radiation} & rate of energy addition via radiation per unit volume\\
 \texttt{species} & table of \texttt{nsp} values\\
 \texttt{energies} & table of \texttt{nmodes} values\\
\end{tabular}\\

\subsection{Notes on global variables and Lua interpreters}
%
For each boundary condition that uses a \verb!USER-DEFINED! boundary condition, 
an independent Lua interpreter is started. 
The global state in each of these interpreters (read boundary conditions) 
is kept between timesteps (\textit{i.e.} the interpreter is reentrant). 
However, there is no way to communicate information internally from one Lua interpreter to another. 
There is a subtlety here. 
You could actually write just one Lua file as the boundary condition but set it on multiple boundaries 
however, you would need to make it smart enough to use the Eilmer-provided information to work out 
which boundary it was and then act accordingly. 
Remember that, although you might use the one file, 
it is running as an independent process for each boundary. 
Those independent processes will not share global state and cannot communicate.

\medskip
An independent Lua interpreter is also started when using the global \verb!udf_file! 
to supply \verb!at_timestep_start()! and \verb!at_timestep_end()! functions. 
A single interpreter is started to house both those functions and 
the global state in that interpreter is also reentrant. 
