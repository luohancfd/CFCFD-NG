% eilmer3-user-guide.tex
% PJ, March 2007 -- elmer2 version
%     September 2008 -- eilmer3 version
%
\documentclass[12pt,a4paper,twoside]{article}
\usepackage[body={16cm,24.5cm}]{geometry}
\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue}
\usepackage{graphicx}
\usepackage{makeidx}
% \usepackage{showidx}
\usepackage{listings}
\usepackage{lscape}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{subfig}
\lstset{basicstyle=\ttfamily\scriptsize,identifierstyle=,keywordstyle=}

%------------------------------------------------------------------
% a couple horizontal bars to delimit embedded code
% the width suits the page size set above and
% the mathmode eliminates spaces between the three elements
\newcommand{\topbar}{\ensuremath{
    \rule{0.1mm}{2.0mm} \rule[2.0mm]{159.5mm}{0.1mm} \rule{0.1mm}{2.0mm}
}}
\newcommand{\bottombar}{\ensuremath{
    \rule{0.1mm}{2.0mm} \rule{159.5mm}{0.1mm} \rule{0.1mm}{2.0mm}
}}
\newcommand{\topbarshort}{\ensuremath{
    \rule{0.1mm}{2.0mm} \rule[2.0mm]{149.5mm}{0.1mm} \rule{0.1mm}{2.0mm}
}}
\newcommand{\bottombarshort}{\ensuremath{
    \rule{0.1mm}{2.0mm} \rule{149.5mm}{0.1mm} \rule{0.1mm}{2.0mm}
}}
%------------------------------------------------------------------

\title{
    The Eilmer3 Code: User Guide and Example Book.
}
\author{
    Mechanical Engineering Report 2008/07\\
    P. A. Jacobs\thanks{Queensland Geothermal Energy Centre of Excellence, The University of Queensland, Brisbane, Australia.} 
    and 
    R. J. Gollan\thanks{Centre for Hypersonics, The University of Queensland, Brisbane, Australia.}\\
    {\normalsize with contributions\thanks{These contributions have come in the form of examples, debugging, 
    proof-reading and constructive comments on the codes and this document, and code for special cases.}
    from a cast of many, including:}\\
    {\normalsize Peter Blyton,}
    {\normalsize Arianna Bosco,}
    {\normalsize Djamel Boutamine,}
    {\normalsize Laurie Brown,}
    {\normalsize David Buttsworth,} \\
    {\normalsize Wilson Chan,} 
    {\normalsize Sam Chiu,}
    {\normalsize Chris Craddock,} 
    {\normalsize Brian Cook,} 
    {\normalsize Jason Czapla,} \\
    {\normalsize Carlos de Miranda-Ventura,} 
    {\normalsize Andrew Denman,} 
    {\normalsize David Gildfind,} 
    {\normalsize Richard Gooze\'{e},}
    {\normalsize Stefan Hess,} \\
    {\normalsize Carolyn Jacobs,} 
    {\normalsize Ian Johnston,}
    {\normalsize Ojas Joshi,}
    {\normalsize Rainer Kirchhartz,} 
    {\normalsize Matt McGilvray,} \\
    {\normalsize David Mee,} 
    {\normalsize Luke Montgomery,} 
    {\normalsize Jan-Pieter Nap,} 
    {\normalsize Brendan O'Flaherty,} 
    {\normalsize Paul Petrie-Repar,} \\
    {\normalsize Dan Potter,} 
    {\normalsize Deepak Ramanath,}
    {\normalsize Michael Scott,}
    {\normalsize Umar Sheikh,} 
    {\normalsize Ben Stewart,} \\
    {\normalsize Joseph Tang,} 
    {\normalsize Katsu Tanimizu,} 
    {\normalsize Paul van der Laan,} 
    {\normalsize Jaidev Vesudevan,} 
    {\normalsize Mike Wendt,} \\
    {\normalsize Vince Wheatley,} 
    {\normalsize Adrian Window,} 
    {\normalsize Hannes Wojciak,}
    {\normalsize Fabian Zander}
}
% \date{September 2008}
\makeindex

\begin{document}
\maketitle

% For some reason, the abstract environment causes the labelling in
% the metapost figures to disappear; strange!
% \begin{abstract}
% \end{abstract}
\centerline{\textbf{Preface}}
Eilmer3 is an integrated collection of programs for the simulation of transient,
compressible flow in two and three spatial dimensions.
It provides a preparation program that can be used to set up a database of
simulation parameters, a block-structured grid defining the flow domain and an
initial flow field.
These items are then used as a starting point for the main simulation program
which computes a series of snapshots of the evolving flow.
Eilmer3 is part of the larger collection of compressible flow simulation codes
found at \url{http://www.mech.uq.edu.au/cfcfd/}.

\medskip
This user guide contains a collection of example simulations: scripts, results
and commentary.
It may be convenient for new users of the code to identify an example
close to the situation that they wish to model and then adapt the 
scripts for that example.

\cleardoublepage
\tableofcontents

%------------------------------------------------------------------
\cleardoublepage
\baselineskip = 1.5pc

\part{User guide}

\section{Introduction}
%
Eilmer3 is an integrated collection of programs for the simulation of transient,
compressible flow in two and three dimensions.
It provides a preparation program (\texttt{e3prep.py}) that can be used to set up a database of
simulation parameters, a block-structured, body-fitted grid defining the flow domain and an
initial flow field.
These items are then used as a starting point for the main simulation program (\texttt{e3shared.exe})
which computes a series of snapshots of the evolving flow.
Finally, a rudimentary but versatile postprocessing program (\texttt{e3post.py}) makes the flow data
available for further analysis.

\medskip
Eilmer3 is a derivative of the code mbcns2 which, in turn was an experiment in writing
the mb\_cns code in C++.
Once it was determined that there were clear benefits in using C++,
our three-dimensional flow code Elmer was then reworked in C++ as Elmer2.
At the same time, we experimented with using the Python language for the user's input script and 
embedding the Lua language in order to make some of the boundary conditions programmable.
Of course, these codes being experiments in C++, we soon decided that it could all be done
much more cleanly and be made much more versatile if we just reworked some of the basic modules.
Thus, the thermochemistry was reworked and the separate two and three dimensional codes merged
into Eilmer3.
The name change is to avoid a naming clash with the Elmer finite-element code 
from Finland.\footnote{\url{http://www.csc.fi/elmer}}

\medskip 
The following sections provide example input scripts and shell scripts for a number of simulations.
These are intended to be starting points for your own simulations and should be studied together with 
the other manuals that can be found in the documentation section of the 
Compressible Flow CFD Group web site:  
\url{http://www.mech.uq.edu.au/cfcfd/}.\index{Internet address}
Study these scripts carefully; some of the interesting bits of the documentation are
embedded within them.

\medskip
For a description of the methods coded into \texttt{Eilmer3}, see the companion report \cite{jacobs_etal_2010b}
which covers the gas-dynamic formulation and the basic thermochemistry components.

\clearpage
%------------------------------------------------------------------
\section{Building and installing the programs}
%
The core solver and its modules are mainly written in C/C++ for speed and the benefits of compile time checking. 
The pre- and post-processing programs are mainly Python so that we get flexibility and convenient customization.
There is also a little Tcl/Tk and Lua.

\medskip
Our main development environment is Linux but the programs can be deployed on
Linux, flavours of Unix such as MacOS-X and MS-Windows (using Cygwin).
The main requirement is that the C/C++ compilers, the Tcl and Python
interpreters be available, along with their supporting libraries and 
various extensions. 
The source code of the Lua interpreter is included in with Eilmer3.
The reStructuredText file \texttt{eilmer3.rst} (Appendix\,\ref{getting-started-file}) 
or the corresponding HTML file from the web site\footnote{The web site 
\url{http://www.mech.uq.edu.au/cfcfd/} has a nicely formatted set of instructions,
detailed API documents that have been extracted from the source code and 
a number of examples.  It is regularly expanded and updated.}
provides more detail including 
the actual commands needed to build and install the programs.

\medskip
If you are not accustomed to working with Unix/Linux, 
have a look at Appendix\,\ref{linux-command-notes-sec}
for a brief introduction to working on the command line.


%------------------------------------------------------------------
\section{Running simulations}
%
Setting up a simulation is mostly an exercise in writing a text-based 
description of your flow and its bounding geometry.
This \textit{input script} is presented to the preparation program as 
a Python source file, often with the extension ``.py''.
Once you have prepared your flow specification as an input script using your favourite text editor, 
the simulation data is generated by the \texttt{Eilmer3} programs in a number of stages:
\begin{itemize}
\item[1] Create the geometry definition, a grid and the initial flow state.
  For simple to moderately complex geometries, the built-in geometry tools (described later in this manual)
  are adequate.
  For complex geometries, you may find it convenient to import block-structured grids, 
  possibly from a specialized gridding tool such as \texttt{Gridgen} or \texttt{ICEMCFD}.
\item[2] Run the simulation code to produce flow data at subsequent times.
\item[3] Reformat the flow solution data to produce files suitable for a data viewing program such as Paraview or GNU-Plot.
\end{itemize}

\newpage
\subsection{Data preparation (with e3prep.py)}
Create the geometry definition and a grid with the command\\
         \texttt{\$ e3prep.py --job=\textit{job} --do-svg }\\ \index{e3prep.py!using}\index{preparation}
         \vspace{0.25cm} \\
         \centerline{\includegraphics[width=0.7\textwidth]{figs/preparation.png}}\\
         The italics word \textit{job} in the command should be replaced 
         by whatever job name that you have chosen.
         That name is then used as a base to derive specific names for each of
         the files associated with the simulation.
         At a minimum, you have an input script called \textit{job}\texttt{.py} 
         with the \texttt{.py} extension, indicating that the script is written in Python.
         The files from the preparation stage are:
         \begin{itemize}
           \item \textit{job}\texttt{.config}: \index{config file}
             A database of configuration parameters in INI format.
             Parameters are specified, one per line, as \textit{parameter-name = value}.
             A hierarchical structure is given to the set of parameters via
             named subsections in the file.
             Although you would probably never assemble one of these parameter files
             from scratch manually, it is sometimes convenient to alter a value or two and rerun
             a simulation without invoking \texttt{e3prep.py}.
           \item \textit{job}\texttt{.control}: \index{control file}
             A small database of parameters to control the time-stepping, the final time,
             and the intervals between writing of solutions and history data.
             The content of this file is also in INI format and it is parsed at the
             start of every time step.
             This way, a user can alter the simulation behaviour (by editing this file)
             without having to restart the simulation.
             To stop a simulation cleanly, set the \texttt{halt\_now} entry to 1.\index{halting a simulation}
             Other control parameters are marked with \ddag~ in Section\,\ref{sec:sim-control-parameters}.
           \item  \textit{job}\texttt{.times}:
             A mapping of time stamps to actual times at which the simulation
             data was written.
             After the preparation stage, there should be only the zero-time entry.
           \item \textit{job}\texttt{.svg} or \textit{job}\texttt{.wrl}: \index{SVG} \index{VRML}
             Sometimes it is convenient to see a graphical representation of the flow domain 
             and boundary conditions.
             These options produce a SVG or VRML rendering of the block boundaries 
             and the boundary-condition labels.
             The \texttt{--do-svg} will invoke the rendering of two-dimensional blocks
             to a scalable-vector-graphics file while \texttt{--do-vrml} will render 
             three-dimensional blocks to a virtual-reality-modeling-language file.
             For two-dimensional simulations, the SVG file can be edited in a program such as \texttt{Inkscape}
             (\url{http://www.inkscape.org})
             and the result used as part of your documentation for a particular simulation.
           \item \textit{job}\texttt{.grid.b0000.t0000}, \textit{job}\texttt{.grid.b0001.t0000} :
             The grid of finite-volume cells, 
             one file for each block that defines part of the flow domain.
             The grids are written as plain text files in a relatively simple format.
             The spatial coordinates for points within each file are
             associated with cell vertices of the structured grid.\footnote{Note that, in recent versions of the programs, 
             the grid and flow files are written to subdirectories within the job directory.}
           \item one flow-data file for each block:
             \textit{job}\texttt{.flow.b0000.t0000}, \textit{job}\texttt{.flow.b0001.t0000}, ...
             containing the initial flow state within each of the finite-volume cells.
             Look at the first couple of lines of a flow file to see what data elements are written for each cell.
             Variable names appear on the second line and units are \texttt{SI}.
         \end{itemize}
         Note that the grid and flow data files are written to subdirectories of the same names.
         The grid is written once (at time zero, subdirectory \texttt{grid/t0000/}) and 
         the flow files are written to a new subdirectory (\texttt{flow/tnnnn/}) at each output time.
         This is to keep the main job directory clean and to allow easy copying or moving of 
         individual solution times.
         Also, these files are stored in ``gzip'' format with a ``.gz'' extension by default.\index{gzip}

\newpage
\subsection{Running the simulation (with e3shared.exe)} 
Run the simulation code to produce flow data at subsequent times.\footnote{If the simulation
finishes too quickly (possibly without taking any steps at all),
it may be that the initial time step size is too large and the calculation is unstable.
One symptom of this is that the final value for \texttt{dt} is reported as being
the excessively large value of \texttt{1e+6} seconds.
Choose a suitably small value and try again.}\\ \index{e3shared.exe!running a simulation}
         \texttt{\$ e3shared.exe --job=\textit{job} --run}\\
         \vspace{0.25cm} \\
         \centerline{\includegraphics[width=0.7\textwidth]{figs/running-sim.png}}\\
         The output files are:
         \begin{itemize}
           \item \textit{job}\texttt{.flow.b}\textit{nnnn}\texttt{.t}\textit{mmmm}:
             The flow data for all cells at the times requested.
             As the simulation proceeds, whole-field solutions are written
             to new files with \textit{nnnn} representing the block number and
             \textit{mmmm} representing a time stamp.
             Look up the \textit{job}\texttt{.times} file to see what time values
             belong to each time stamp (or tindx).
             Just as for the grid files, each flow solution file is written 
             as a plain text file with a simple layout, not too different from 
             the Tecplot point-format for a structured-block grid.
             In these files, the spatial coordinates of points within the file are
             associated with the cell centres.
           \item  \textit{job}\texttt{.hist.b}\textit{nnnn}: \index{history location}
             Data at particular ``history locations'' and at times requested.
             This data is typically used to simulate the signals recorded by pressure 
             and heat-transfer sensors mounted on model surfaces.
             When restarting a simulation, the program will append to existing history files 
             rather than clobbering them.
             Note that, if you are running a simulation from the start multiple times, 
             you will need to manually remove the history files before each run.  
             The command \texttt{``rm -r ./hist/''} should do the job.
           \item  \textit{job}\texttt{.times}: \index{times file}
             A mapping of time stamps to actual times at which the simulation
             data was written.
             The main simulation appends lines to this file.
             This file may assist when automating some of the postprocessing operations.
           \item  \textit{job}\texttt{.finish}: \index{finish file}
             An INI-format file giving some information about the time-stepping parameters
             at the end of the simulation.
             These may be useful for starting a follow-on simulation.
         \end{itemize}

\medskip
For viscous simulations, surface heat flux and cell Reynolds number files are also written to the subdirectory \texttt{heat}.
See the \texttt{--heat-flux-list} option in Section\,\ref{sec:e3post} for a hint at how to extract the data and then
have a look in the data files to see what specific data has been captured. 

\subsection{Running the simulation in parallel (e3mpi.exe)}
%
One can build and run the distributed-memory version of the program, 
\texttt{e3mpi.exe}\index{e3mpi.exe}, on computers with 
the MPI (Message Passing Interface) library\footnote{See, for example, \url{http://www.open-mpi.org/}.} 
and runtime environment.
The notes in Appendix\,\ref{getting-started-file} show how to build and run 
the Eilmer3 executable for OpenMPI.\footnote{These notes are also available in HTML form at the URL
\url{http://www.mech.uq.edu.au/cfcfd/}.}
To run Eilmer3 across multiple processors\index{e3mpi.exe!running a simulation}
on a local machine use the following command\\
\texttt{\$ mpirun -np \textit{n} e3mpi.exe --job=name --run}\\
where \textit{n} is the number of MPI processes to use.
Note that the program is written such that one MPI process is assigned to each block; 
the number of MPI processes \emph{must} match the number of blocks in the simulation.
Each of these MPI processes is a separate program and you may run more than one per core 
or physical processor, however, if you want the shortest calculation time and you had lots of cores,
you would probably run one per core.

\subsection{Restarting a simulation}\index{restarting a simulation}
%
By default, the simulation program picks up the flow solution for \texttt{tindx} equal to 0 but
it can be told to pick up any other \texttt{tindx} snapshot.
To pick up a solution and continue, it is probably best to do a little house-keeping with the command\\
\texttt{\$ e3post.py --job=name --prepare-restart}\\
This renames the 9999 flow files and tidies up the \textit{job}\texttt{.times} file to reflect the changes.
Then you should edit the \textit{job}\texttt{.control} file and change the parameters \texttt{dt}
\texttt{max\_time} and \texttt{max\_steps} to suitable values.
Do \underline{not} run \texttt{e3prep.py} again, else it will write all over 
your newly edited \textit{job}\texttt{.control} file.
At this point, you should be ready to run the main simulation program again.
Remember to supply the relevant \texttt{tindx} value on the command line for your restart.
For example:\\
\texttt{\$ e3shared.exe --job=name --tindx=5 --run}

\medskip
Also, with restarts, be careful that you have consistent modelling requirements and settings.
Restarting a laminar simulation as a turbulent simulation with the $k-\omega$ model would lead
to inconsistent data.
It may be better to start a new job and use \texttt{ExistingSolution} objects\footnote{We need to make \texttt{ExistingSolution} smart enough to fill in missing values.} (see Section\,\ref{sec:ExistingSolution}) to pick up the old data. 

\newpage
\subsection{Postprocessing (with e3post.py)}\index{postprocessing} 
\label{sec:e3post}
%
Postprocessing of the simulation data is the most unstructured of the simulation activities.
We provide a postprocessing program, \texttt{e3post.py} that has the basic capabilities of picking up 
the simulation data and writing flow field files in formats suitable for 
\texttt{Paraview}, \texttt{Visit}, \texttt{Tecplot}, the venerable \texttt{Plot3D} or 
\texttt{gnuplot}\footnote{See the web sites  \url{http://www.paraview.org}, \url{https://wci.llnl.gov/codes/visit/},
\url{http://www.tecplot.com}, \url{http://people.nas.nasa.gov/\~rogers/plot3d/intro.html} and \url{http://www.gnuplot.info}}.
\vspace{0.25cm} \\
\centerline{\includegraphics[width=0.7\textwidth]{figs/post-process.png}}\\

\medskip
To reformat the flow solution data into one unstructured grid
containing all of the flow data for the domain and write this data in a format suitable
for \texttt{Paraview} or \texttt{Visit}, use the command:\\
\texttt{\$ e3post.py --job=\textit{job} --vtk-xml --tindx=all}\\ \index{e3post.py!using}

\medskip
The postprocessing program (\texttt{e3\_post.py}) started as a fairly simple script that picked up solution data
and reformatted it for plotting, however, it has continued to sprout features and has become a bit 
complex to describe.
To see its command-line options, just run it without any options at all.
It should then print a \textit{usage} message which provides some hints.
As at October 2009, the start of this message is:

\noindent
{\footnotesize
\begin{verbatim}
Begin e3post.py...

Usage: e3post.py [--help] [--job=<jobFileName>] [--tindx=<index|all>]
                 [--zip-files|--no-zip-files]
                 [--vtk-xml] [--tecplot] [--plot3d]
                 [--prepare-restart] [--prepare-fstc-restart]
                 [--put-into-folders]
                 [--ref-function=<python-script>]
                 [--report-norms]
                 [--per-block-norm-list="jb,var-name,norm-name;..."
                 [--global-norm-list="var-name,norm-name;..."
                 [--compare-job=<jobFileName> [--compare-tindx=<index>]]
                 [--output-file=<profile-data-file>]
                 [--slice-list="blk-range,i-range,j-range,k-range;..."]
                 [--slice-at-point="blk-range,index-pair,x,y,z;..."]
                 [--slice-along-line="x0,y0,z0,x1,y1,z1,N"]
                 [--surface-list="blk,surface-name;..."]
                 [--add-pitot-p] [--add-total-p] [--add-mach] [--add-total-enthalpy]
                 [--add-molef --gmodel-file="gas-model.lua"]
                 [--probe="x,y,z;..."]
                 [--heat-flux-list="blk-range,surf-range,i-range,j-range,k-range;..."]
                 [--omegaz="[omegaz0,omegaz1,...]"]
                 [--tangent-slab-list="blk-range,i-range,j-range,k-range;..."]
\end{verbatim}
} % end of \footnotesize

\noindent
The options can be combined in fairly complex ways; some experimentation on the part of the user
may be required to get the desired effect.
\begin{itemize}
  \item \texttt{--help} just prints the usage message.  No other options are relevant.
  \item \texttt{--job=<jobFileName>} specifies the root name of the solution files
  \item \texttt{--tindx=<index|all} You may pick up one solution time via its index or you may
     specify all solution times via the keyword ``\texttt{all}''.
  \item \texttt{--zip-files|--no-zip-files} The default behaviour is to use gzipped files for the
     grid and flow data files, however, earlier version of the code used plain text files that were not zipped.
  \item \texttt{--vtk-xml} The XML format for the Visualization Tool Kit (VTK) is readable by both \texttt{Paraview}
     and \texttt{Visit}.
  \item \texttt{--tecplot} This produces an ASCII file that can be read by \texttt{Tecplot}.
  \item \texttt{--plot3d} This is also an ASCII format file that many visualization and flow simulation
     packages read and write.
     Two grid files are generated.  The first, with \texttt{.grd} extension, 
     is the true grid as used by the simulation with mesh location at the nodes.  
     The second, with extension \texttt{.g}, has cell-centred values and accompanies 
     the cell-centred values in the \texttt{.f} file.
  \item \texttt{--prepare-restart} does some house-keeping in the data files so that a simulation 
     may be restarted cleanly.  
     This is mainly dealing with the \texttt{9999} file and adjusting the \texttt{.times} file.
  \item \texttt{--put-into-folders} puts an old solution (which has its files all sitting in the current directory)
     into the current directory structure where the grid, flow and plot files have their own subdirectories.
  \item \texttt{--ref-function=<python-script>} compares the flow solution with a supplied Python function.
     The difference is output.
  \item \texttt{--report-norms} returns a dictionary of norms for all of the flow variables.
    The available norms are \texttt{L1}, \texttt{L2}, and \texttt{Linf} (maximum magnitude).
  \item \texttt{--per-block-norm-list="jb,var-name,norm-name;..."} returns the specified norms 
     for particular variables and blocks.  Sometimes just a little bit of information is required.
  \item \texttt{--global-norm-list="var-name,norm-name;..."} returns the specified norms,
     computed over the whole flow domain.
  \item \texttt{--compare-job=<jobFileName> [--compare-tindx=<index>]} compares one flow data set with another.
     The difference is output.  This option combined with the computation of norms is a convenient way to check
     convergence in of a simulation.
  \item \texttt{--output-file=<profile-data-file>} specifies the name of a file in which to dump the requested data.
     This naming option is relevant to the various slice options and also to the the surface-list option where
     where it is used as the root name of the generated VTK files.
     This will allow you to make a number of sliced data sets for plotting.
  \item \texttt{--slice-list="blk-range,i-range,j-range,k-range;..."} allows one to extract subsets of the data.
     A Python-like slicing notation is used in the specification string which should be enclosed in quotes, as shown. 
     Several slices (separated by semicolons) may be specified in the one string.
     Each slice specification consists of 4 indices or index ranges separated by commas.  
     An index is a single integer value and may be negative to indicate counting from the end.
     A value of \texttt{-1} indicates the maximum value.
     An index range may be a colon-separated pair of integers, a colon and one limit 
     or just a colon by itself (to indicate the full range).
     Note that the range limits are inclusive.
     So, for example, to extract the EAST strip of cells from block 0 in a 2D simulation, you would use
     the string \texttt{"0,-1,:,0"}.
  \item \texttt{--slice-at-point="blk-range,index-pair,x,y,z;..."} allows one to extract a slice/plane of data
     through a particular point.
     The index-pair is one of ij, jk or ki.  
     The program sets these indices to zero and searches along the remaining index to find the cell nearest 
     the specified (x,y,z) point.
     Once found, the slice over the index pair is selected for output (by adding it to the slice-list.
     Be aware that, for each block selected, slice-at-point will always select a slice to output, 
     even if it is not very close.
     Again, use quotes to hold the string together as it passed through the shell interpreter.
  \item \texttt{--slice-along-line="x0,y0,z0,x1,y1,z1,N"} generates a list of \texttt{N} sampled points between
     the specified end points.
     The sampled data is taken from the nearest cell-centre for eash sample point.
     No higher-order interpolation is done.
  \item \texttt{--surface-list="blk,surface-name;..."} extracts a set of surfaces from the full flow field and 
     writes them as VTK files.  
     Sometimes we want convenient access to the bounding surfaces of the blocks.
     Use \texttt{NORTH}, \texttt{EAST}, \texttt{SOUTH}, \texttt{WEST}, \texttt{TOP} and \texttt{BOTTOM} 
     as the surface names.
  \item \texttt{--add-pitot-p}, \texttt{--add-total-p}, \texttt{--add-mach} and \texttt{--add-total-enthalpy} add the
     named variable to the plotting data set, either for the full field (VTK, Tecplot and Plot3D format) or for sliced data.
     These flow variables are not in the Eilmer3 native flow solution file and must be reconstructed by \texttt{e3post.py}.
  \item \texttt{--probe="x,y,z;..."} reports the sampled data for the specified points.
     The selected data is written in gnuplot format.
  \item \texttt{--heat-flux-list="blk-range,surf-range,i-range,j-range,k-range;..."}\,\footnote{Dan Potter's heat flux code writes
     the heat fluxes for a collection of surfaces.  This was part of his PhD work.} extracts surface heat flux and cell Reynolds number data.
     The syntax is the same as the \texttt{--slice-list} option except that the second argument is the boundary index 
     (\texttt{NORTH}, \texttt{SOUTH}, \texttt{WEST}, \texttt{EAST}, \texttt{TOP} or \texttt{BOTTOM}).
     For 2D simulations, the block and boundary indices are sufficient to define the edge, 
     so you can then leave the \texttt{i-range}, \texttt{j-range} and \texttt{k-range} arguments blank.
     For 3D simulations you would need to specify either \texttt{i}, \texttt{j} or \texttt{k} to get a single line of cells.
     For any range, it is sufficient to give just a colon to get the full range.
     For the surface range, the order of the boundary names comes into play with \texttt{NORTH}=0 and \texttt{BOTTOM}=5.
\end{itemize}
Note that you must use double-quotes on some specification strings to prevent the command shell 
from pulling the string apart (or otherwise changing it) before giving it to \texttt{e3post.py}.

\medskip 
Ad hoc postprocessing\index{postprocessing!customized} is possible by picking up the cell-centre flow
data with your own custom postprocessing program written in Python.
Two Python modules (\texttt{e3\_flow.py}\index{module!e3\_flow.py} and \texttt{e3\_grid.py}\index{module!e3\_grid.py}) 
are available for picking up individual blocks of data and storing
selected flow properties in numpy arrays.
Note that three-dimensional arrays are always used, even for two-dimensional simulations
where the k-index has the single value 0.
The examples that make up the bulk of this manual show some of the things that are possible.
Two specific applications of writing a custom postprocessing script are the estimation of 
surface force on the 10$^o$ ramp case (Section \ref{simple-ramp-sec}) and 
finding the location of the bow shock for the finite cylinder simulation.

\subsection{Supervisory GUI}
%
To ease new-comers into the use of the codes, the \texttt{e3console.tcl} program provides
a graphical view of the simulation process.
It provides straight-forward automation of the simple case of running a simulation
from scratch and then reformatting the entire flow-field data for plotting.
Figure\,\ref{e3console-screenshot-fig} shows the state of the GUI just after running the
cone20 simulation.
The Python input file is shown in the top text frame of the main window, 
with the log of the standard output from the simulation shown in the lower text frame.
The tab for the postprocessor is visible in the ``Options'' window.
It indicates that \texttt{e3post.py} will reformat all the flow data into the XML
file format for the VTK plotting library (as used by Paraview).
Also, note the text in the console window which shows the underlying commands that have been used. 

\begin{figure}
 \includegraphics[width=\textwidth]{figs/e3console-screenshot.png}
 \caption{Screen shot of the \texttt{e3console.tcl} GUI running on PJ's workstation.}
 \label{e3console-screenshot-fig}
\end{figure}


\section{Input Script Overview}
Currently, \texttt{e3prep.py}\index{e3prep.py} is implemented as 
a Python program that has a library of classes specialized for constructing
geometric regions and specifying flow conditions.
Because your specification script, \texttt{{\em job}.py}, 
becomes a part of that program when it runs,
it is worth the effort to learn just enough Python to be dangerous.
The web site \url{http://www.python.org} is a good starting point for
learning about the Python programming language, however, Appendix\,\ref{python-notes-sec}
may have enough information to get you started.

\medskip
After doing some initialization, \texttt{e3prep.py} executes your
script file and assembles the geometry and flow specification data
into a form that can be given to the main simulation code
\texttt{e3shared.exe}\index{e3shared.exe}\footnote{The ``shared'' tag indicated that we are
  using the shared-memory version of the code.  
  There is also a distributed-memory version, \texttt{e3mpi.exe}\index{e3mpi.exe},
  based on message passing (MPI) that can be used for running the main simulation.
}.
The advantage of this approach is that you have the full capability of 
the Python interpreter available to you from within your script.
You can perform calculations so that you can parameterize your geometry, 
for example, or you can use Python control structures
to make repetitive definitions much more concise.
Additionally, you may use Python comments and print statements
to add documentation to the script file. 
An input script usually does the following:
\begin{enumerate}
  \item selects gas model
  \item optionally, creates geometric elements to assist in defining the boundary representation of the gas domain
  \item creates blocks within the gas domain and specifies their discretization and, optionally, 
        specifies boundary conditions along some block surfaces (in 3D) or edges (in 2D)
  \item specifies remaining boundary conditions, if any
  \item sets some simulation control parameters
\end{enumerate}
Most examples in this manual do just these things, however, it is possible to do much more.
The example that computes the heat transfer to a sphere (Section\,\ref{sphere-heat-transfer-sec}) uses a top-level Python
script to coordinate a number of simulations with increasingly-refined grids as a crude multigrid simulation.

\medskip
To aid with debugging, it is easy to process part of your input script and
then temporarily put the interpreter into an interactive mode where 
you may type python commands and expressions at the prompt (\texttt{>>>}).
To do so, add the following lines at the appropriate point in your input
script.\\
%
\topbar\\
\texttt{from code import interact}\index{e3prep.py!interactive mode}\\
\texttt{interact('Start interactive mode (Ctrl-D to return)', local=locals())}\\
\bottombar\\
%
Now you can interact with the Python environment and the objects that your
input script has defined so far.
For example, to find out a bit about defining \texttt{Block3D} objects, type:\\
%
\topbar\\
\texttt{>>> help(Block3D)}\\
\bottombar\\
%
To get out of the interactive mode and continue processing the input script,
type \texttt{Control-D} at the prompt.


%------------------------------------------------------------------
\section{Thermochemical model and flow conditions}
\label{thermo-flow-sec}\index{thermochemical models}\index{module!libgas}
%
The thermochemical models are provided by the \texttt{libgas} module.
This is primarily a C++ module but it has a SWIG-generated Python interface so
that its objects and methods can be accessed from the user's input script.

\subsection{10 second version: just tell me how to select perfect air}
Place the following text (which is a function call) in your script \emph{before}
specifying any \texttt{FlowCondition} objects:\\
%
\topbar\\
\texttt{select\_gas\_model(model='ideal gas', species=['air'])}\\ \index{select\_gas\_model}
\bottombar\\
%
If this is the only gas model that interests you for the present, then
proceed to page~\pageref{sec:flow_condition} which discusses the specification
of a \texttt{FlowCondition}.

\subsection{2 minute version: tell me about other simple models}

To select a gas model, the user calls the function
\texttt{select\_gas\_model}.
This function accepts three keyword arguments: \texttt{model},
\texttt{species}, and \texttt{fname}.
In the vast majority of cases, only the first
two keyword arguments will be used.
This function must be called \emph{before} specifying any \texttt{FlowCondition} objects
so that the complete thermodynamic state can be computed.

\medskip
A second example: to select an ideal mixture of nitrogen and oxygen
call:\\
%
\topbar\\
\texttt{select\_gas\_model(model='ideal gas', species=['N2', 'O2'])}\\
\bottombar\\
%
Note that the only difference between selecting a mixture and a single
component gas is the addition of extra species in the species list and the extra computation that
the main simulation program needs to do.

\medskip
In general, the \texttt{model} keyword accepts a string describing
the gas model behaviour.
The available gas models are:
\begin{itemize}
 \item \texttt{'ideal gas'}: a gas with ideal behaviour: modelled as having perfectly elastic collisions
                             and constant specific heats\index{gas model!ideal}
 \item \texttt{'thermally perfect gas'}: a gas with thermally perfect behaviour: modelled as having perfectly
                             elastic collisions but with specific heats that are functions of temperature
                             \index{gas model!thermally perfect}
% \item \texttt{'one temperature gas'}: similar to the 'thermally perfect gas' except that the thermodynamic 
%                             properties are calculated from statistical mechanics rather than the CEA curve 
%                             fits\footnote{Due to the assumption of decoupled thermal modes, the thermodynamic
%                             properties for the 'one temperature gas' model are not as accurate as the CEA curve
%                             fits.  The purpose of the this gas model is to provide a single temperature 
%                             equivalent of the multiple temperature gas models.  For general thermal equilibrium
%                             calculations, users are advised to use the 'thermally perfect gas' model.}, and
%                             transport properties are calculated via collision-integrals.
 \item \texttt{'two temperature gas'}: a thermally perfect gas\footnote{The two temperature gas model is thermally
                             perfect in the sense that the thermodynamic properties are functions
                             of temperature only, however multiple temperatures are defined.} with two independent
                             thermal modes: one temperature $T_\text{tr}$ governs the heavy-particle translation 
                             and rotation modes, and another temperature $T_\text{ve}$ governs the vibration, 
                             electronic and free-electron translation modes.
                             \index{gas model!two temperature}
% \item \texttt{'three temperature gas'}: a thermally perfect gas with three independent thermal modes: the 
%                             temperature $T_\text{tr}$ governs the heavy-particle translation and rotation modes,
%                             $T_\text{v}$ governs the vibration modes and $T_\text{e}$ governs the
%                             electronic and free-electron translation modes.
%                             \index{gas model!three temperature}
% \item \texttt{'four temperature gas'}: a thermally perfect gas with four independent thermal modes: the 
%                             temperature $T_\text{t}$ governs the heavy-particle translation modes, $T_{\text{r}}$
%                             governs the rotation modes, $T_\text{v}$ governs the vibration modes and $T_\text{e}$ 
%                             governs the electronic and free-electron translation modes.
%                             \index{gas model!four temperature}
 \item \texttt{'real gas Bender'}: a gas with real behaviour, such as accurate thermodynamic property evaluation
                            at high density and pressure near the saturation boundary and in the critical region.
                            This model is based on the Bender \textit{p-v-T} relationship.
                             \index{gas model!real gas!Bender}
 \item \texttt{'real gas MBWR'}: a gas with real behaviour, such as accurate thermodynamic property evaluation
                            at high density and pressure near the saturation boundary and in the critical region.
                            This model is based on the MBWR \textit{p-v-T} relationship, which is more accurate
                            than the Bender \textit{p-v-T} relationship.
                             \index{gas model!real gas!MBWR}
 \item \texttt{'real gas REFPROP'}: a gas with real behaviour, such as accurate thermodynamic property evaluation
                            in all single and two phase regions.
                            This model makes use of the REFPROP thermodynamic database and is more accurate than
                            the MBWR gas model.
                             \index{gas model!real gas!REFPROP}
\end{itemize}

The \texttt{species} keyword accepts a list of strings; each string denotes
a species in the mixture.  The order of this list is important: the order of
species in this list corresponds to the order in which the species mass fractions
are specified in other parts of the input.
To get a list of available species, look at the selection of species which are placed
in the \texttt{\$HOME/e3bin/species}\index{species!list of available} area during the install, 
that is, at a command prompt type:

\noindent
\topbar\\
\texttt{> ls \$HOME/e3bin/species}\\
\bottombar\\
%
The names of these files (excluding the \texttt{.lua} extension) correspond to the
names of available species.  The \texttt{defaults.lua} file is not a species name.
Rather, this file provides a set of default values when no other data is available.

\subsection{10 minute version: the detail of gas model configuration}
In the last two examples, the \texttt{select\_gas\_model} function was called using
the two keyword arguments \texttt{model} and \texttt{species}.
Behind the scenes, this function calls an auxiliary set of tools to build
a stand-alone text file which is a configuration file for the gas model.
This configuration file is a Lua-style file: it is read directly by the
C++ code (with embedded Lua interpreter) in order to configure the gas model.
By default, the created configuration file is called \texttt{gas-model.lua}.
This file will sit in your working directory after a successful call to
\texttt{select\_gas\_model} using only the \texttt{model} and \texttt{species} keyword
arguments.
The configuration file contains all the necessary details to completely
specify the gas.
Thus, this file serves as a record of the gas model input parameters used in
your simulation.

\medskip
You are encouraged to open the file \texttt{gas-model.lua} and take a look.
It contains not only the input parameters for the gas model but also references for the
data where possible.
Some amount of effort has been made to design a configuration file that
properly documents the input data.
The use of Lua as the configuration language has aided this effort.

\medskip
Alternatively, the \texttt{select\_gas\_model} function may also be called
with \texttt{fname} as a keyword argument.
This argument, \texttt{fname}, accepts a string which names a Lua-style configuration
file for the gas model.
Thus, if you have a gas model configuration file from a previous simulation, you could
set the gas model with the call:\\
%
\topbar\\
\texttt{select\_gas\_model(fname='gas-model.lua')}\\
\bottombar\\
%
This assumes your configuration file is called \texttt{gas-model.lua} and resides
in the same directory as your main simulation script.\index{gas model!gas-model.lua file}

\medskip
Finally, for certain advanced gas models (such as a gas with multiple vibrational temperatures),
the only means to configure these models is via the preparation of a Lua-style configuration
file by hand.
After building a file by hand (that is, in a text editor), one would use the \texttt{fname} keyword
argument in the call to \texttt{select\_gas\_model} to set the gas model.
The list of gas models which are set by directly creating a configuration file are:
\begin{itemize}
 \item user-defined gas (by specification of callable Lua functions)\index{gas model!user-defined}
 \item an equilibrium gas, based on a look-up table\index{gas model!look-up table}
 % DFP: this model is specified via 'thermally perfect gas'
 % \item a reacting mixture of thermally perfect gases\index{gas model!reacting}
\end{itemize}
Further discussion of gas models which are set by direct creation
and manipulation of a configuration file is given in Appendix~\ref{app:gas-models}.

\subsection{Selecting a simple model and adjusting it}
The simple ideal gas model of air as discussed above has $\gamma = 1.4$.
You can get an air model with $\gamma = 1.3$ by selecting the species
as \texttt{'air13'} or you can adjust the value of $\gamma$ directly
for the ideal gas model.
This can be done from within the Python input script by calling the function 
\texttt{change\_ideal\_gas\_attribute()},\index{gas model!change\_ideal\_gas\_attribute}
and telling it which species, which attribute and what new value to use.
The function actually does a string substitution within the \texttt{gas-model.lua} file
that was generated behind the scenes when the \texttt{select\_gas\_model()} function was called.

\medskip
For an example of use, see the MNM Implosion problem in Section\,\ref{mnm-implosion-sec}.
There, the value of ratio of specific heats is changed with the lines\\
%
\topbar\\
\texttt{gas\_gamma = 5.0/3.0}\\
\texttt{select\_gas\_model(model='ideal gas', species=['air'])}\\
\texttt{change\_ideal\_gas\_attribute('air', 'gamma', gas\_gamma)\\}
\bottombar\\
You might also like to change the gas constant but, since that is not an actual parameter in the 
\texttt{gas-model.lua} file, it needs to be set indirectly, via the molecular mass (in units of kg/mol).\\
\topbar\\
\texttt{Rgas = 300.0}\\
\texttt{MM = R\_u / Rgas}\\
\texttt{change\_ideal\_gas\_attribute('air', 'M', Rgas)\\}
\bottombar\\
Note that \texttt{'M'} is the label for molecular mass in the \texttt{gas-model.lua} file
and \texttt{R\_u} is the universal gas constant made available by the thermochemistry module
to the Python input script.


\subsection{Specifying chemically reacting flow}
\index{chemical reaction!reaction scheme file}
For chemically reacting flow simulations, the following function call is
required:\\
%
\topbar\\
\texttt{set\_reaction\_scheme(config\_file, reacting\_flag=1)}\\
\bottombar\\
where \texttt{config\_file} is a string naming the configuration file for the
chemical reaction scheme.  This configuration file specifies all of the chemical
reactions between the various species and is built by hand by the user.\index{chemical reaction}
By default, the reactions are turned on, however, the user may elect to turn off
chemical reaction updates by setting \texttt{reacting\_flag=0}.

\medskip
An example of a reacting flow simulation is given in Section~\ref{sec:n90}.
The details of building a chemistry input file are provided in Appendix~\ref{app:chem}.

\subsection{Specifying thermal energy exchange mechanisms}
\index{thermal nonequilibrium!energy exchange scheme file}
For flow simulations where the number of thermal modes is greater than one (such as for the 
`two temperature gas' model previously
mentioned), energy exchange mechanisms can be defined that describe the exchange of thermal
energy between modes due to particle collisions.
If such energy exchange mechanisms wish to be modelled, the following function call is
required:\\
%
\topbar\\
\texttt{set\_energy\_exchange\_update(config\_file)}\\
\bottombar\\
where \texttt{config\_file} is a string naming the Lua configuration file for the
energy exchange scheme.  This configuration file specifies all of the energy exchange 
mechanisms between the thermal modes due to thermal processes (i.e. particle collisions) 
and is built by hand by the user.\index{thermal energy exchange}
Thermal energy exchange is automatically turned on when the
\texttt{set\_energy\_exchange\_update(config\_file)} function call is made.

\medskip
An example of a flow simulation with thermal energy exchange is given in
Section~\ref{sec:finite-cyl-sec}.
The details of building a thermal energy exchange input file are provided in 
Appendix~\ref{app:therm-exchange}.

\subsection{Defining flow conditions}
\label{sec:flow_condition}
Because \texttt{Eilmer3} is a flow \textit{simulation} code, initial gas flow conditions
need to be specified throughout the domain.
Also, depending on your model, free-stream inflow boundary conditions 
may need to be specified on appropriate boundary surfaces.
To define such a flow condition in your input script for one or both of these purposes, 
create a \texttt{FlowCondition} object\footnote{The \texttt{FlowCondition} class is
  defined in source file \texttt{e3\_flow.py}} as:
\texttt{
\begin{tabbing}
my\_flow = FlowCondition(\=p=1.0e5, u=0.0, v=0.0, w=0.0, \\
                         \>Bx=0.0, By=0.0, Bz=0.0, T=[300.0,], \\
                         \>massf=None, label="", tke=0.0, omega=1.0, \\
%                         \>sigma\_T=0.0, sigma\_c=0.0, 
                         \>S=0, add\_to\_list=1)
\end{tabbing}
}\index{FlowCondition}\index{FlowCondition!add\_to\_list parameter}

%
\begin{itemize}
  \item \texttt{p}: pressure in Pa, default value 100\,kPa.
  \item \texttt{u}: $x$-coordinate velocity in m/s, default value 0.0.
  \item \texttt{v}: $y$-coordinate velocity in m/s, default value 0.0.
  \item \texttt{w}: $z$-coordinate velocity in m/s, default value 0.0.
  \item \texttt{Bx}: $x$-coordinate magnetic field in Tesla, default value 0.0.
  \item \texttt{By}: $y$-coordinate magnetic field in Tesla, default value 0.0.
  \item \texttt{Bz}: $z$-coordinate magnetic field in Tesla, default value 0.0.
  \item \texttt{T}: list of temperatures in degrees K, default value [300.0,].
    For gas models with multimodal energies, these are the corresponding temperatures.
    For a gas model with only one internal energy mode, you may specify a scalar value
    for temperature.
  \item \texttt{massf}: mass fractions of the component species.
    These may be provided in a number of ways:
    \begin{itemize}
      \item[(a)] full list of floats. The length of the list of mass fractions 
         must match the number of species in the previously selected gas model.
      \item[(b)] single float or integer that gets used as the first element,
         the rest being set 0.0
      \item[(c)] dictionary of species names with mass fraction values,
         the remainder being set 0.0.  See the example in Section\,\ref{sec:MoleFractions}.
      \item[(d)] None provided, results in the first element being 1.0
         and the rest 0.0
    \end{itemize}
    Note that the mass fractions supplied must sum to 1.0 (within a tolerance of $1.0 \times 10^{-6}$.
  \item \texttt{label}: (optional) text label for the FlowCondition object.
  \item \texttt{tke}: turbulent kinetic energy per unit mass in m$^2$/s$^2$ or
    J/kg, default value 0.0.
  \item \texttt{omega}: turbulence vorticity in 1/s, default value 1.0.
  \item \texttt{mu\_t}: turbulence viscosity in Pa.s, default value 0.0.
  \item \texttt{k\_t}: turbulence thermal conductivity, default value 0.0.
     This might be conveniently computed as $C_p \mu_t / Pr_t$.
%  \item \texttt{sigma\_T}: variance of temperature variations, default value 0.0.
%  \item \texttt{sigma\_c}: variance of species concentrations, default value 0.0.
  \item \texttt{S}: integer shock indicator value, default value 0.
    A value of 1 indicates the presence of a shock through the cell.
  \item \texttt{add\_to\_list}: flag to indicate that this FlowCondition object 
    should be added to the flowList.  Sometimes we don't want
    to accumulate objects in this list, for example, when using
    many FlowCondition objects in a user-defined flow evaluation function.
    default value 1.
\end{itemize}

\medskip
Simulations involving nonequilibrium chemistry require and extra input file
describing the participating gas species and their reactions.
Preparation of this file is described in Appendix\,\ref{app:chem}.

\subsection{Using flow conditions from other simulations}
\label{sec:ExistingSolution}
%
There are occasions where you might like to use flow data from an old simulation
as initial conditions for some or all of your blocks in your new simulation.
A typical use case is to restart a simulation with a finer, or otherwise changed, mesh.
For this, you may pick up the old simulation data using:\\
\index{ExistingSolution}
\texttt{
\begin{tabbing}
old\_flow = ExistingSolution(\=rootName, solutionWorkDir, nblock, tindx, \\
                             \>dimensions=2, assume\_same\_grid=0, zipFiles=1, \\
                             \>add\_velocity=Vector(0.0,0.0,0.0))\\
\end{tabbing}
}\index{ExistingSolution}
where the arguments and their possible values are:
\begin{itemize}
  \item \texttt{rootName}: job name that will be used to build file names
  \item \texttt{solutionWorkDir}: the directory where we'll find our existing solution files.
  \item \texttt{nblock}: number of blocks in the existing solution data set
  \item \texttt{tindx}: the time index to select 0..9999.
            Do not specify with leading zeros because the Python interpreter
            will assume that you want to count the time index in octal.
  \item \texttt{dimensions}: number of spatial dimensions for the existing solution
  \item \texttt{assume\_same\_grid}: decide how to locate corresponding cells
     \begin{itemize}
        \item[\texttt{0}]: searches for corresponding cells. This steps through each cell and
		searches for closest corresponding cell centre in the old solution and inserts
		the flow data.
                As Rainer found, this can be agonisingly slow for large grids.\index{Kirchhartz}
        \item[\texttt{1}]: omits the search for the corresponding cell.
                Definitely the option for the impatient. This assumes the same grid for the old and
		new solution and inserts flow data based on the i and j cell references.
     \end{itemize}
   \item \texttt{zipFiles}: to use gzipped files (1), or not (0)
   \item \texttt{add\_velocity}: value to be added to each cell's velocity,
       for changing frame of reference.
\end{itemize}
The process of writing the data into each cell of the new grid uses a fairly naive search for the 
nearest cell in the existing solution.
Although it is robust, the search is extremely slow and the preparation of sew grids has been known
to take hours of CPU time.
If the new simulation is a continuation of the old simulation, it may be appropriate to set
\texttt{gdata.t0} to a nonzero value.  See Section\,\ref{sec:sim-control-parameters}.

\subsection{Using mole fractions and species dictionaries}
\label{sec:MoleFractions}
%
When simulating flows with mixes of gas species, it may be more convenient to specify the gas mix
via mole fractions rather than mass fractions and via a dictionary rather than a list.
With large numbers of species in the gas model, specification of the mix via dictionary is far easier to
read and check than when using a list of numerical values. 

\medskip
There are a number of functions attached to the \texttt{Gas\_model} object that make the
conversion to a list of mass fractions easy.
Here is an extract from Umar's standing-shock script showing the creation of a fairly complex gas mix
using a dictionary of mole fractions.

\medskip\noindent\topbar\\
{\small %\scriptsize
\begin{verbatim}
select_gas_model(model='thermally perfect gas', 
                 species=['O', 'N', 'N2', 'O2', 'NO', 'N_plus', 'O_plus', 'N2_plus',
                          'O2_plus', 'NO_plus', 'e_minus', 'Ar', 'Ar_plus'])
set_reaction_scheme("gupta_etal_air_reactions.lua", reacting_flag=1)
gmodel = get_gas_model_ptr()

# Pre-shock gas: mass fractions for an ideal air mixture.
mi = {'N2':0.769, 'O2':0.231}
# Post-shock: mole fractions from a CEA calculation.
X = {'O':1.6936e-1, 'N':5.9784e-1, 'N2':6.9757e-5, 'O2':4.7543e-8, 'NO':2.5654e-3, 
     'N_plus':9.6331e-2, 'O_plus':1.7562e-2, 'N2_plus':7.7688e-6, 'O2_plus':5.0837e-8, 
     'NO_plus':1.4459e-5, 'e_minus':1.1436e-1, 'Ar':4.0026e-3, 'Ar_plus':4.4835e-4}

initial = FlowCondition(p=2700.0, u=0.0, v=0.0, T=300.0, massf=mi)
inflow  = FlowCondition(p=4464.0, u=10284.0, v=0.0, T=10140.42,
                        massf=gmodel.to_massf(X))
\end{verbatim}
}
\noindent\bottombar


%-------------------------------------------------------------------
\section{Boundary representation of the gas domain}
%
Most of the effort required to set up a simulation goes into defining the
``body-fitted'' grid of finite-volume cells that completely fills the flow
domain.
The top-level geometry description given to the grid generator is in terms of
``patches'' for 2D flow and ``parametric volumes'' for 3D flow.
These are regions of space that may be traversed by
a set of parametric coordinates $0 \le r < 1$, $0 \le s < 1$ (in 2D) and 
with the third parameter $0 \le t < 1$ in 3D.
These patches or volumes can be imported as VTK structured grids or they can be
constructed as a ``boundary representation'' from lower-dimensional 
geometric entities such as paths and points.

\subsection{Geometric elements}
%
The most fundamental class of geometric object is the \texttt{Vector}\index{geometric element!Vector} (or
\texttt{Vector3}\index{geometric element!Vector3} as it is defined in the C++ module \texttt{libgeom2}\index{module!libgeom2}).
A \texttt{Vector} represents a point in 3D space and has the usual behaviour 
of a geometric vector (as opposed to the \texttt{vector} collection class in
C++).
See, for example, the postprocessing program in the \texttt{simple\_ramp}
simulation (Section\,\ref{simple-ramp-post-files}).
If you want a point to be rendered with a label, you can define it as a
\texttt{Node}.
Examples of use include: $a$ = \texttt{Vector}($x$, $y$, $z$) and
$b$ = \texttt{Node}($x$, $y$, $z$, \texttt{label='B'}).\index{geometric element!Node}

\medskip
It is also possible to 'get' and 'set' values within a geometric element. For example to
create a node, extract the x value of that node, to change the y value or to use
the geometry values for a new node could be done as follows.\\
\topbar\\
\texttt{a = Node(0.5,0.8,label='Node a')}\\
\texttt{x-value = a.x}\\
\texttt{a.y = 0.6}\\
\texttt{b = Node(a.x, a.y+0.2,label='Node b')}\\
\bottombar\\

\medskip
If you look into the file \texttt{cfcfd3/lib/geometry2/source/geom.hh}, you will see that
the \texttt{Vector3} objects support the usual vector operations of addition, subtraction and the like.
Also, you can \texttt{clone} and transform a point.
For example, to create a point and its mirror image in the (x,z)-plane, you could use\\
\topbar\\
\texttt{a = Vector(0.5, 0.6)}\\
\texttt{b = a.clone().mirror\_image(Vector(0.0,0.0), Vector(0.0,1.0)}\\
\bottombar\\
 
\subsubsection{Paths}
%
The next level of dimensionality is the \texttt{Path} class\index{geometric element!Path}.
A path object is a parametric curve in space, 
along which points can be specified via the single parameter $0 \le t < 1$.
Types of paths that are available include:
\begin{itemize}
\item \texttt{Line}($a$, $b$): a straight line between points $a$ and $b$.\index{geometric element!Line}
\item \texttt{Arc}($a$, $b$, $c$): a circular arc from $a$ to $b$ around centre,
  $c$.\index{geometric element!Arc}
  Be careful that you don't try to make an \texttt{Arc} with included angle of 180$^o$ or greater.
  For such a situation, create two circular arcs and join as a \texttt{Polyline} path.
\item \texttt{Arc3}($a$, $b$, $c$): a circular arc from $a$ through $b$ to $c$.
  All three points lie on the arc.\index{geometric element!Arc3}
\item \texttt{Helix}($a_0$, $a_1$, $x_{local}$, $r_0$, $r_1$, $d\theta$): a helical path
  about a specified axis, start and end radii and angle through which the path extends.\index{geometric element!Helix}
\item \texttt{Helix}($p_0$, $p_1$, $a_0$, $a_1$): a helical path through specified points
  and about a specified axis.
  Internally, it is stored as the helical path described above.
\item \texttt{Bezier}([$b_0, b_1, ..., b_n$]): a Bezier curve from $b_0$ to
  $b_n$.\index{geometric element!Bezier}
\item \texttt{Nurbs}($CP[.]$, $w[.]$,$degree$, $U[.]$): nonuniform rational B-spline with
  control points vector $CP[.]$, weights vector $w[.]$, and knot vector $U[.]$.\index{geometric element!Nurbs}
\item \texttt{Polyline}([$p_0, p_1, ..., p_n$]): a composite path made up of 
  the segments $p_0$, through $p_n$.\index{geometric element!Polyline}
  The individual segments are reparameterised, based on arc length, so that
  the composite curve parameter is $0 \le t < 1$.
\item \texttt{Polyline2}(*args): a composite path constructed from path elements and/or \texttt{Vector} points.
  If there are gaps between the elements and points, 
  they will be filled with \texttt{Line} segments.\index{geometric element!Polyline2}
\item \texttt{Spline}([$b_0, b_1, ..., b_n$]): a cubic spline from $b0$ through
  $b1$, to $bn$.\index{geometric element!Spline}
  A \texttt{Spline} is actually a specialized \texttt{Polyline}.
\item \texttt{Spline2}(filename): a spline constructed from a file containing $x(,y(,z))$ coordinates
  of the interpolation points, one point per line.
  If the $y$ or $z$ values are missing, they are assumed to be zero.\index{geometric element!Spline2}
\item \texttt{PathOnSurface}($S$, $f_r$, $f_s$): a path on the
  ParametricSurface $S(r,s)$, defined by the univariate functions 
  $r=f_r(t)$ and $s=f_s(t)$.\index{geometric element!PathOnSurface}
\item \texttt{PolarPath}($P$, $H$): A path in 3D space made from another path, $P$,
  such that the neutral plane at height $H$ is wrapped around a cylinder aligned with
  the x-axis.\index{geometric element!PolarPath}
\item \texttt{PyFunctionPath}($f$): a path defined by the user-supplied Python function, $f(t)$.
  The user function returns a tuple of three values representing the point in space 
  for parameter value $t$.\index{geometric element!PyFunctionPath}
\end{itemize}

Most \texttt{Path} objects (except \texttt{PyFunctionPath}) support the transformation methods
\texttt{translate(displacement)}, 
\texttt{reverse()}, 
\texttt{mirror\_image(point, normal)} and \\
\texttt{rotate\_about\_zaxis(radians)}.
Look in the source code files \texttt{gpath.hh} and \texttt{gpath.cxx} for details.
These may be found in the directory \texttt{cfcfd3/lib/geometry2/source/}.

\subsubsection{Surfaces}
%
The \texttt{ParametricSurface}\index{geometric element!ParametricSurface} class 
represents two-dimensional objects which can be constructed from \texttt{Path} objects.
Examples are:
\begin{itemize}
\item \texttt{CoonsPatch}($p_S, p_N, p_W, p_E$): a transfinite interpolated
  surface between the four paths.\index{geometric element!CoonsPatch}
  It is expected that the paths join at the corners of the patch, such that
  $p_S(0) = p_W(0) = p00$, $p_S(1) = p_E(0) = p10$, $p_N(0) = p_W(1) = p01$ and $p_N(1) =  p_E(1) = p11$.
  See the left part of Figure\,\ref{block2d-defn-fig} for the layout of this surface.
  Note that, although we are using subscripts aligned with the BOTTOM and TOP
  surfaces in this description, the same order is used for the other surfaces
  when the local surface parametric directions are aligned with the relevant index
  directions.
  See the debugging cube in Appendix\,\ref{cube-development}.
  Be aware that the order of the supplied paths for each surface is (SOUTH, NORTH, WEST, EAST),
  which is different to the order accepted by the \texttt{make\_patch()} function 
  that is used to make two-dimensional grids in the following section.  
  Finally, it is important to be careful with the orientation of the \texttt{Path}
  elements that form the patch boundaries.
  The NORTH and SOUTH boundaries progress WEST to EAST as shown in Figure\,\ref{block2d-defn-fig}
  (in the following section).
  The WEST and EAST boundaries progress SOUTH to NORTH.
  If the \texttt{e3prep.py} program complains that the corners of your patch are ``open'',
  that may be a symptom of having one, or more, of your bounding paths having incorrect orientation.
\item \texttt{AOPatch}($p_S, p_N, p_W, p_E$): an interpolated surface \index{geometric element!AOPatch}
  that tries to keep the grid orthogonal near the edges and 
  also tries to keep equal areas across the surface.
\item \texttt{MeshPatch}: a surface defined over a structured mesh of
  quadrilateral facets.\index{geometric element!MeshPatch}
  This might be useful for generating new grids from files imported from
  an external grid generator.
\item \texttt{TrianglePatch}: a surface defined over an unstructured mesh of
  triangular facets.\index{geometric element!TrianglePatch}
  When the surface is really too complex to describe as a simpler form,
  this type of surface can conform (approximately) to just about anything.
\item \texttt{BezierPatch}: a surface defined over a tensor product of Bezier curves.\index{geometric element!BezierPatch} 
\item \texttt{RevolvedSurface}($p$): a surface defined by rotating Path $p$
  about the $x$-axis.\index{geometric element!RevolvedSurface}
  When calling the \texttt{eval(r,s)} method for this surface, 
  the first parameter, \texttt{r}, is along the path and the second parameter, 
  \texttt{s}, is the angle in the ($y,z$)-plane.
\item \texttt{MappedSurface}($S_{query}$, $S_{true}$)\index{geometric element!MappedSurface}: points on the
  query surface are projected onto the true surface.
  The final surface is a subset of the true surface.
  Usually the query surface is something simple like a \texttt{CoonsPatch}
  that is close to the shape of the desired grid and
  the true surface could be constructed as a \texttt{RevolvedSurface} which is
  a bit difficult to grid regularly.
\item \texttt{PolarSurface}($S$, $H$): A surface in 3D space made from another surface, $S$,
  such that the neutral plane at height $H$ is wrapped around a cylinder aligned with
  the x-axis.\index{geometric element!PolarSurface}
\item \texttt{SurfaceThruVolume}($V$,$f_r$,$f_s$,$f_t$)\index{geometric element!SurfaceThruVolume}: a surface through the
  ParametricVolume $V(r,s,t)$, defined by the univariate functions 
  $r=f_r(t)$, $s=f_s(t)$ and $t=f_t(t)$.
\item \texttt{NurbsSurface}\index{geometric element!NurbsSurface}: a surface defined as the tensor product of non-uniform rational B-splines.
\item \texttt{PyFunctionSurface}($f$)\index{geometric element!PyFunctionSurface}: a surface defined by the user-supplied Python function, $f(r,s)$.
  The user function returns a tuple of three values representing the point in 3D space 
  for parameter values $r$ and $s$.
  If you are trying to build a 2D simulation, just return the z-coordinate as zero.
\end{itemize} 

Except for \texttt{PyFunctionSurface}, most of the surface objects can be cloned and transformed
with \texttt{translate}, \texttt{mirror\_image} and \texttt{rotate\_about\_zaxis} methods.
Again, see the source code for details.


\subsubsection{Volumes}
%
Finally, in its most general form, a 
\texttt{ParametricVolume}($S_N, S_E, S_S, S_W, S_T, S_B$) \index{geometric element!ParametricVolume}
can be constructed from
a set of six parametric surfaces to form a body-fitted hexahedral volume.
More restricted forms of a volume can be constructed as
\begin{itemize}
\item \texttt{WireFrameVolume}($p_{01}, p_{12}, p_{32}, p_{03}, p_{45},
  p_{56}, p_{76}, p_{47}, p_{04}, p_{15}, p_{26}, p_{37}$): \index{geometric element!WireFrameVolume} is defined by its
  12 edges (paths).
  Note the implied directions in the subscripts.
  The subscripts correspond to the labelled points in Figure\,\ref{block-defn-fig}.
\item \texttt{WireFrameVolume}($surf, p$): consists of a surface $surf$
  extruded along path $p$.
  The extrusion is actually done be forming a set of 6 surfaces by copying the
  original surface and then constructing four \texttt{CoonsPatch} surfaces
  between them. 
\item \texttt{SimpleBoxVolume}($p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7$): \index{geometric element!SimpleBoxVolume}
  consists of a straight-edged hexahedral box
  defined by its 8 corner points (as shown in Figure\,\ref{block-defn-fig}).
\item \texttt{MeshVolume}\index{geometric element!MeshVolume}: consists of a \texttt{ParametricVolume}
  interpolated in an existing mesh.
  This mesh may be specified as an array of points or it may be read in from a
  VTK file.
\end{itemize}
There is an alternative approach to defining the ParametricVolume via a user-supplied
Python function as
\begin{itemize}
 \item \texttt{PyFunctionVolume}($f$)\index{geometric element!PyFunctionVolume}: a volume defined by the user-supplied Python function, $f(r,s,t)$.
  The user function returns a tuple of three values representing the point in 3D space 
  for parameter values $r$, $s$ and $t$.
\end{itemize}

Again, transform methods such as \texttt{translate} and \texttt{rotate\_about\_zaxis} may help in 
reducing the amount of user input script required to build complex regions out of multiple \texttt{ParametricVolume}
objects.

%------------------------------------------------------------------
\subsection{Two-dimensional grids}\index{grid!2D}
%
The grid defining the discretized gas domain is block structured. 
In 2D, each block is a patch bounded by 4 edges (NORTH, EAST, SOUTH and WEST) such that
we are looking at a plan-view of the flow domain as shown in Fig.\,\ref{block2d-defn-fig}.

\begin{figure}[htbp]
\mbox{
\includegraphics[width=0.5\textwidth,viewport=34 102 524 671,clip=true]{figs/block2d-defn.pdf}
\includegraphics[width=0.5\textwidth,viewport=34 102 524 671,clip=true]{figs/superblock2d-defn.pdf}
}
\caption{A two-dimensional patch containing the structured mesh for a Block2D object (left)
    and a collection of sub-blocks defined via a SuperBlock2D or MultiBlock2D constructor (right).
    The orientations of the bounding paths are important:  
    WEST and EAST paths progress from SOUTH to NORTH;
    SOUTH and NORTH paths progress from WEST to EAST.}
\label{block2d-defn-fig}
\end{figure}

\medskip
To define a block in your input script for a 2D simulation, create a \texttt{Block2D} object as:
\texttt{
\begin{tabbing}
my\_2d\_block = Block2D(\=psurf=None, grid=None, \\
                        \>import\_grid\_file\_name=None, nni=2, nnj=2, \\
                        \>cf\_list=[None,]*4, bc\_list=[SlipWallBC(),]*4, \\
                        \>fill\_condition=None, hcell\_list=[], \\
                        \>xforce\_list=[0,]*4, label="", active=1)
\end{tabbing}\index{block!Block2D}
}
%
\noindent
where the assignment to the name \texttt{my\_2d\_block} allows easy referencing of
the block at later times, say, for adding boundary conditions.
The names of the actual arguments given above match the actual arguments in
the \texttt{e3prep.py} program and these represent\footnote{The
  definitive source is, of course, the \texttt{Block2D} class definition in 
  \texttt{e3\_block.py}\index{module!e3\_block.py}. }:
\begin{itemize}
\item \texttt{psurf}: a region of 2D space bounded by 4 edges.
    This region is often constructed from 4 geometric paths via a call to
    \texttt{make\_patch(north, east, south, west, grid\_type)}\index{make\_patch} where the
    default value for \texttt{grid\_type} is ``TFI'' \textit{i.e.} transfinite interpolation
    or Coons' patch.\index{grid!TFI}\index{grid!transfinite interpolation}
    Another possible form of grid is ``AO'', the area-orthogonality grid.\index{grid!AO}\index{grid!area orthogonality}
    This is the usual way of specifying the flow domain, which will be discretized 
    using \texttt{nni, nnj, and cf\_list}.
    Note that all geometric elements should have zero values for their z-components when
    doing a 2D flow simulation.
    Since most constructors will have a default value of zero for the z-component, this
    detail can usually be ignored.
\item \texttt{grid}: a \texttt{StructuredGrid} object may be supplied (defaults to None). 
\item \texttt{import\_grid\_file\_name}\index{import\_grid\_file\_name} defaults to None.
  If a name is supplied, this file is read to obtain the grid directly.
  The assumed file format in the legacy (ASCII) VTK format for a structured grid.
\item \texttt{nni} is the number of finite-volume cells in the $i$-index
  direction. See the left part of Figure\,\ref{block2d-defn-fig} for the orientation of the index.
  Note that, when placing one block against another, the blocks must conform in
  \begin{itemize}
    \item the number of cells along corresponding edges
    \item the clustering of those cells along the edges
    \item the path defining the corresponding edges.
  \end{itemize}
  The minimum number of cells is 2, because of the way that the cell-interface values are 
  reconstructed from cell-centred data.
\item \texttt{nnj} is the number of finite-volume cells in the $j$-index direction.
\item \texttt{cf\_list} \label{cflist-item} is an optional list of 4 \texttt{UnivariateFunction} objects
  that specify a (possibly) nonuniform distribution of cells along each particular edge.
  \index{clustering!See univariate function}
  For each object, there is an \texttt{eval(t)} method which returns a transformed (new) value of $t$.
  The options available are:
  \begin{itemize}
    \item \texttt{LinearFunction(m, c)}\index{univariate function!LinearFunction}
      where $t_{new} = m \times t_{old} + c$.
    \item \texttt{LinearFunction2(y0, y1)}\index{univariate function!LinearFunction2}
      where $t_{new} = y0 \times (1-t_{old}) + y1 \times t_{old}$.
    \item \texttt{RobertsClusterFunction(end0, end1, beta)}\index{univariate function!RobertsClusterFunction}
      where the \texttt{end0, end1} integer flags indicate which end (possibly both) we wish to cluster toward.
      The value of \texttt{beta} $> 1.0$ specifies the strength of the clustering, with the clustering
      being stronger for smaller values of \texttt{beta}.
      For example, a value of 1.3 would be relatively weak clustering while a value of 1.01 is quite strong
      clustering.
    \item \texttt{ValliammaiFunction(dL0, dL1, L, n)}\index{univariate function!ValliammaiFunction}
      See Adriaan's source code for definitions.
  \end{itemize}
  See the files \texttt{lib/nm/source/fobject.cxx} and \texttt{lib/nm/source/fobject.hh} for details.
  The order of appearance of boundaries in the list is NORTH, EAST, SOUTH and WEST.
  Note that a full list of 4 items is required.
  If you don't want to specify one (or more) of the items in the list, specify \texttt{None} as that item.
\item \texttt{bc\_list} is an optional list of BoundaryCondition objects.\footnote{Note that, 
  when creating these objects in the Python input script, the Python language requires the parentheses
  even for the cases where no arguments, such as \texttt{Twall}, are required. }
  Available boundary conditions are:\index{boundary conditions!list of available}
  \begin{itemize}\index{boundary conditions}
    \item \texttt{AdjacentBC()}\index{boundary conditions!AdjacentBC} for cases where one block interfaces with another.
    \item \texttt{SupInBC(inflow\_condition, label='')}\index{boundary conditions!SupInBC} where we want to specify the inflow condition
      that gets copies into the ghost cells each time step.
      The optional \texttt{label} has an empty default value but may be used to group boundary surfaces symbolically
      in the postprocessing stage.
      Paul Petrie-Repar has made use of these labels in his \texttt{CGNS} postprocessing program.
    \item \texttt{ExtrapolateOutBC(x\_order=0, sponge\_flag=0, label='')}\index{boundary conditions!ExtrapolateOutBC} where we want a (mostly supersonic) outflow
      condition.
      Flow data is effectively copied (\texttt{x\_order=0}) or linearly-extrapolated (\texttt{x\_order=1})
      from just inside the boundary to the ghost cells just outside the boundary, every time step.
      In subsonic flow, this can lead to unphysical bahaviour.
    \item \texttt{SlipWallBC(label='')}\index{boundary conditions!SlipWallBC} where we want a solid wall with no viscous effects.
      This is the default boundary condition where no other condition is specified.
    \item \texttt{AdiabaticBC(label='')}\index{boundary conditions!AdiabaticBC} where we want viscous effects to impose no-slip at the wall
      but where there is no heat transfer.
    \item \texttt{FixedTBC(Twall, label='')}\index{boundary conditions!FixedTBC} where we want viscous effects to impose a no-slip velocity 
      condition and a fixed wall temperature.
    \item \texttt{SubsonicInBC(stagnation\_condition, label='')}\index{boundary conditions!SubsonicInBC} where the flow is assumed subsonic and
      we specify the stagnation pressure and temperature, but take the velocity from just inside
      the boundary.
    \item \texttt{TransientUniBC(filename, label='')}\index{boundary conditions!TransientUniBC} where we want to specify the time-history of
      the inflow condition.
    \item \texttt{StaticProfileBC(filename, label='')}\index{boundary conditions!StaticProfileBC} where we want to apply a steady-state inflow
       which may vary in space.
    \item \texttt{FixedPOutBC(Pout, x\_order=0, label='')}\index{boundary conditions!FixedPOutBC} 
      is like \texttt{ExtrapolateOutBC()} but with a specified back pressure.
      This can be analogous to a vacuum pump that removes gas at the boundary to maintain
      a fixed pressure in the ghost cells.
    \item \texttt{UserDefinedBC(filename, is\_wall=0, use\_udf\_flux=0, label='')}\index{boundary conditions!UserDefinedBC}: 
       allows the user to define the ghost-cell flow properties and/or interface fluxes at run time.
       This is done via a set of functions defined by the user, and written in the Lua
       programming language.
       These functions are provided in the file given by \texttt{filename}.
       The flag \texttt{is\_wall} indicates whether the boundary is to be considered
       a wall for the application of turbulence-model fudges and the like (default 0).
       The flag \texttt{use\_udf\_flux} indicates whether the user is supplying
       the fluxes at the boundary interfaces (default 0).  
       If not, the internal flux calculator is used together with the supplied ghost-cell data.
       This boundary condition is the Jack of all trades and master of none.
       It can be used to emulate any of the other boundary conditions and then build
       variations, however, it is going to cost quite a lot in computational time.
       See Appendix\,\ref{udf-sec} for the details of setting up this boundary condition.
    \item \texttt{AdjacentPlusUDFBC(other\_block, other\_face, orientation, filename, \\is\_wall=0, use\_udf\_flux=0, label='')}\index{boundary conditions!AdjacentPlusUDFBC}: 
       is a combination of the \texttt{AdjacentBC} and \texttt{UserDefinedBC}.
       At each time step, the flow data is first exchanged, as per the usual
       \texttt{AdjacentBC}.  Then the user-defined functions are applied.
       This is one way of getting fancy boundary conditions, such as slowly-opening diaphragms,
       into the simulation.
  \end{itemize}
  These boundary conditions may also be set, one at a time, as described in the 
  Section\,\ref{setting-boundary-conditions-sec}.
\item \texttt{fill\_condition} is the \texttt{FlowCondition} object with which to
  define the initial flow state within the volume.
  See Section\,\ref{thermo-flow-sec} for defining a suitable flow condition.
  You may alternatively provide a Python function that supplies the flow properties as
  a function of position or you may use an \texttt{ExistingSolution()} object.
\item \texttt{hcell\_list} is a list of ($i,j$)-tuples specifying which
  cells should be monitored at simulation time.
  Data from the specified cells will be written to a ``history'' file for the
  block and may be used at the postprocessing stage to provide flow data as if
  there was a sensor located in the cell.
\item \texttt{xforce\_list}\index{xforce\_list} is an optional list of zeros/ones that indicate if we
  want the force to be calculated for each of the four edges and written to the 
  \texttt{e3shared.log} log file.
  See the notes in the 20$^o$ cone test case (Section\,\ref{cone20-simple-sec}) for an
  example of how to extract this data from the log file. 
\item \texttt{label} is an optional text label for the block.  This label
  will be embedded in the block definition and some of the postprocessing
  programs may use it.
  For example, the \texttt{e3cgns.py} postprocessing program uses labels to group block boundaries symbolically.
\end{itemize}
Note that, when lists of items are provided for the four boundaries,
the order of the boundaries is NORTH, EAST, SOUTH and WEST.
 

\medskip
When defining large domains and running simulations of a parallel computer, 
it may be convenient to define many Block2D objects with one call.
The first of two constructors for this situation is
\texttt{
\begin{tabbing}
my\_block\_list = SuperBlock2D(\=psurf=None, nni=2, nnj=2, nbi=1, nbj=1, \\
                               \>cf\_list=[None,]*4, bc\_list=[SlipWallBC(),]*4, \\
                               \>fill\_condition=None, hcell\_list=[], label="sblk")
\end{tabbing}\index{block!SuperBlock2D}
}
\noindent
which generates a single grid over \texttt{psurf} and then subdivided that grid
into \texttt{nbi} $\times$ \texttt{nbj} Block2D sub-blocks.
References to all of these sub-blocks are returned as a list of lists, such that
a particular sub-block may be obtained as \texttt{my\_block\_list.blks[i][j]}.
The second constructor is
\texttt{
\begin{tabbing}
my\_block\_list = MultiBlock2D(\=psurf=None, nni=None, nnj=None, \\
                               \>bc\_list=[SlipWallBC(),]*4, \\
                               \>nb\_w2e=1, nb\_s2n=1, nn\_w2e=None, nn\_s2n=None,\\
                               \>cluster\_w2e=None, cluster\_s2n=None,\\
                               \>fill\_condition=None, label="blk")
\end{tabbing}\index{block!MultiBlock2D}
}
\noindent
which first subdivides the parametric patch into sub-patches and then generates an
individual grid over each sub-patch.
Here, a set of \texttt{nb\_w2e} $\times$ \texttt{nb\_s2n} sub-blocks are generated and, if lists
of integers are provided for \texttt{nn\_w2e} and \texttt{nn\_s2n}, these will be used
as the numbers of cells along the edges of the sub-blocks.
If these lists are not supplied, \texttt{nni} $\times$ \texttt{nnj} cells will be divided
across the sub-blocks.
In both of these constructors, the interior boundaries for the sub-blocks are connected 
(as \texttt{AdjacentBC} boundary conditions).

\medskip
When assembling large numbers of blocks for complex geometries, there is a function
\texttt{
\begin{tabbing}
identify\_block\_connections(\=block\_list=None, exclude\_list=[],\\
                             \>tolerance=1.0e-6)
\end{tabbing}\index{block!identify\_block\_connections}
}
\noindent
that performs a brute-force search for all adjacent blocks and sets \texttt{AdjacentBC}
boundary conditions for pairs of edges that have coinciding corners (to within a given tolerance).
If you don't want the search to be over all blocks generated so far, supply a list to
the \texttt{block\_list} argument.  
Alternatively, supply a list for blocks that should be excluded.

\medskip
In some situations, you may want to manually connect particular blocks.
You can use the function
\texttt{
\begin{tabbing}
connect\_blocks\_2D(\= A, faceA, B, faceB, with\_udf=0, filename=None,\\
                    \> is\_wall=0, use\_udf\_flux=0)
\end{tabbing}\index{block!connect\_blocks\_2D}
}
\noindent
where \texttt{A} and \texttt{B} are references to the individual \texttt{Block2D} objects
and \texttt{faceA} and \texttt{faceB} are their adjoining edges (NORTH, EAST, SOUTH or WEST)
Most of the time you can just ignore the default arguments associated with user-defined functions
(\textit{i.e.} \texttt{with\_udf, filename, is\_wall, use\_udf\_flux}).
These are used to implement slowly-opening diaphragms and the like. 


%------------------------------------------------------------------
\subsection{Three-dimensional grids}\index{grid!3D}
%
In 3D, life is just that bit more complicated with
each block defined by 6 surfaces (NORTH, EAST, SOUTH, WEST, TOP and BOTTOM) 
fitted to the actual surfaces of the domain.
Figure\,\ref{block-defn-fig} shows the ``index-space'' view with cell indices
$i$,$j$ and $k$ taking values $0 \le i < nni$, $0 \le j < nnj$ and 
$0 \le k < nnk$ respectively.\footnote{
  The $i$, $j$ and $k$ indices are related to the $r$, $s$ and $t$ parameters
  used within the 3D geometric functions.
  In some places, the corner points are identified by their ($r,s,t$)
  coordinates.
  For example, in the simple-ramp postprocessing script (section
  \ref{simple-ramp-post-files}), point 0 would be identified as $p000$, point 1
  as $p100$, etc.}
The corner vertices of the block are numbered 1 through 7 as shown.
These points are used in the search to determine block connectivity if the
flow domain is defined as consisting of more than one block.
Subdividing a complex flow domain into simpler subdomains is often done
because the mapping from parametric space to physical space is limited to a
simple transfinite interpolation.

\medskip
To assist in understanding the orientation of the corners, surfaces and indices,
you can build a model block from the development plan in Appendix~\ref{cube-development}.
This should bring back fond memories of kindergarten and primary school, 
at least it did for us.

 
\begin{figure}[htbp]
\mbox{
\includegraphics[width=0.5\textwidth]{figs/block3d-defn.pdf}
\includegraphics[width=0.5\textwidth]{figs/block3d-defn-2.pdf}
}
\caption{Two views of the hexahedral block containing the structured mesh.
    These figures are ambiguous but each is supposed to show a hollow box
    with the \textit{far} surfaces in each view being labelled.  
    The \textit{near} surfaces are transparent and unlabelled.
    To get your hands on an unambiguous representation, build the debugging cube
    drawn in Appendix\,\ref{cube-development}}.
\label{block-defn-fig}
\end{figure}

\medskip
To define a block in your input script, create a \texttt{Block3D} object as:
\texttt{
\begin{tabbing}
my\_3d\_block = Block3D(\=parametric\_volume=None, grid=None, \\
                        \>import\_grid\_file\_name=None, \\
                        \>nni=None, nnj=None, nnk=None, \\
                        \>cf\_list=[None,]*12, bc\_list=[SlipWallBC(),]*6, \\
                        \>fill\_condition=None, \\
                        \>hcell\_list=None, xforce\_list=[0,]*6, \\
                        \>label="", active=1, omegaz=0.0)
\end{tabbing}\index{block!Block3D}
}
%
\noindent
where the assignment to the name \texttt{my\_3d\_block} allows easy referencing of
the block at later times, say, for adding boundary conditions.
The names of the actual arguments given above match the actual arguments in
the \texttt{e3prep.py} program and these represent\footnote{Again, the
  definitive source is, of course, the \texttt{Block3D} class definition in 
  \texttt{e3\_block.py}. }:
\begin{itemize}
\item \texttt{parametric\_volume}: a region of 3D space bounded by 6 surfaces.
    This is the usual way of specifying the flow domain, which will be discretized 
    using \texttt{nni, nnj, nnk and cf\_list}.
    See the following section for a guide to constructing \texttt{parametric\_volume} objects.
\item \texttt{grid}: a \texttt{StructuredGrid} object may be supplied (defaults to None). 
\item \texttt{import\_grid\_file\_name}\index{import\_grid\_file\_name} defaults to None.
  If a name is supplied, this file is read to obtain the grid directly.
  The assumed file format in the legacy (ASCII) VTK format for a structured grid.
  There is also an external tool (\texttt{p2e.py}) that can be used to convert
  Plot3D format files to Eilmer's native format.
\item \texttt{nni} is the number of finite-volume cells in the $i$-index
  direction as shown in Figure\,\ref{block-defn-fig}.
  This is only used when diecretizing a \texttt{parametric\_volume}.
  When importing or supplying a grid, this data (\texttt{nni, nnj and nnk}) is ignored.
  Note that, when placing one block against another, the blocks must conform in
  \begin{itemize}
    \item the number of cells along corresponding edges
    \item the clustering of those cells along the edges
    \item the path defining the corresponding edges.
  \end{itemize}
\item \texttt{nnj} is the number of finite-volume cells in the $j$-index direction.
\item \texttt{nnk} is the number of finite-volume cells in the $k$-index direction.
\item \texttt{cf\_list} is a list of \texttt{Function} objects
  that specify a (possibly) nonuniform distribution of cells along a
  particular edge of the \texttt{parametric\_volume}.
  The order of the edges is shown in Table\,\ref{edge-list-table}.
  See page~\pageref{cflist-item} for a more complete description of the cluster functions.
\begin{table}
  \caption{Directions for the edges of a \texttt{Block3D} object.}
  \label{edge-list-table}
  \begin{center}
    \begin{tabular}{cccl}
      \hline\hline
      edge & from point & to point & comment \\ 
      \hline
      0  & $p_0$      & $p_1$    & $i$-direction, bottom surface \\
      1  & $p_1$      & $p_2$    & $j$-direction, bottom surface \\
      2  & $p_3$      & $p_2$    & $i$-direction, bottom surface \\
      3  & $p_0$      & $p_3$    & $j$-direction, bottom surface \\
      4  & $p_4$      & $p_5$    & $i$-direction, top surface \\
      5  & $p_5$      & $p_6$    & $j$-direction, top surface \\
      6  & $p_7$      & $p_6$    & $i$-direction, top surface \\
      7  & $p_4$      & $p_7$    & $j$-direction, top surface \\
      8  & $p_0$      & $p_4$    & $k$-direction \\
      9  & $p_1$      & $p_5$    & $k$-direction \\
      10 & $p_2$      & $p_6$    & $k$-direction \\
      11 & $p_3$      & $p_7$    & $k$-direction \\
      \hline \hline
    \end{tabular}
  \end{center}
\end{table}
\item \texttt{bc\_list} is an optional list of BoundaryCondition objects for the 
  six bounding surfaces (\texttt{NORTH, EAST, SOUTH, WEST, TOP, BOTTOM}).
  Available boundary conditions are the same as for Block2D objects
\item \texttt{fill\_condition} is the \texttt{FlowCondition} object with which to
  define the initial flow state within the volume.
  See Section\,\ref{thermo-flow-sec} for defining a suitable flow condition.
  This may also be a callable function that supplies the flow properties as
  a function of position.
\item \texttt{hcell\_list} is a list of ($i,j,k$)-tuples specifying which
  cells should be monitored at simulation time.
  Data from the specified cells will be written to a ``history'' file for the
  block and may be used at the postprocessing stage to provide flow data as if
  there was a sensor located in the cell.
\item \texttt{xforce\_list} is an optional list of zeros/ones that indicate if we
  want the force to be calculated for each of the six surfaces and written to the 
  \texttt{e3shared.log} log file.
  The order of the boundaries is the same as for \texttt{bc\_list}.
\item \texttt{label} is an optional text label for the block.  This label
  will be embedded in the block definition and some of the postprocessing
  programs may use it.
\item \texttt{omegaz} is the rotational speed of the volume about the z-axis.
  This parameter is non-zero only for rotating components of the turbomachine grids.
\end{itemize} 

\medskip
To manually connect particular Block3D objects, you can use the function
\texttt{
\begin{tabbing}
connect\_blocks\_3D(\= A, B, vtx\_pairs, with\_udf=0, filename=None,\\
                    \> is\_wall=0, use\_udf\_flux=0)
\end{tabbing}\index{block!connect\_blocks\_3D}
}
\noindent
where \texttt{A} and \texttt{B} are references to the individual \texttt{Block3D} objects
and \texttt{vtx\_pairs} is a list of 4 pairs (tuples) of vertex indices.
For example, the list \texttt{[(3,2),(7,6),(6,7),(2,3)]} specifies a \texttt{NORTH}-to-\texttt{NORTH} connection
with orientation \texttt{0}.
The definitions of all allowable connections is listed near the top of the file \texttt{e3\_block.py}.
You will see that there are \textit{many} more combinations in 3D compared with 2D.

\medskip
As for the 2D grids, there are two composite-block generation functions.
The first takes a volume, grids it and then subdivides the newly generated grid:
\texttt{
\begin{tabbing}
my\_3d\_block = SuperBlock3D(\=parametric\_volume=None, cf\_list=[None,]*12, \\
                        \>fill\_condition=None, \\
                        \>nni=2, nnj=2, nnk=2, \\
                        \>nbi=1, nbj=1, nbk=1, \\
                        \>bc\_list=[SlipWallBC(),]*6, label="sblk", \\
                        \>hcell\_list=None, omegaz=0.0)
\end{tabbing}\index{block!SuperBlock3D}
}
\noindent
where \texttt{nbi}, \texttt{nbi} and \texttt{nbk} are the number of basic blocks in each of the
index directions.
The values for \texttt{nni}, \texttt{nnj} and \texttt{nnk} specify the number of cells for the grid
generated over the whole volume.
The second composite block takes a volume, subdivides that volume and then generates a separate
grid within each subvolume:
\texttt{
\begin{tabbing}
my\_3d\_block = MultiBlock3D(\=parametric\_volume=None, \\
                        \>fill\_condition=None, \\
                        \>nni=None, nnj=None, nnk=None, \\
                        \>nbi=1, nbj=1, nbk=1, \\
                        \>clusteri=None, clusterj=None, clusterk=None, \\
                        \>bc\_list=[SlipWallBC(),]*6, label="blk", \\
                        \>hcell\_list=None, omegaz=0.0)
\end{tabbing}\index{block!MultiBlock3D}
}
\noindent
Here, \texttt{nni}, \texttt{nnj} and \texttt{nnk} may be integer values or lists of integer values.
If they are simple integers, they represent the number of cells over the whole volume.
If they are lists of integers, they specify the number of cells each of the subblocks.
The \texttt{clusteri}, \texttt{clusterj} and \texttt{clusterk} may be lists of cluster functions
that get applied to the subblocks in the respective index directions.

\noindent
Note the the composite-block objects contain a member \texttt{blks} that refers to the list of basic
blocks that form the composite block.
Any further setting of boundary conditions, and the like, 
needs to be done to the individual blocks within this list.
See the input script for the finite-cylinder case (on page\,\pageref{finite-cyl-script}) for an example of this.

\medskip
When assembling large numbers of blocks for complex geometries, the function
\texttt{
\begin{tabbing}
identify\_block\_connections(\=block\_list=None, exclude\_list=[],\\
                             \>tolerance=1.0e-6)
\end{tabbing}\index{block!identify\_block\_connections}
}
\noindent
also works for 3D blocks.
As for 2D blocks, it performs a brute-force search for all adjacent blocks and sets \texttt{AdjacentBC}
boundary conditions for pairs of faces that have coinciding corners (to within a given tolerance).
The rotational orientation of the joined faces is also determined automatically.
If you don't want the search to be over all blocks generated so far, supply a list to
the \texttt{block\_list} argument.  
Alternatively, supply a list for blocks that should be excluded.

\medskip
Be aware that the \texttt{identify\_block\_connections()} function is unaware of the form of the actual paths
or surfaces connecting the corner points. 
It may be that the corners coincide but the paths and surfaces do not conform.
If you want more control over the process of joining blocks, you can manually
connect blocks using the \texttt{connect\_blocks\_3D()} function which makes the logical
connection without looking at the geometric locations of the corners.
This situation might arise, for example, when you want to apply periodic boundary conditions
\index{boundary conditions!periodic} in the cross-stream direction of a flow domain.
Then, the boundaries that you want to connect have corners and faces that really don't coincide.

%-------------------------------------------------------------------
\bigskip
\section{Setting conditions for individual boundaries}
\label{setting-boundary-conditions-sec}\index{boundary conditions!setting individually}
%
If you have not already set all appropriate boundary conditions through the \texttt{bc\_list}
argument of the block constructor, you may apply boundary conditions to specific faces 
of a \texttt{Block2D} or \texttt{Block3D} object by calling its method
\texttt{
\begin{tabbing}
set\_BC(\=face\_name, type\_of\_BC, inflow\_condition=None, x\_order=0,\\
      \>sponge\_flag=None, Twall=None, Pout=None, filename=None,\\
      \>is\_wall=0, use\_udf\_flux=0, label='')
\end{tabbing}\index{boundary conditions!set\_BC}
}
\noindent
and specifying the face and type of boundary condition.
When this function is called, it creates a suitable boundary condition object 
(as discussed in the previous section) and binds it to the appropriate block boundary.
There is no difference in the end result compared with the approach of
specifying the boundary conditions when the block is created. 
\begin{itemize}
  \item \texttt{face\_name}: one of \texttt{NORTH}, \texttt{EAST},
    \texttt{SOUTH}, \texttt{WEST}, \texttt{TOP}, \texttt{BOTTOM}
  \item \texttt{type\_of\_BC}: one of 
    \begin{itemize}
      \item \texttt{ADJACENT}: there is another block abutting this face.
        This boundary condition is usually set by the block-conection functions.
      \item \texttt{SUP\_IN}: supersonic inflow using the
        \texttt{inflow\_condition} properties.
      \item \texttt{EXTRAPOLATE\_OUT}: (assumed) supersonic-outflow where the
        ghost-cell flow properties are copies or extrapolations 
        of the adjacent interior cell properties.
      \item \texttt{SLIP\_WALL}: an inviscid solid wall where the normal
        velocity in the ghost cells is a reflection of the velocity in the
        interoir cell.
      \item \texttt{ADIABATIC}: a no-slip wall where the wall temperature is
        the same as the cell-centre temperature.
      \item \texttt{FIXED\_T}: a no-slip wall where the wall temperature is
        specified by \texttt{Twall} in degrees K.
      \item \texttt{SUBSONIC\_IN}: subsonic inflow where the stagnation
        pressure and temperature is specified and the velocity is taken from
        the interior cell.
      \item \texttt{TRANSIENT\_UNI}: a transient flow condition applied
        uniformly across the face of the block.
      \item \texttt{STATIC\_PROF}: a time-invariant flow condition that has
        spatial variation across the face of the block.
      \item \texttt{FIXED\_P\_OUT}: something like the \texttt{EXTRAPOLATE\_OUT}
        condition with the pressure in the ghost cells set to \texttt{Pout}.
      \item \texttt{RRM}: rescaled and recycled data for Andrew Denman's LES simulations.
      \item \texttt{USER\_DEFINED}: the user-supplied Lua functions are used to
        determine ghost-cell flow properties and or interface fluxes.
        These functions are provided in the file given by \texttt{filename}.
        The flag \texttt{is\_wall} indicates whether the boundary is to be considered
        a wall for the application of turbulence-model fudges and the like (default 0).
        The flag \texttt{use\_udf\_flux} indicates whether the user is supplying
        the fluxes at the boundary interfaces (default 0).  
        If not, the internal flux calculator is used together with the supplied ghost-cell data.
      \item \texttt{ADJACENT\_PLUS\_UDF}:
    \end{itemize}
  \item \texttt{inflow\_condition}: the flow condition used for
    \texttt{SUP\_IN}, default value None.
  \item \texttt{x\_order}: Order of extrapolation for \texttt{EXTRAPOLATE\_OUT} and 
    \texttt{FIXED\_P\_OUT}, default value 0.
  \item \texttt{sponge\_flag}: Andrew Denman's flag, default value None.
  \item \texttt{Twall}: static temperature of the wall in degrees K, default value None.
  \item \texttt{Pout}: static pressure in Pa applied to the ghost cells, default value None.
  \item \texttt{label}: symbolic label for the boundary, default value is an empty string.
\end{itemize}
You need only specify the properties that are relevant to the specific
boundary condition.

%------------------------------------------------------------------
\bigskip
\section{Special zones and history points}
\label{sec:special-zones}
% 
Zones of heating or cooling may be defined within the flow domain as rectangular (2D) 
or regular hexahedral (3D) patches which are specified by two diagonally-opposite
corners (\texttt{point0} and \texttt{point1}).
For example, we could specify\\
\texttt{HeatZone(qdot, point0, point1, label="")}\index{HeatZone}\\
where \texttt{qdot} is the heat addition per unit volume in W/m$^3$.
The corners of each hexahedral zone are given by the \texttt{Vector} values 
\texttt{point0} and \texttt{point1}.
If the centre of a cell lies within the heat zone, \texttt{qdot} is added to
the source term in the energy equation every time step during the simulation. When using
a HeatZone it is necessary to give at least \texttt{heat\_time\_stop} a positive non-zero
value and \texttt{heat\_time\_start} and \texttt{heat\_factor\_increment} can also be modified
as appropriate.
A HeatZone might be used to model the deposition of energy into a small volume from 
a high-power laser, for example.

\medskip
Similarly, zones of reaction are defined with\\
\texttt{ReactionZone(point0, point1, label="")}\index{ReactionZone}\\
where the finite-rate reactions will be allowed to proceed.
Outside of these zones, the finite-rate chemical update will be suppressed 
and the species concentrations will be effectively frozen.
If no such zones are specified, reactions are permitted for the entire flow field.

\medskip
Also, when running turbulent flow simulations, the turbulence model can also be
restricted to being applied to specific zones using\\
\texttt{TurbulenceZone(point0, point1, label="")}\index{TurbulenceZone}\\
The turbulence model (say, the $k-\omega$ model) is active throughout the flow
but its effect on the flow field is masked outside of the \texttt{TurbulenceZone}s.
This is achieved by the code setting the turbulence viscosity and conductivity to zero
for finite-volume cells that fall outside of all regions defined as a \texttt{TurbulenceZone}.
If there a no such defined regions, all of the flowfield may have nonzero turbulence viscosity.

\medskip
As well as being identified by their cell indices when defining a block,
history points can be located by their Cartesian coordinates using:\\
\texttt{HistoryLocation(x, y, z=0.0, i\_offset=0, j\_offset=0, k\_offset=0, label="")}\index{HistoryLocation} \\
where the offset indices allow you to select a cell a known number of cells 
away from another.

%------------------------------------------------------------------
\bigskip
\section{Simulation control parameters}
\label{sec:sim-control-parameters}
\index{configuration parameters}\index{control parameters}
%
A number of other parameters can be set in order to control the behaviour of
the simulation.
These parameters are mainly collected into the \texttt{gdata}
object\footnote{The \texttt{gdata} object is an instance of the \texttt{GlobalData}
  class defined in \texttt{e3prep.py}. Most of the attributes are discussed here,
  however, see the source code for that class for a full list of attributes.} 
which is accessible to the user's input script.
Grouped by theme, the possible attributes include\footnote{Attributes that are stored in the control file\index{control file}
are denoted by a \ddag ~symbol.  The rest go into the config file.\index{config file}}:
\paragraph{Geometry}
\begin{itemize}
\item \texttt{dimensions}: number of geometric dimensions (2 or 3).  
  If unspecified, the default is 2.
\item \texttt{axisymmetric\_flag}: 1=2D-axisymmetric geometry with $x$-axis being the axis of symmetry,
  0=2D-planar geometry, default value 0.
\end{itemize}

\paragraph{Time stepping}
\begin{itemize}
\item \texttt{sequence\_blocks}: 0=normal time iteration on all blocks, 1=integrate one block
  at a time, default value 0.
\item \texttt{dt}\ddag: the initial time step (in seconds) that will be used for the
  first few steps of the simulation process.
  Be careful to set a value small enough for the time-stepping to be stable.
  Since the time stepping is synchronous across all parts of the flow domain,
  this time step size should be smaller than half of the smallest time for a signal
  (pressure wave) to cross any cell in the flow domain. 
\item \texttt{dt\_chem}: suggested time-step for finite-rate chemistry update;
  default value of -1.0 indicates that we want the code to work it out.
\item \texttt{dt\_therm}: default value -1.0.
\item \texttt{t\_order}\ddag: 1=Euler time stepping, 2=predictor-corrector
  time-stepping, default value 1.
  If you want time-accurate solutions, use predictor-corrector stepping,
  otherwise, Euler stepping is half the computational expense 
  (but you may get less accuracy and the code will not be as robust).
\item \texttt{fixed\_time\_step}\ddag: 1=do not change time step from that specified, 
  0=allow time step size to be determined from cell conditions and cfl number, default value 0.
\item \texttt{cfl}\ddag: ratio of the smallest signal time to the actual time step,
  default value 0.5.
\item \texttt{stringent\_cfl}\ddag: 1=use the smallest cross-cell distance in the
  CFL check, 0=use different cell widths in each index direction, default is 0.
\item \texttt{dt\_reduction\_factor}\ddag: if the CFL condition is violated, scale the time-step size
  down by this factor, default value 0.2.
\item \texttt{cfl\_count}: number of time steps between checks of the CFL
  condition, default value 10.
  This check is expensive so we don't want to do it too frequently but, then,
  we have to be careful that the time step does not become unstable.
\item \texttt{max\_time}\ddag: the simulation will be terminated on reaching this
  value of time, default value $1.0 \times 10^{-3}$.
\item \texttt{t0}: starting time for simulation, may be useful to change when restarting from another job,
  default value 0.0.
\item \texttt{max\_step}\ddag: the simulation will be terminated on reaching this
  number of time steps, default value 10.
\item \texttt{dt\_plot}\ddag: the whole flow solution will be written to disk when
  this amount of simulation time has elapsed, default value $1.0 \times 10^{-3}$s.
\item \texttt{dt\_history}\ddag: the history-point data will be written to disk
  when this amount of time has elapsed, default value $1.0 \times 10^{-3}$s.
\end{itemize}

\paragraph{Spatial reconstruction/interpolation}
\begin{itemize}
\item \texttt{x\_order}\ddag: 1=no reconstruction of intra-cell flow properties
  before applying the flux calculator, 2=high-order reconstruction applied, 
  default value 2.
\item \texttt{apply\_limiter\_flag}: 1=apply reconstruction limiter, default value 1.
\item \texttt{extrema\_clipping\_flag}: 1=do extrema clipping at end of 1D scalar reconstruction,
  default value 1.  A value of 0 suppresses clipping.
\item \texttt{interpolation\_type}: string to choose the set of interpolation variables
  to use in the interpolation, options are "rhoe", "rhop", "rhoT", "pT", default value "rhoe".
\end{itemize}

\paragraph{Flux calculator}
\begin{itemize}
\item \texttt{flux\_calc}: selects the flavour of the flux calculator, 
  default value \texttt{ADAPTIVE}.
  The ADAPTIVE scheme is a good all-round scheme that uses AUSMDV away from
  shocks and EFM near shocks.
\item \texttt{compression\_tolerance}: value of relative velocity change (normalised by local sound-speed)
   across a cell-interface that triggers the shock-point detector.  A negative value indicates a compression.
   When the ADAPTIVE flux calculator is used and the shock detector is triggered, the EFM flux calculation
   will be used in place of the default AUSMDV calculation.
   A value of -0.05 seems OK for the sod and cone20 inviscid flow simulations, however,
   a higher value is needed for cases with viscous boundary layers, 
   where it is important to not have too much dissipation in the boundary layer region.
   The default value is -0.30.
\item \texttt{shear\_tolerance}: value of the relative tangential-velocity change 
   (normalised by local sound speed) across a cell-interface that suppresses the use of EFM even if the
   shock detector indicates that EFM should be used for the ADAPTIVE flux calculator.
   The default value is experimentally set at 0.20 to get smooth shocks
   in the stagnation region of bluff bodies.
   A smaller value (say, 0.05) may be needed to get strongly expanding flows to behave 
   when regions of shear are also present.
\end{itemize}

\paragraph{Viscous effects}
\begin{itemize}
\item \texttt{viscous\_flag}: 1=viscous terms are active, 0=inviscid
  simulation, default value 0.
\item \texttt{viscous\_delay}: the time (in seconds) to wait before applying
  the viscous terms.
  This might come in handy when trying to start blunt-body simulations.
\item \texttt{viscous\_factor\_increment}: per-time-step increment of the viscous effects, once
  t\,$>$\,viscous\_delay, default value 0.01.
\item \texttt{diffusion\_flag}: 1=compute multicomponent diffusion of species, default value 0.
\item \texttt{diffusion\_model}: string, default value "None".
\item \texttt{turbulence\_flag}: 1=activate turbulence model, 0=laminar viscosity only,
  default value 0.
\item \texttt{turbulence\_model}: string specifying which model to use, "k\_omega", "baldwin\_lomax",
  default "k\_omega".
\item \texttt{turbulence\_prandtl\_number}: default value 0.89
\item \texttt{turbulence\_schmidt\_number}: default value 0.75
\item \texttt{max\_mu\_t\_factor}: turbulent viscosity is limited to laminar viscosity multiplied
  by this factor, default value 300.0. 
\item \texttt{transient\_mu\_t\_factor}: default value 1.0.
\end{itemize}

\paragraph{Chemistry}
\begin{itemize}
\item \texttt{reacting\_flag}: flag to indicate that the finite-rate chemical
  reactions are active.
  It has a default value of 0, however, it gets set to 1 if the call 
  to \texttt{set\_reaction\_scheme()} is made.
  This is the usual way of setting it.
\item \texttt{reaction\_update}: File name for reaction scheme configuration.
  (More conveniently set by calling \texttt{set\_reaction\_scheme()}.)
\item \texttt{reaction\_time\_start}: time after which finite-rate reactions are allowed to start,
  default value 0.0.
\end{itemize}

\paragraph{Miscellaneous}
\begin{itemize}
\item \texttt{title}: a title string that may appear in a number of places.
  For example, in plots made during the postprocessing stage.
\item \texttt{max\_invalid\_cells}: the maximum number of bad cells that will be tolerated on
  decoding conserved quantities.  It this number is exceeded, the simulation will stop. default value 10.
\item \texttt{udf\_source\_vector\_flag}: 1=apply user-defined source terms as supplied in a Lua file,
  default value 0.
\item \texttt{udf\_file}: name of the Lua file for the user-defined source terms, default value "".
\item \texttt{print\_count}\ddag: number of time steps between printing status
  information to the console, default value 20.
\item \texttt{heat\_time\_start}: default value 0.0, in seconds.
  For a description of HeatZones, see Section\,\ref{sec:special-zones}.
\item \texttt{heat\_time\_stop}: a non-zero value indicates that we wish to add heat
  through the HeatZones, default value 0.0, in seconds.
\item \texttt{heat\_factor\_increment}: the fraction of full heat load that will be
  added with each step after $t$=heat\_time\_start, default value 0.01.
\item \texttt{mhd\_flag}: 1=make MHD physics active. default value 0.
\end{itemize}


%------------------------------------------------------------------
\section{Parameters for a 2D sketch of the flow domain}\index{sketch}
%
The \texttt{sketch} object holds parameters that set the view and scale of the
SVG (scalable vector graphic) rendering of the two-dimensional flow domain.
The method
\texttt{
\begin{tabbing}
sketch.window(\=xmin=0.0, ymin=0.0, xmax=1.0, ymax=1.0,\\
              \>page\_xmin=0.05, page\_ymin=0.05, page\_xmax=0.17, page\_ymax=0.17)
\end{tabbing}
}

\noindent
sets the mapping from the lower-left to upper-right points in simulation geometry 
to the corresponding points on a page.
Axes may also be drawn with:\\
\texttt{sketch.xaxis(x0, x1, xtic, y\_offset)} \\
\texttt{sketch.yaxis(y0, y1, ytic, x\_offset)} \\
where small negative values may be given for the offset values in order to move
the axes clear of the main sketch elements.

\medskip
Of course, this sketch environment is only available for 2D simulations.
For 3D rendering, there is an option for most geometric elements to be rendered as
Virtual Reality Markup Language (VRML) strings.\index{VRML}  
These VRML strings may be manually written to a file as part of the user's input script.
 
\cleardoublepage
%-------------------------------------------------------------------
% The examples...

\part{Examples for 2D flow}
%
These examples are graded from simple geometry specification and gas model specification
to more complex.
Initially, simple box regions and single-specied ideal gas models are used, followed by
examples with curved boundaries, equilibrium gas models and, also, 
multi-species thermally-perfect gases with finite-rate chemical kinetics.
Later examples also use more of Python's capabilities with the input script for the 
heat-transfer to a sphere, for example, being written as a template script and a top-level 
coordinating script that runs the simulation a number of times with better grid resolution.

% 2D examples
\include{cone20-simple}
\cleardoublepage
\include{axi-cylinder}
\cleardoublepage
\include{sharp}
\cleardoublepage
\include{sharp-pyfun}
\cleardoublepage
\include{blunt-wedge}
\cleardoublepage
\include{bar-476}
\cleardoublepage
\include{back-nozzle}
\cleardoublepage
\include{sawada-sphere}
\cleardoublepage
\include{classic-shock-tube}
\cleardoublepage
\include{sphere-heat-transfer}
\cleardoublepage
\include{n90}
\cleardoublepage
\include{lehr-sphere}
\cleardoublepage
\include{mnm-implosion-problem}
\cleardoublepage
\include{periodic-shear-layer}
\cleardoublepage
\include{cone20-udf}
\cleardoublepage
\include{vortex}
\cleardoublepage
\include{mms-euler}
\cleardoublepage
\include{mms-viscous}
\cleardoublepage
\include{odw}
\cleardoublepage
\include{turbo-sc10}
\cleardoublepage
\include{turbo-sc10-parametric}
\cleardoublepage
\include{hayabusa}
\cleardoublepage

\part{Examples for 3D flow}
%
Now, let's do it all again in three dimensions.

% 3D examples
\include{simple-ramp}
\cleardoublepage
\include{sod-3d}
\cleardoublepage
\include{inject}
\cleardoublepage
\include{finite-cylinder}
\cleardoublepage
\include{sphere-cone}
\cleardoublepage
\include{scram1}
\cleardoublepage
\include{bianca-epfl}
\cleardoublepage

%--------------------------------------------------------------------
\part{References and Appendices}

\bibliographystyle{unsrt}
\bibliography{bibtex/pj,bibtex/computing,bibtex/gas_dynamic,bibtex/adm,bibtex/gas,bibtex/dan}

\cleardoublepage
\appendix

\section{Instructions for installation and getting started}
\label{getting-started-file}\index{Getting started}\index{Installation}
%
The latest version of this files should be in the \texttt{doc/sphinx/} directory 
of the package of source files.\\
\topbar
\lstinputlisting[language={}]{../../../doc/sphinx/getting-started.rst}
\bottombar

\noindent
\topbar
\lstinputlisting[language={}]{../../../doc/sphinx/eilmer3.rst}
\bottombar

\cleardoublepage
\section{Surviving the Linux Command Line}
\label{linux-command-notes-sec}
For running jobs on a Linux machine, it is worth knowing how to get around and do things in the \textit{shell},
which is a command interpreter and programming language.
Sobell's text \cite{sobell_2005a} is a good source of information but here are a few notes to get you started.

\medskip
A basic command is composed of a sequence of words, separated by spaces and has the usual form\\
\texttt{cmd [options] arguments}\\
where 
\begin{itemize}
 \item\texttt{cmd} is the name of the command or utility program that will do the work.
   Command names on Linux are often terse, 2 or 3 character names.
 \item\texttt{options} are words that are optionally included and are typically preceded by one or two dashes.
   These modify the behaviour of the command, if the default behaviour is not quite what you want.
 \item \texttt{arguments} are the things to work on.
   If these are file names, you can often use patterns with \textit{wildcard} characters that may match
   more then one file at a time.
\end{itemize}
Commands often put their \textit{standard output} to the console.
If the amount of text output is overwhelming, it can be \textit{redirected} to a file 
or \textit{piped} through a paging filter.
This latter option is an example of putting multiple command together so that the output from
one command becomes the input for another.
Once you understand the system, customised commands can be build rather simply in this way.

The following tables summarize a number of commands that you are likely to find useful while
using \texttt{Eilmer3}.\\

\subsection*{Logging in and getting out}
\begin{tabular}{l|l}
 \texttt{ssh} \textit{user}\texttt{@}\textit{host} & Connect to computer named \textit{host} as \textit{user}. \\
 \textit{Ctrl+d} & Quit current session. \\
 \texttt{exit} & Quit current session. \\
\end{tabular}

\subsection*{Getting help}
\begin{tabular}{l|l}
 \texttt{man} \textit{cmd-name} & Display the manual page for the named command. \\
 \texttt{man} \textit{cmd-name} \texttt{| less} & Display the manual page through the paging filter. \\
 \texttt{ls --help | less} & Look at the online help provided by the \texttt{ls} command. \\
 \texttt{man -k} \textit{keyword} & List \texttt{man} pages that contain \textit{keyword}. \\
 \texttt{apropos} \textit{subject} & List \texttt{man} pages on \texttt{subject}. \\
\end{tabular}
 
\subsection*{Moving about and looking in your folders}
\begin{tabular}{l|l}
 \texttt{cd} \textit{dir} & Change to directory \textit{dir}. \\
 \texttt{cd} & Change to home directory. \\
 \texttt{cd ..} & Change to parent of current directory. \\
 \texttt{pwd} & Print current (working) directory. \\
 \texttt{pushd} \textit{dir} & \parbox{0.8\textwidth}{Change to new directory \textit{dir}, 
   putting the current directory onto a stack.} \\
 \texttt{popd} & Go back to the directory at the top of that stack. \\
 \texttt{ls -l} & List the files in the current directory, long format. \\
 \texttt{ls -a ..} & List the files in the directory above, including all hidden files. \\
 \texttt{du -h} \textit{dir} & Report the size of the directory and its subdirectories. \\
 \texttt{df -h} & Report the capacities of the file systems and how much is used for each. \\
 \texttt{mkdir} \textit{dir} & Make new directory. \\
 \texttt{rmdir} \textit{dir} & Remove an empty directory. \\
\end{tabular}

\subsection*{Handling files}
\begin{tabular}{l|l}
 \texttt{cat} \textit{file} & Displays the content of a text file. \\
 \texttt{head -n 20} \textit{file-to-show} & Display the first 20 lines of a text file. \\
 \texttt{tail -f} \textit{file-to-show} & \parbox{0.6\textwidth}{Show the last few lines of a file and continue 
   to show lines as that file changes.} \\
 \texttt{grep 'ideal gas' *.py} & \parbox{0.6\textwidth}{Find the string \texttt{ideal gas} in all of 
   the Python files in the current directory.} \\
 \texttt{mv} \textit{src-file} \textit{dest-file} & Renames the source file to the destination name. \\
 \texttt{cp} \textit{src-file} \textit{dest-file} & Copy the content from the source file to the destination file. \\
 \texttt{scp} \textit{src-file} \textit{user}\texttt{@}\textit{host}\texttt{:} & \parbox{0.6\textwidth}{Copy the file
   from the local computer to the home directory of \textit{user} on the remote computer \textit{host}.} \\
 \texttt{rm -r} \textit{dir} & Remove a directory and all of its contents (recursively). \\
 \texttt{gzip} \textit{src-file} & Compresses the file, adding the extension \texttt{.gz} to its name. \\
 \texttt{tar -zcf} \textit{tarfile} \textit{dir} & Pack all of the contents of \textit{dir} into the \textit{tarfile}. \\
 \texttt{tar -zxf} \textit{tarfile} & Unpack the contents of \textit{tarfile} into the current directory. \\
\end{tabular}

\subsection*{Managing processes}
\begin{tabular}{l|l}
 \texttt{top} & \parbox{0.9\textwidth}{Display information about all running processes. This is very handy
   for finding out which jobs are taking all of your workstation's CPU cycles and memory.} \\
 \textit{Ctrl+z} & Stops the current command. \\
 \texttt{bg} & Resumes a stopped job in the background. \\
 \texttt{fg} & Brings most recent job to the foreground. \\
 \textit{Ctrl+c} & Halts current command. \\
\end{tabular}

\subsection*{Command-line editing}
On most Linux systems, it seems that you can use the cursor keys to move about within the command line.
Delete and backspace also seem to have suitable effect.

\smallskip \noindent
\begin{tabular}{l|l}
 \textit{Ctrl+u} & Erases whole command line. \\
 \texttt{!!} & Repeats last command. \\
 \texttt{history} & Shows command history. \\
 \texttt{!}\textit{n} & Repeats command \textit{n}. \\
\end{tabular}


\cleardoublepage
\section{Just enough Python to be dangerous}
\label{python-notes-sec}
When \texttt{e3prep.py} is run, the first thing that happens is that a number of Eilmer3-specific
modules are loaded and a number of classes are defined to assist with the definition of flow and geometry.
The user's input file is then read in and executed by the Python interpreter
in the context of these predefined classes and functions.
Since the input file has to be valid Python code, it's worth knowing a little about the language itself.
We will discuss the features of Python using examples from the periodic shear layer input file on
page \pageref{psl-py-file}.

\medskip
Python is a statement-based language where indentation is used to define the block structure
of compound statements.
One of the implications of this significant whitespace is that the first statement in the user's input
file must start right at the beginning of the line.
That is, it must not be indented.
The first couple of lines in the periodic shear layer input file are:\\
\texttt{\# psl.py\\
gdata.title = "Periodic shear layer"\\
}
The comment line, starting with the sharp (or hash) character is ignored and the first statement assigns
a string literal to the title.

\medskip
Single statements, such as assignment statements, may extend over several lines if they are continued
by one of:
\begin{itemize}
 \item a backslash ($\backslash$) at the end of each incomplete line;
 \item an open left parenthesis, bracket or brace without the corresponding closing parenthesis, bracket or brace; or
 \item an open triple quote that has indicated the start of a multiline string.
\end{itemize}
The second of these is quite commonly seen in the example files because many of the function calls and object
constructors have a lot of arguments, some of which may be quite complex in themselves.
The following assignment statement, from near the end of the periodic shear layer input file, 
calls the \texttt{SuperBlock2D} object
constructor and then binds the resultant object to the name \texttt{superblk}.
\texttt{
\begin{tabbing}
superblk = SuperBlock2D( \= psurf=domain, nni=nnx, nnj=nny,\\
                         \> bc\_list=[SlipWallBC(),]*4,\\
                         \> fill\_condition=initial\_gas,\\
                         \> nbi=nbi, nbj=nbj, label="blk")
\end{tabbing}
}

\medskip
On the selection of names to bind to returned data objects, the usual rules apply.
Start the name with a letter from the alphabet and follow it with any number of letters, digits or 
underscores.
Don't use any of the following reserved words for your own names:
\begin{center}
\texttt{
\begin{tabular}{lllll}
and      & del      & from     & None    & try \\
as       & elif     & global   & not     & while \\
assert   & else     & if       & or      & with \\
break    & except   & import   & pass    & yield \\
class    & exec     & in       & print   & \\
continue & finally  & is       & raise   & \\
def      & for      & lambda   & return  & 
\end{tabular}
}
\end{center}
And, if you want to see the list of names that are predefined for the environment in
which your input file is interpreted, start \texttt{e3prep.py} with the \texttt{--show-names} option.
There are conventions that leading and trailing underscores are reserved for system names and that
names starting with an uppercase letter are class names.

\medskip
Control flow statements such are implemented as compound statements.
These start with an opening clause at the current indentation level.
This clause will start with a keyword, such as \texttt{if}, \texttt{while}, or \texttt{for},
and end with a colon.
The body of the compound statement will typically start on the following line, indented one level.
All statements at that level of indentation or more form part of the body of that compound statement.
There may be nested compounded statements and each level of indentation will be 4 spaces, by convention.

\medskip
The definition of a function is itself a compound statement and an example can be seen
in the periodic shear layer example (page \pageref{psl-py-file}) where the initial state of the gas 
is defined in the function \texttt{initial\_gas(x, y, z))} in the user's input file. 
Collections of functions are typically available as modules in Python.
These modules, or items from the modules may be ``imported''. 
By default, Python does not load a lot of modules so you will typically have to import math functions, for example.

\medskip
As well as the simple numerical data types of integers and floats, there are strings and more complex, 
structured data types built into the language.
These include tuples, lists and dictionaries.
\texttt{e3prep.py} also makes use of \texttt{numpy} arrays.

\medskip
You will make use of lists when defining collections of mass fractions and boundary conditions, for example.
A list literal is denoted by square brackets, with items separated by commas.
Lists are ordered collections of items that may be indexed, starting from zero.
Negative index values count backward from the end of the list.
The \texttt{for} loop is a convenient way of working through all the elements of a list.
In the periodic shear layer example above, the boundary conditions are specified as a list of 4
\texttt{SlipWallBC} objects.
The following code works through the list of blocks 
that had been returned by the SuperBlock2D constructor and makes the appropriate
connections for a periodic domain.
\texttt{
\begin{tabbing}
for \= j in range(nbj):\\
    \> connect\_blocks\_2D(superblk.blks[-1][j], EAST, superblk.blks[0][j], WEST)
\end{tabbing}
}
\noindent
Here, the call to the function \texttt{range} returns a list of integer values starting with 0,
going up to but not including the value bound to \texttt{nbj}.

\medskip
Dictionaries are collections of named objects.
They are a convenient way of setting species mass fractions, especially for a gas model
that has many species.
You may typically only have only one or a couple of species present in and particular inflow or 
initial gas condition as, for example, the literal dictionary \{\texttt{'He':0.1, 'air':0.9}\}
is used to set the mass fraction of helium to 0.1 and the mass fraction of air to 0.9.
Use of the dictionary has the benefit of making the input script somewhat self-documenting and you
don't have to remember the order in which the gas species were defined in the call 
to the \texttt{select\_gas\_model} function, earlier in the input file.

\medskip
More specialized data objects can be defined via classes, and \texttt{e3prep.py} does exactly that.
The name \texttt{gdata} is bound to an instance of the \texttt{GlobalData} class and contains
many attributes that set the configuration of the flow solver.
The user input file will use the already defined gdata object but will typically create new instances
of objects such as \texttt{Node} and \texttt{SuperBlock2D}.
It is often convenient to bind the reference returned to the newly created object to a name in the input script
so that it can be conveniently referenced in later statements.
In the periodic shear layer case, the \texttt{Node} objects are bound to names 
that are then used to construct the \texttt{Line} objects that are, in turn, 
used to define the rectangular flow domain.

\medskip
When working in Python it is possible to see what options are available to you with a particular
function or object using the \texttt{dir} command. This enables you to get a print out of the properties
and functions associated with the object. For example create a node and see what the \texttt{dir} output is.\\
\topbar\\
\texttt{a = Node(0.0,0.1,label='a')}\\
\texttt{print dir(a)}\\
\begin{scriptsize}
\texttt{['\_\_add\_\_', '\_\_class\_\_', '\_\_del\_\_', '\_\_delattr\_\_', '\_\_dict\_\_', '\_\_div\_\_', '\_\_doc\_\_',
 '\_\_format\_\_', '\_\_getattr\_\_',\\ '\_\_getattribute\_\_', '\_\_hash\_\_', '\_\_iadd\_\_', '\_\_idiv\_\_', 
'\_\_imul\_\_', '\_\_init\_\_', '\_\_isub\_\_', '\_\_module\_\_', '\_\_mul\_\_',\\ '\_\_neg\_\_', '\_\_new\_\_', 
'\_\_pos\_\_', '\_\_reduce\_\_', '\_\_reduce\_ex\_\_', '\_\_repr\_\_', '\_\_rmul\_\_', '\_\_setattr\_\_', 
'\_\_sizeof\_\_',\\ '\_\_str\_\_', '\_\_sub\_\_', '\_\_subclasshook\_\_', '\_\_swig\_destroy\_\_', '\_\_swig\_getmethods\_\_', 
'\_\_swig\_setmethods\_\_',\\ '\_\_weakref\_\_', 'clone', 'copy', 'label', 'mirror\_image', 'nodeList', 'norm', 
'rotate\_about\_zaxis', 'str',\\ 'this', 'transform\_to\_global', 'transform\_to\_local', 'translate', 'vrml\_str', 
'vtk\_str', 'x', 'y', 'z']}\end{scriptsize}\\
\bottombar\\

The last items in this list are the different options available to a Node object that can be used within the
prep file.

\cleardoublepage
\section{Make your own debugging cube}
\label{cube-development}
%
\centerline{\includegraphics[viewport=69 220 490 778,clip=true,angle=180]{figs/paper-cube-development.pdf}}

%\newpage 
%\input{../../../lib/gas_models2/tex/scriptnoneq}

\cleardoublepage
\section{cfpylib modules}\index{module!cfpylib}
There are a number of modules that are useful for the definition of flow
simulations but are not part of the Eilmer code.
These are available in a separate Python library that may be imported into the
user's job definition script.
 
\subsection{Billig shock shape correlation}\index{Billig}
\label{billig-correlation}
\topbar
\lstinputlisting[language={}]{../../../lib/cfpylib/gasdyn/billig.py}
\bottombar

\cleardoublepage
\section{Gas models: specification by configuration file}
\label{app:gas-models}
\input{gas_models}

\cleardoublepage
\section{Chemical reactions: specification by configuration file}
\label{app:chem}
\input{chem}

\cleardoublepage
\section{Thermal energy exchange mechanisms: specification by configuration file}
\label{app:therm-exchange}
\input{therm-exchange}

\cleardoublepage
\section{User-defined functions for run-time customization}
\label{udf-sec}
\input{udf}

\cleardoublepage
\section{Hints for Solution Visualisation with ParaView}
\label{app:paraview}
\input{paraview}

\cleardoublepage
\phantomsection % re-set the hyperref anchor so that TOC page number link is correct.
\addcontentsline{toc}{part}{\indexname}
\printindex
\end{document}
