#! /usr/bin/env python 
# generate-optimised-curves.py
#
# This script generates the Bezier control points and coordinates of the 
# optimised curves at every n-th check of the optimisation loop. Here, the 
# n-th check is the "n_check" term that we have fed in to the minimize() 
# function of the nelmin.py script (see optimise_nozzle.py).
#
# This script requires the nelmin.log file as input, and returns three files.
#  1. optimised-curves-comparison.data -> contains the physical coordinates
#       of the optimised curve at every n-th check of the optimisation loop.
#  2. optimised-curves-controlpts.data -> contains the Bezier control points
#       of the optimised curve at every n-th check of the optimisation loop.
#  3. residuals.data -> contains residuals from every n-th check of the 
#       optimisation loop.
#
# The gnuplot script, plot-optimised-curves-and-optimisation-stats.sh, uses
# these three files to generate a comparison of the optimised curves and to
# generate a plot of the optimisation residuals at each n-th check.
# #
# Wilson Chan, 31 Aug 2012.
# ---------------------------------------------------------------------------

from math import *

def eval_Bezier(bezCtrlPts, t):
    """
    Return the x- and y-coordinates of point t (0 < t < 1) on
    the Bezier curve generated by the input control points .
    """
    n = len(bezCtrlPts) - 1
    blendingFunc = []
    # Generate blending functions.
    for i in range(len(bezCtrlPts)):
        blendingFunc.append((factorial(n) /(factorial(i)*factorial(n-i))) *\
            pow(t,i) * pow((1-t),(n-i)))
    # Get x and y coordinates.
    x = 0.0; y = 0.0
    for i in range(len(bezCtrlPts)):
        x += blendingFunc[i] * bezCtrlPts[i][0]
        y += blendingFunc[i] * bezCtrlPts[i][1]
    return x, y


# ------------------------------------------------------------------

# User-defined parameters
noOfCtrlPts = 9     # Total number of Bezier control points.
nFixedCtrlPts = 2   # Number of control points that are not touched by the optimiser.
nPtsOnCurve = 1000  # Number of points to generate from the Bezier control points.
n_checks = 5        # Number of loops before a convergence check is conducted in the 
                    # optimiser (as per specified in the optimisation script).

fo = open("optimised-curves-comparison.data", "w")
fo2 = open("residuals.data", "w")
fo3 = open("optimised-curves-controlpts.data", "w")

# Initialise number of iterations.
nIter =  0

# Read in initial Bezier control points.
controlPts = []
fi = open("Bezier-control-pts-t4-m7.initial.data", "r")
fi.readline()
while True:
    buf = fi.readline().strip()
    if len(buf) == 0: break
    tokens = [float(word) for word in buf.split()]
    controlPts.append([tokens[0], tokens[1]])
fi.close()
    
# Generate data points for the initially given curve.
for n in range(nPtsOnCurve+1):
    t = float(n)/float(nPtsOnCurve)
    x, y = eval_Bezier(controlPts, t)
    fo.write("%.6e %.6e\n" % (x, y))
fo.write("\n")

# Write out Bezier control points.
for n in range(len(controlPts)):
    fo3.write("%.6e %.6e\n" % (controlPts[n][0], controlPts[n][1]))
fo3.write("\n")

# Read control points for the optimised curve at each n-th check in the
# optimisation loop, generate data points for each curve and write them
# to a data file.
fi = open("nelmin.log", "r")
while True:
    buf = fi.readline().strip()
    if len(buf) == 0: break
    tokens = [word for word in buf.split()]
    if tokens[0] == "x":
        # Decode the design variables to obtain the Bezier control points.
        for n in range(nFixedCtrlPts, noOfCtrlPts):
            if n == nFixedCtrlPts:
                newY = controlPts[n-1][1] + float(tokens[n][1:9])
            else:
                newY = controlPts[n-1][1] + float(tokens[n][0:8])
            controlPts[n][1] = newY
        # Generate and write out data points for each Bezier curve.
        for n in range(nPtsOnCurve+1):
            t = float(n)/float(nPtsOnCurve)
            x, y = eval_Bezier(controlPts, t)
            fo.write("%.6e %.6e\n" % (x, y))
        fo.write("\n")
        # Write out Bezier control points.
        for n in range(len(controlPts)):
            fo3.write("%.6e %.6e\n" % (controlPts[n][0], controlPts[n][1]))
        fo3.write("\n")
    # Also write out optimisation statistics.
    if tokens[0] == "Number":
        noFuncEvals = int(tokens[5])
    if tokens[0] == "Current":
        nIter += n_checks
        fo2.write("%d %d %s\n" % (nIter, noFuncEvals, tokens[4]))

fi.close()
fo.close()
fo2.close()
fo3.close()

