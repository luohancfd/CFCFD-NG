#! /usr/bin/env python 
# generate-optimised-curves-comparison.py
#
# Wilson Chan, 25 May 2012.
# ------------------------------------------------------------------

from math import *

def eval_Bezier(bezCtrlPts, t):
    """
    Return the x- and y-coordinates of point t (0 < t < 1) on
    the Bezier curve generated by the input control points .
    """
    n = len(bezCtrlPts) - 1
    blendingFunc = []
    # Generate blending functions.
    for i in range(len(bezCtrlPts)):
        blendingFunc.append((factorial(n) /(factorial(i)*factorial(n-i))) *\
            pow(t,i) * pow((1-t),(n-i)))
    # Get x and y coordinates.
    x = 0.0; y = 0.0
    for i in range(len(bezCtrlPts)):
        x += blendingFunc[i] * bezCtrlPts[i][0]
        y += blendingFunc[i] * bezCtrlPts[i][1]
    return x, y


# ------------------------------------------------------------------

nPtsOnCurve = 1000  # Number of points on curve generated by the Bezier points

nIter =  0
n_checks = 5 # As per specified in optimisation script.

fo = open("optimised-curves-comparison.data", "w")
fo2 = open("residuals.data", "w")
fo3 = open("optimised-curves-controlpts.data", "w")

# Read in initial Bezier control points
controlPts = []
fi = open("../Bezier-control-pts-t4-m4.initial.data", "r")
fi.readline()
while True:
    buf = fi.readline().strip()
    if len(buf) == 0: break
    tokens = [float(word) for word in buf.split()]
    controlPts.append([tokens[0], tokens[1]])
fi.close()
    
# Generate data points for the Bezier curve
for n in range(nPtsOnCurve+1):
    t = float(n)/float(nPtsOnCurve)
    x, y = eval_Bezier(controlPts, t)
    fo.write("%.6e %.6e\n" % (x, y))
fo.write("\n")

# Write out Bezier control points
for n in range(len(controlPts)):
    fo3.write("%.6e %.6e\n" % (controlPts[n][0], controlPts[n][1]))
fo3.write("\n")

# Read all optimised curves
fi = open("../nelmin.log", "r")
while True:
    buf = fi.readline().strip()
    if len(buf) == 0: break
    tokens = [word for word in buf.split()]
    if tokens[0] == "x":
        # Generate control points.
        for n in range(2, len(controlPts)):
            if n == 2:
                newY = controlPts[n-1][1] + float(tokens[n][1:9])
            else:
                newY = controlPts[n-1][1] + float(tokens[n][0:8])
            controlPts[n][1] = newY
        # Generate data points for the Bezier curve
        for n in range(nPtsOnCurve+1):
            t = float(n)/float(nPtsOnCurve)
            x, y = eval_Bezier(controlPts, t)
            fo.write("%.6e %.6e\n" % (x, y))
        fo.write("\n")
        # Write out Bezier control points
        for n in range(len(controlPts)):
            fo3.write("%.6e %.6e\n" % (controlPts[n][0], controlPts[n][1]))
        fo3.write("\n")
    # Write out optimisation statistics
    if tokens[0] == "Number":
        noFuncEvals = int(tokens[5])
    if tokens[0] == "Current":
        nIter += n_checks
        fo2.write("%d %d %s\n" % (nIter, noFuncEvals, tokens[4]))

fi.close()
fo.close()
fo2.close()
fo3.close()

