-- Lua script for the vertex velocity
--
-- Author: Jason Kan Qin
-- Date: 13-Dec-2014

-- dummy functions to keep eilmer3 happy

function at_timestep_start(args) return nil end
function at_timestep_end(args) return nil end

local R = 23e-3
local thickness = 0.5e-3
local Inertia = 2700 * thickness * R^3 /3
local Moment_retard = 0 --1.25
local Angular_velocity = 0
local Angle = 30.
local T_last = 0
local P_amb = 35.8e3 -- static pressure acting on lower side of flexible part

function before_grid_update(args)



    -- only block 3 needs to be processed

    b_id = args.block_id -- block ID (number generated by e3prep.py) 
 
    if b_id == 2 then


        t = args.t -- current simulation time 
        print ("Running before_grid_update")

        local Delta_t = t - T_last
        T_last = t

        -- block 1 needs to integrate pressure acting on lower boundary obtain total force
        local imin = 2
        local jmin = 2
        local imax = 52 
        local Moment = 0 
        local P_mean = 0       
        local C_u = 0 -- x-velocity of node C
        local C_v = 0 -- x-velocity of node C      

        A0 = sample_vtx(b_id,imin,jmin,0) -- south-west corner
        A1 = sample_vtx(b_id,imax,jmin,0) -- south-east corner
        for i = imin,(imax-1) do 
            Dat = sample_flow(b_id,i,jmin,0) -- data can only be sampled from current block. 
            -- If data from multiple blocks is required, this must be delayed until vtx_velocity()
            arm = ((Dat.x - A0.x)^2 + (Dat.y - A0.y)^2 )^0.5
            p = (Dat.p - P_amb)    -- pressure, after subtracting localc static pressure 
            f = p * Dat.iLength
            P_mean = P_mean + p
            --print (Dat.p) 
            --print (Dat.p-5955)
            --print (Dat.iLength)
            --print (Moment)
            Moment = Moment + arm*f
        end 

        -- check if corner bending moment is overcome
        if Moment > Moment_retard then
           Moment = Moment - Moment_retard
        else
           Moment = 0
        end 
        -- use moment to calculate angular acceleration and movement
        Accel = Moment / Inertia
        Angular_velocity = Angular_velocity - Accel * Delta_t
        Angle = Angle + Angular_velocity / math.pi *180. * Delta_t 
        print ("Moment",Moment)
        -- print ("Accel", Accel)
        print ("Mean Pressure on Plate (kPa)", P_mean/50. *1/1000)
        -- print ("Delta Angle_dot", Accel *Delta_t)
        print ("Delta_t",Delta_t)
        print ("Angle_dot (rad/s)", Angular_velocity)
        print ("Angle (deg)", Angle)

        -- Set velocities at end of plate
        C_u = - Angular_velocity * R * ((A1.y-A0.y) / R) -- x velocity at point 1 and 2
        C_v = Angular_velocity * R * ((A1.x-A0.x) / R) -- y velocity at point 1 
      
        local file = io.open("test_file","w")   
        file:write(C_u, "\n") -- write C_u to first line
        file:write(C_v, "\n") -- write C_v to second line
        file:close()

    end

return nil end


function vtx_velocity(args)

    src = {}
    b_id = args.bdp_id -- block ID (number generated by e3prep.py)  

    if b_id == 0 then
        -- vtx for blk_0 are kept stationary
        src.vel_x = 0
        src.vel_y = 0
        src.vel_z = 0   
    elseif b_id == 1 then
        -- vtx for blk_0 are kept stationary
        src.vel_x = 0
        src.vel_y = 0
        src.vel_z = 0   
    elseif b_id == 2 then
        -- vtx for blk_1 are move based on linear interpolation    
        local imin = 2
        local jmin = 2
        local imax = 52 
        local jmax = 12

        i = args.i -- vertex index (includes ghost vtx)
        j = args.j -- vertex index (includes ghost vtx)

        if (i == imin and j == jmin) then -- loading routine only needs to be run at first call (imin, jmin) 
            -- load variables from file
            local file = io.open("test_file","r") 
            C_u = file:read("*number")
            C_v = file:read("*number")
            print("C_u loaded from file",C_u)
            print("C_v loaded from file",C_v)
            file:close() 
        end

        src.vel_x = (i-imin)/(imax-imin) * C_u
        src.vel_y = (i-imin)/(imax-imin) * C_v   -- * (jmax-j)/(jmax-jmin)
        src.vel_z = 0


    else 

        local imin = 2
        local jmin = 2

        i = args.i -- vertex index (includes ghost vtx)
        j = args.j -- vertex index (includes ghost vtx)

        if (i == imin and j == jmin) then
            -- load variables from file
            local file = io.open("test_file","r") 
            C_u = file:read("*number")
            C_v = file:read("*number")
            file:close() 
        end
        -- code that will load C_u and C_v

        src.vel_x = C_u
        src.vel_y = C_v
        src.vel_z = 0 
    end  
       
return src end
