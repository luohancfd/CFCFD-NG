#!/usr/bin/env python
## \file script_noneq.py
## \ingroup libnoneq
## \brief Python program to specify a nonequilibrium system.
##
## \author Rowan J Gollan
## \version 06-Mar-2006

import os
import sys
import re
import string
from copy import copy
from getopt import getopt
from time import strftime

from species_library import *
from parse_reaction import parse_reaction

sys.path.append(os.path.expandvars("$HOME/cfd_bin")) # installation directory
sys.path.append("") # so that we can find user's scripts in current directory
from libgas2 import *

reac_count = 0

known_elements = [ 'E', 'e-',
    'H',                                            'He',
    'Li', 'Be',       'B',  'C',  'N',  'O',  'F',  'Ne',
    'Na', 'Mg',       'Al', 'Si', 'P',  'S',  'Cl', 'Ar',
    'K',  'Ca',

                                              'I',
                   'AA', 'BB'                  
    ]

# Note: AA and BB are dummy elements for artificial species

class GlobalNoneqData(object):
    """Python class to organize the global data for a nonequilibrium system.

    The user's script does not create this object but rather just alters
    attributes of the global object.
    """
    __slots__ = 'elem_list', 'species_list', 'reactions_list', \
                'props_file', 'config_file', 'input_file', 'err_tol', 'T_trigger', \
                'method', 'step_routine', \
                'max_step_attempts', 'max_increase_factor', 'max_decrease_factor', \
                'decrease_factor', 'notes'
    
    count = 0
    def __init__(self):

        if GlobalNoneqData.count >= 1:
            raise Exception, "Already have a GlobalNoneqData object defined."
        self.elem_list = []
        self.species_list = []
        self.reactions_list = []
        self.props_file = ""
        self.config_file = ""
        self.input_file = ""
        self.err_tol = 0.1
        self.T_trigger = 0.0
        self.method = "ode"
        self.step_routine = "qss"
        self.max_step_attempts = 4
        self.max_increase_factor = 1.15
        self.max_decrease_factor = 0.01
        self.decrease_factor = 0.333
        self.notes = ""

        GlobalNoneqData.count = 1
        return

    def declare_elements(self, elem_list ):
        self.elem_list = copy( elem_list )
        for elem in self.elem_list:
            if( not elem in known_elements ):
                raise Exception, "Element: %s is not part of known_elements." % elem
        return

    def declare_species(self,  species_list ):
        self.species_list = copy( species_list )
        for species in species_list:
            if( not check_species(species) ):
                raise Exception, "Species: %s contains an element which is not part of known_elements." % species
        return

    def declare_reactions(self, reactions_list ):
        self.reactions_list = copy( reactions_list )
        

    def write_properties_file(self):
        if self.props_file == "":
            raise Exception, "The props_file name has not been declared."
        if self.species_list == []:
            raise Exception, "The species_list is empty. Check that it has been declared."

        ofp = open(self.props_file, "w")

        ofp.write("# %s \n" % self.props_file )
        ofp.write("# auto-generated by script_noneq.py based on input file: %s\n" % self.input_file)
        ofp.write("\n# Time of file creation: %s \n\n" % strftime("%d-%b-%Y %X") )

        ofp.write("[global]\n")
        ofp.write("number_of_species = %d\n" % len(self.species_list))
        ofp.write("species = ")
        for spec in self.species_list:
            ofp.write("%s " % spec)
        ofp.write("\n\n")

        for spec in self.species_list:
            ofp.write("[%s]\n" % spec)
            str = gather_info_for_species(spec)
            ofp.write("%s\n" % str)

        ofp.close()
                 

    def write_config_file(self):
        if self.config_file == "":
            raise Exception, "The config_file name has not been declared."
        if self.reactions_list == []:
            raise Exception, "The reactions_list is empty. Check that it has been declared."

        ofp = open( self.config_file, "w")

        ofp.write("# %s \n" % self.config_file )
        ofp.write("# auto-created by script_noneq.py based on input file: %s\n" % self.input_file )
        if self.notes != "":
            ofp.write("%s" % self.notes )
        ofp.write("\n# Time of file creation: %s \n\n" % strftime("%d-%b-%Y %X") )

        ofp.write("[reaction_scheme]\n")
        ofp.write("number_of_reactions        = %d\n" % len(self.reactions_list))
        ofp.write("err_tol                    = %e \n" % self.err_tol)
        ofp.write("T_trigger                  = %.1f\n" % self.T_trigger)
        ofp.write("method                     = %s\n" % self.method)
        ofp.write("\n")
        if( self.method == "ode" ):
            ofp.write("[ode_method]\n")
            ofp.write("step_routine               = %s\n" % self.step_routine)
            ofp.write("max_step_attempts          = %d\n" % self.max_step_attempts)
            ofp.write("max_increase_factor        = %g\n" % self.max_increase_factor)
            ofp.write("max_decrease_factor        = %g\n" % self.max_decrease_factor)
            ofp.write("decrease_factor            = %g\n" % self.decrease_factor)
        elif( self.method == "ode_mc" ):
            ofp.write("[ode_mc_method]\n")
            ofp.write("step_routine               = %s\n" % self.step_routine)
            ofp.write("max_step_attempts          = %d\n" % self.max_step_attempts)
            ofp.write("max_increase_factor        = %g\n" % self.max_increase_factor)
            ofp.write("max_decrease_factor        = %g\n" % self.max_decrease_factor)
            ofp.write("decrease_factor            = %g\n" % self.decrease_factor)
        else:
            raise Exception, "The method for system solution, %s, is not known." % self.method

        ofp.write("\n")

        for i, reac in enumerate(self.reactions_list):
            ofp.write("[reac-%d]\n" % i)
            ofp.write("%s\n" % reac.str() )
        ofp.close()

    def write_latex_tabular(self, fname):
        """Writes out a LaTeX tabular environment of reaction rates.

        This function will work for normal Arrhenius type reactions.
        """
        ofp = open(fname, 'w')
        
        # 1. Tabular opening
        ofp.write(r"\begin{tabular}{l|ccd{2}d{1}}"); ofp.write("\n")
        ofp.write(r"\hline \hline"); ofp.write("\n")
        ofp.write(r"\multicolumn{1}{c|}{Reaction} & \multicolumn{4}{c}{Reaction rate coefficients} \\")
        ofp.write("\n")
        ofp.write(r"\hline"); ofp.write("\n")

        # 2. Now ready for reactions
        for ir, reac in enumerate(self.reactions_list):
            r_dict = parse_reaction(reac.equation())
            ofp.write(r"\verb:%d. %s: & " % (
                    ir+1, reac.equation()))
            # Add forward rates if of Arrhenius type
            fr = reac.get_fr_model()
            br = reac.get_br_model()
            if fr.model() == "GeneralisedArrhenius":
                nc = 0
                for c in r_dict['reactants']:
                    if 'pd_form' not in c:
                        nc += c['coeff']
                ofp.write(r"%s \\" % fr.latex_str(nc)); ofp.write("\n")
                if br.model() == "GeneralisedArrhenius":
                    nc = 0
                    for c in r_dict['products']:
                        if 'pd_form' not in c:
                            nc += c['coeff']
                    ofp.write(r" & %s \\" % br.latex_str(nc)); ofp.write("\n")
            elif br.model() == "GeneralisedArrhenius":
                ofp.write(r" & ")
                nc = 0
                for c in r_dict['products']:
                    if 'pd_form' not in c:
                        nc += c['coeff']
                ofp.write(r"%s \\ \hline" % br.latex_str(nc)); ofp.write("\n")
            else:
                print "Error: neither the forwards or backwards rate are"
                print "of type GeneralisedArrhenius, therefore cannot"
                print "continue to write LaTeX file."
                sys.exit(1)
            
            ofp.write(r"\hline"); ofp.write("\n")
        
        ofp.write(r"\hline"); ofp.write("\n")
        ofp.write(r"\end{tabular}"); ofp.write("\n")

        ofp.close()
        return
        

#
# Helper functions
#

digit = re.compile(r'[0-9]')
notdigit = re.compile(r'^[0-9]')
letter = re.compile(r'[a-zA-Z]')
capLetter = re.compile(r'[A-Z]')
lowLetter = re.compile(r'[a-z]')

def translate_e_name(List, stra, strb):

    for i in range(len(List)):
            if List[i] == stra:
                List[i] = strb       
    return List

def is_an_integer(x):
    try:
        int(x)
        return True
    except ValueError:
        return False

def is_a_float(x):
    try:
        float(x)
        return True
    except ValueError:
        return False

def check_species(spec):
    """
    This function checks that a species string represents an allowable
    species (at least in terms of the previously declared elements)
    """
    flag = True
    str = spec
    test_str = ''
    stra = ''
    while str != '':
        if letter.match(str[0]):
            stra += str[0]
        elif str[0] == '-':
            stra += str[0]
        else:
            if stra != '':
                test_str += stra
                stra = ''
        str = str[1:]

    for elem in test_str:
        if not elem in known_elements:
            flag = False
	    
    if test_str in known_elements:
	flag = True

    return flag

def split_species_str(spec):
    """
    Splits a species out into its full form.
    """
    if spec == 'e-':
        return [ 'e-', ]
    spec_tokens = []
    temp_tokens = []
    for i in range(len(spec)):
        temp_tokens.append(spec[i])

    for tk in temp_tokens:
        if capLetter.match(tk):
            spec_tokens.append(tk)
        elif lowLetter.match(tk):
            tstr = spec_tokens[-1] + tk
            spec_tokens[-1] = tstr
        elif digit.match(tk):
            tstr = spec_tokens[-1]
            if digit.match(tstr[-1]):
                tstr = tstr + tk
                spec_tokens[-1] = tstr
            else:
                spec_tokens.append(tk)
        elif tk == '+':
            spec_tokens.append(tk)
        else:
            print 'Unknown symbol in species name ' + tk

    return spec_tokens

def count_elements_in_species(spec, elemList):
    """
    Given a single species name, return the number of each
    type of elements.
    """
    spec_tokens = split_species_str(spec)
    n_e = len(elemList)
    e_count = range(n_e)
    for i in range(n_e):
        e_count[i] = 0

    for i in range(len(spec_tokens)):
        tk = spec_tokens[i]
        if tk in elemList:
            curr_elem = tk
            curr_count = 1
            try:
                tstr = spec_tokens[i+1]
            except IndexError:
                pass
            else:
                if is_an_integer(tstr):
                    curr_count = string.atoi(tstr)
                else:
                    pass

            ie = elemList.index(curr_elem)
            e_count[ie] += curr_count
        else:
            pass

    return e_count
    
def count_elements_in_list(f_index, f_coeffs, spList, elemList):
    """
    Given a list of species indices (as the reactants and
    products are recorded), tally up the elements.
    """
    n_e = len(elemList)
    e_count = range(n_e)

    for i in range(n_e):
        e_count[i] = 0

    for i in range(len(f_index)):
        index = f_index[i]
        coeff = f_coeffs[i]
        spec = spList[index]
        temp_count = count_elements_in_species(spec, elemList)
        for j in range(n_e):
            temp_count[j]  = coeff*temp_count[j]
            e_count[j] += temp_count[j]

    return e_count

def count_charge_in_species(spec):
    """
    Given a single species name, count the charge.
    """

    spec_tokens = split_species_str(spec)
    plus_count = 0
    minus_count = 0

    for i in range(len(spec_tokens)):
        tk = spec_tokens[i]
        if tk == 'E' or tk == 'e-':
            minus_count += 1
        elif tk == '+':
            plus_count += 1
        else:
            pass
        
    return (plus_count - minus_count)

def count_charge_in_list(f_index, f_coeffs, spList):
    """
    Given a list of species (as the reactants and products
    are stored), tally up the charge.
    """
    charge = 0
    
    for i in range(len(f_index)):
        index = f_index[i]
        coeff = f_coeffs[i]
        spec = spList[index]
        charge += coeff * count_charge_in_species(spec)

    return charge
    
def is_str_a_molecule(str):
    full_rep = split_species_str(str)
    if len(full_rep) > 1:
        return True
    else:
        return False

def check_mass_balance(f_index, f_coeffs,
                       b_index, b_coeffs, spList, elemList):
    """
    This function checks the conservation of elements in a reaction
    description.
    Returns (flag, msg)
    flag - indicates whether the equation is balanced or not
    msg - prints an error message if unbalanced
    """

    f_count = count_elements_in_list(f_index, f_coeffs, spList, elemList)
    b_count = count_elements_in_list(b_index, b_coeffs, spList, elemList)

    flag = True
    msg = ''
    for i in range(len(f_count)):
        # Ignore electrons in mass balance, we'll pick this up in charge balance
        if( elemList[i] == "E" or elemList[i] == "e-" ):
            continue
        if f_count[i] != b_count[i]:
            flag = False
            msg += 'Check element ' + elemList[i] + ' - it does not seem to balance.'

    return (flag, msg)

def check_charge_balance(f_index, f_coeffs,
                         b_index, b_coeffs,
                         spList):
    """
    This function checks the conservation of fundamental charge
    in a reaction description.
    Returns (flag, msg)
    flag - indicates whether the charge is balanced or not
    msg - prints an error message if unbalanced
    """

    f_charge = count_charge_in_list(f_index, f_coeffs, spList)
    b_charge = count_charge_in_list(b_index, b_coeffs, spList)

    flag = True
    msg = ''
    if f_charge != b_charge:
        flag = False
        msg += 'Check charge - it does not seem to balance.'

    return (flag, msg)


def make_reaction( equation,
                   label="",
                   fr="",
                   br=from_eq_const(),
                   dr="",
                   eq=from_thermo(),
                   reac_type="GeneralReaction",
                   efficiencies=None,
                   participating_ivib=[-1]):
    
    # 1. Let's parse the reaction string (desc) and check
    #    mass balance
    r_dict = parse_reaction(equation)

    f_index = []
    f_coeffs = []
    b_index = []
    b_coeffs = []
    thirdbody = False
    falloff = False
    thirdbody_index = -1

    for p in r_dict['reactants']:
        if not 'pd_term' in p:
            sp = p['sp']
            if sp in ndata.species_list:
                sp_idx = ndata.species_list.index(sp)
                f_index.append(sp_idx)
                f_coeffs.append(p['coeff'])
                if sp == 'AA':
                    reac_type = "SingleStep"
            elif sp == 'M':
                thirdbody = True
                reac_type = "ThirdBodyReaction"
            else:
                print "Species ", sp, " not found in declared species list."
                print "Check the list in ndata.declare_species()."
                print "This occurred in reaction:", equation
                sys.exit(1)
        else:
            reac_type = "FallOffReaction"
            falloff = True
            sp = p['sp']
            if sp in ndata.species_list:
                thirdbody_index = ndata.species_list.index(sp)
            elif sp == 'M':
                thirdbody_index = -1
            else:
                print "Species ", sp, " not found in declared species list."
                print "Check the list in ndata.declare_species()."
                print "This occurred in reaction:", equation
                sys.exit(1)
                
            if p['coeff'] > 1:
                print "It does not make sense to specify a coefficient"
                print "for a species participating as a collider in"
                print "in a presssure-dependent reaction."
                print "The problem is: ( + ", p['coeff'], " ", p['sp'], ")"
                print "This occurred in reaction:", equation
                sys.exit(1)

    for p in r_dict['products']:
        if not 'pd_term' in p:
            sp = p['sp']
            if sp in ndata.species_list:
                sp_idx = ndata.species_list.index(sp)
                b_index.append(sp_idx)
                b_coeffs.append(p['coeff'])
                if sp == 'BB':
                    reac_type = "SingleStep"
            elif sp == 'M':
                thirdbody = True
                reac_type = "ThirdBodyReaction"
            else:
                print "Species ", sp, " not found in declared species list."
                print "Check the list in ndata.declare_species()."
                print "This occurred in reaction:", equation
                sys.exit(1)
        else:
            reac_type = "FallOffReaction"
            falloff = True
            sp = p['sp']
            if sp in ndata.species_list:
                thirdbody_index = ndata.species_list.index(sp)
            elif sp == 'M':
                thirdbody_index = -1
            else:
                print "Species ", sp, " not found in declared species list."
                print "Check the list in ndata.declare_species()."
                print "This occurred in reaction:", equation
                sys.exit(1)
                
            if p['coeff'] > 1:
                print "It does not make sense to specify a coefficient"
                print "for a species participating as a collider in"
                print "in a presssure-dependent reaction."
                print "The problem is: ( + ", p['coeff'], " ", p['sp'], ")"
                print "This occurred in reaction:", equation
                sys.exit(1)

    # Check the mass and charge balance
    if( reac_type != "SingleStep" ):
        (val, msg) = check_mass_balance(f_index, f_coeffs, b_index, b_coeffs,
                                        ndata.species_list, ndata.elem_list)
        if val == False:
            print 'There is a problem balancing the mass for:'
            print equation
            print msg
            sys.exit(-1)

        (val, msg) = check_charge_balance(f_index, f_coeffs, b_index, b_coeffs,
                                          ndata.species_list)
        if val == False:
            print 'There is a problem balancing the charge for:'
            print equation
            print msg
            sys.exit(-1)

    #
    # Do a few more sanity checks
    #
    if r_dict['direction'] == "forward_only":
        print "Setting the backwards rate to 0.0 for reaction:"
        print equation
        print "because the '=>' symbol indicates that is only"
        print "proceeds in the forwards direction."
        br = GeneralisedArrhenius("_b", 0.0, 0.0, 0.0)
    
    if reac_type == "FallOffReaction":
        if dr == "":
            print "There is a problem with reaction:"
            print equation
            print "The form suggests a pressure-dependent fall-off"
            print "reaction but the low pressure reaction rate (dr)"
            print "is not specified."
            sys.exit(1)

    #
    # Now create a reaction based on the reac_type
    #

    if( reac_type == "Dissociation" ):
        reac = Dissociation( label, equation, fr, br, eq, participating_ivib,
                             f_index[0], b_index[0], b_index[1], f_index[1] )
    elif( reac_type == "Exchange" ):
        reac = Exchange( label, equation, fr, br, eq, participating_ivib,
                         f_index[0], b_index[0], b_index[1], f_index[1])

    elif( reac_type == "ThirdBodyReaction" ):
        if efficiencies == None:
            reac = ThirdBodyReaction( label, equation, fr, br, eq, participating_ivib,
                                      f_index, f_coeffs, b_index, b_coeffs )
        else:
            eff_list = []
            for i in range(len(ndata.species_list)):
                eff_list.append(1.0)

            for species,eff in efficiencies:
                if species in ndata.species_list:
                    eff_list[ ndata.species_list.index(species) ] = eff
                else:
                    print "Warning species %s is not in species list when trying to list efficiency." \
                          % species
            reac = ThirdBodyReaction( label, equation, fr, br, eq, participating_ivib,
                                      f_index, f_coeffs, b_index, b_coeffs,
                                      eff_list )

    elif( reac_type == "FallOffReaction" ):
        # Fall-off reactions always contain a third body, although they do not always take part
        # in the reaction. The reaction rate transitions or "falls off" between two limiting
        # reaction rates with a pressure dependency.
        # If an efficiency list is not supplied, a unary array is substituted.
        if efficiencies == None:
            reac = FallOffReaction( label, equation, fr, br, dr, eq, participating_ivib,
                                f_index, f_coeffs, b_index, b_coeffs )
        else:
            eff_list = []
            for i in range(len(ndata.species_list)):
                eff_list.append(0.0)
                
            if thirdbody_index != -1:
                print "Warning the efficiciencies list for reaction:"
                print equation
                print "is being ignored because a specific species:"
                print ndata.species_list[thirdbody_index]
                print "was listed. A constructed list gives this value"
                print "an efficiency of 1.0 and all others, 0.0"

                eff_list[thirdbody_index] = 1.0
            else:
                for species,eff in efficiencies:
                    if species in ndata.species_list:
                        eff_list[ ndata.species_list.index(species) ] = eff
                    else:
                        print "Warning species %s is not in species list when trying to list efficiency." \
                          % species
            reac = FallOffReaction( label, equation, fr, br, dr, eq, participating_ivib,
                                    f_index, f_coeffs, b_index, b_coeffs, eff_list )

    elif( reac_type == "SingleStep" ):
        reac = SingleStep( label, equation, fr, f_index[0], b_index[0] )
    else:
        # a general reaction
        reac = GeneralReaction( label, equation, fr, br, eq, participating_ivib,
                                f_index, f_coeffs, b_index, b_coeffs )

    global reac_count
    reac_count += 1
    print "Data for reaction ", reac_count, " gathered: ", reac.equation()
    return reac

def gather_info_for_species(spec_str):
    if spec_str not in available_species:
        print "The requested species ", spec_str, " is not available in the"
        print "species database: species_library.py"
        print "The thermodynamic and transport property data will need to be added"
        print "to the database."
        print "Bailing out!"
        sys.exit(-1)

    spec = available_species[spec_str]
    type = spec['type'].split()
    if( type[0] == "molecule" ):
        mol_type = type[1]
        
    strA = ""
    strA += "type = %s\n" % spec['type']
    strA += "mol_weight = %.8e\n" % spec['mol_weight']
    strA += "sigma = %.8e\n" % spec['sigma']
    strA += "epsilon = %.8e\n" % spec['epsilon']
    if( type[0] == "molecule" ):
        if( mol_type == "non-polar" ):
            strA += "polarizability = %f \n" % spec['polarizability']
        else:
            strA += "dipole_moment = %f \n" % spec['dipole_moment']
    strA += "\n"

    no_s = spec['no-s-segments']
    strA += "no-s-segments = %d\n" % no_s
    for i in range(no_s):
        key = "range-s-" + str(i)
        T_range = spec[key]
        strA += "%s = %.1f %.1f \n" % (key, T_range[0], T_range[1])
        key = "coeffs-s-" + str(i)
        coeffs = spec[key]
        strA += "%s = " % key
        for val in coeffs:
            strA += "%.8e " % val
        strA += "\n"
    strA += "\n"
    
    no_mu = spec['no-mu-segments']
    strA += "no-mu-segments = %d\n" % no_mu
    for i in range(no_mu):
        key = "range-mu-" + str(i)
        T_range = spec[key]
        strA += "%s = %.1f %.1f \n" % (key, T_range[0], T_range[1])
        key = "coeffs-mu-" + str(i)
        coeffs = spec[key]
        strA += "%s = " % key
        for val in coeffs:
            strA += "%.8e " % val
        strA += "\n"
    strA += "\n"

    no_k = spec['no-k-segments']
    strA += "no-k-segments = %d\n" % no_k
    for i in range(no_k):
        key = "range-k-" + str(i)
        T_range = spec[key]
        strA += "%s = %.1f %.1f \n" % (key, T_range[0], T_range[1])
        key = "coeffs-k-" + str(i)
        coeffs = spec[key]
        strA += "%s = " % key
        for val in coeffs:
            strA += "%.8e " % val
        strA += "\n"

    if 'warning' in spec:
        print "There is a warning about the data for ", spec_str, " in the species_library.py"
        print spec['warning']

    return strA

ndata = GlobalNoneqData()

def main():
    from optparse import OptionParser

    usage =  "usage: %prog -i reac_desc.py|--input-script=reac-desc.py\n"
    usage += "             -p props.pgm|--properties-file=props.pgm\n"
    usage += "             -r reac.rsi|--reac-file=reac.rsi\n"
    usage += "             -l reac.tex|--latex-file=reac.tex"
    parser = OptionParser(usage=usage)
    parser.add_option( "-i", "--input-script",
                       action="store", type="string", dest="inFile",
                       help="input Python script for reaction description")
    parser.add_option( "-p", "--properties-file",
                       action="store", type="string", dest="propsFile",
                       help="species property data in format for C++ module")
    parser.add_option( "-r", "--reac-file",
                       action="store", type="string", dest="reacFile",
                       help="output configuration file for C++ module")
    parser.add_option( "-l", "--latex-file",
                       action="store", type="string", dest="latexFile",
                       help="output LaTeX file of table describing reactions")

    (options, args) = parser.parse_args()

    ndata.input_file = options.inFile
    ndata.props_file = options.propsFile
    ndata.config_file = options.reacFile
    execfile( options.inFile )

    if( options.propsFile != None ):
        ndata.write_properties_file()
        print "Species properties file %s created.\n" % options.propsFile

    if( options.reacFile != None ):
        ndata.write_config_file()
        print "Configuration file %s for ReactionScheme description created." % options.reacFile
    if( options.latexFile != None ):
        ndata.write_latex_tabular(options.latexFile)
        print "LaTeX file %s for ReactionScheme description created." % options.latexFile


if __name__ == '__main__':
    main()

    
    
    
        
    
