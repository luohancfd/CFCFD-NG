/** \file Bender-real-gas-EOS.cxx
 *  \ingroup gas
 *
 *  \author Peter Blyton
 *  \version 13-Mar-2012
 */

#include <iostream>
#include <sstream>
#include <cmath>

#include "../../util/source/useful.h"
#include "../../util/source/lua_service.hh"
#include "physical_constants.hh"
#include "Bender-real-gas-EOS.hh"

using namespace std;

const double BRG_PROPS_CONVERGE_TOL = 0.001;
const int BRG_MAX_ITERATIONS = 10;

Bender_real_gas::
Bender_real_gas(lua_State *L)
    : Equation_of_state()
{
    lua_getglobal(L, "species"); // Put the list of species table to TOS

    if ( !lua_istable(L, -1) ) {
        ostringstream ost;
        ost << "Bender_real_gas::Bender_real_gas():\n";
        ost << "Error in the declaration of species: a table is expected.\n";
        input_error(ost);
    }

    if ( lua_objlen(L, -1) != 1 ) {
        ostringstream ost;
        ost << "Bender_real_gas::Bender_real_gas():\n";
        ost << "Error in the declaration of species: single species expected.\n";
        input_error(ost);
    }

    lua_rawgeti(L, -1, 1); // Put the specific species name to TOS
    const char* sp = luaL_checkstring(L, -1);
    lua_pop(L, 1); // pop specific species name off stack
    lua_pop(L, 1); // pop list of species table off stack

    lua_getglobal(L, sp); // Now bring the specific species table to TOS
    if ( !lua_istable(L, -1) ) {
        ostringstream ost;
        ost << "Bender_real_gas::Bender_real_gas()\n";
        ost << "Error locating information table for species: " << sp << endl;
        input_error(ost);
    }

    double M;
    M = get_positive_value(L, -1, "M");
    M_.push_back(M);
    R_ = PC_R_u/M;

    lua_getfield(L, -1, "Bender_EOS_coeffs"); // Bring EOS coeffs to TOS
    A_ = get_vector(L, -1, "A");
    lua_pop(L, 1); // pop EOS coeffs off stack
    lua_pop(L, 1); // pop specific species table off stack
}

Bender_real_gas::
~Bender_real_gas() {}

int
Bender_real_gas::
s_eval_pressure(Gas_data &Q)
{
    Q.p = brg_pressure(Q.rho, Q.T[0], R_, A_);
    return SUCCESS;
}

int
Bender_real_gas::
s_eval_temperature(Gas_data &Q)
{
    int status;
    Q.T[0] = brg_temperature(Q.rho, Q.p, R_, A_, status);
    return status;
}

int
Bender_real_gas::
s_eval_density(Gas_data &Q)
{
    int status;
    Q.rho = brg_density(Q.T[0], Q.p, R_, A_, status);
    return status;
}

double
Bender_real_gas::
s_gas_constant(const Gas_data &Q, int &status)
{   // Return the "equivalent" R for the ideal gas equation, needed by CFD code.
    status = SUCCESS;
    return Q.p / (Q.rho * Q.T[0]);
}

double 
Bender_real_gas::
s_prho_ratio(const Gas_data &Q, int isp)
{
    return brg_pressure(Q.rho, Q.T[0], R_, A_)/Q.rho;
}

double
Bender_real_gas::
s_dTdp_const_rho(const Gas_data &Q, int &status)
{
    return 1.0/brg_dpdT(Q.rho, Q.T[0], R_, A_);
}

double
Bender_real_gas::
s_dTdrho_const_p(const Gas_data &Q, int &status)
{   // Calculate using the chain rule.
    return s_dTdp_const_rho(Q, status)*s_dpdrho_const_T(Q, status);
}

double
Bender_real_gas::
s_dpdrho_const_T(const Gas_data &Q, int &status)
{
    status = SUCCESS;
    return brg_dpdrho(Q.T[0], Q.p, R_, A_);
}

double
Bender_real_gas::
s_dpdrho_i_const_T(const Gas_data &Q, int isp, int &status)
{
    status = SUCCESS;
    return brg_dpdrho(Q.T[0], Q.p, R_, A_);
}

double
Bender_real_gas::
s_dpdT_i_const_rho(const Gas_data &Q, int itm, int &status)
{
    status = SUCCESS;
    return brg_dpdT(Q.rho, Q.T[0], R_, A_);
}

double
Bender_real_gas::
s_integral_const_T_energy(const Gas_data &Q)
{
    return brg_integral_const_T_energy(Q.rho, Q.T[0], R_, A_);
}

double
Bender_real_gas::
s_integral_const_T_entropy(const Gas_data &Q)
{
    return brg_integral_const_T_entropy(Q.rho, Q.T[0], R_, A_);
}

double brg_pressure(double rho, double T, double R, const std::vector<double> &A)
{
    // Bender p-rho-T equation of state as generated by sympy from the
    // utility script Bender-gas-equations.py.
    return A[13]*pow(rho, 6) + R*T*rho
        + pow(rho, 5)*(A[11]*T + A[12])
        + pow(rho, 4)*(A[10] + A[9]*T) + pow(rho, 3)*(A[6]*T + A[7] + A[8]/T)
        + pow(rho, 2)*(A[1]*T + A[2] + (A[3] + (A[4] + A[5]/T)/T)/T)
        + pow(rho, 5)*(A[17] + (A[18] + A[19]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 2)
        + pow(rho, 3)*(A[14] + (A[15] + A[16]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 2);
}

double brg_dpdT(double rho, double T, double R, const std::vector<double> &A)
{
    // Derivative of pressure w.r.t temperature as generated by sympy from the
    // utility script Bender-gas-equations.py.
    // This is needed for the integrals for internal energy and entropy.
    // Also used to iteratively solve the EOS for temperature using Newtons method.
    return A[11]*pow(rho, 5) + A[9]*pow(rho, 4) + R*rho
        + pow(rho, 3)*(A[6] - A[8]/pow(T, 2))
        + pow(rho, 2)*(A[1] + (-A[5]/pow(T, 3) - (A[4] + A[5]/T)/pow(T, 2))/T - (A[3] + (A[4] + A[5]/T)/T)/pow(T, 2))
        + pow(rho, 5)*(-A[19]/pow(T, 3) - (A[18] + A[19]/T)/pow(T, 2))*exp(-A[20]*pow(rho, 2))/pow(T, 2)
        + pow(rho, 3)*(-A[16]/pow(T, 3) - (A[15] + A[16]/T)/pow(T, 2))*exp(-A[20]*pow(rho, 2))/pow(T, 2)
        - 2*pow(rho, 5)*(A[17] + (A[18] + A[19]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 3)
        - 2*pow(rho, 3)*(A[14] + (A[15] + A[16]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 3);
}

double brg_dpdrho(double rho, double T, double R, const std::vector<double> &A)
{
    // Derivative of pressure w.r.t density as generated by sympy from the
    // utility script Bender-gas-equations.py.
    // Used to iteratively solve the EOS for density using Newtons method.
    return 6*A[13]*pow(rho, 5)
        - 2*A[20]*pow(rho, 6)*(A[17] + (A[18] + A[19]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 2)
        - 2*A[20]*pow(rho, 4)*(A[14] + (A[15] + A[16]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 2)
        + R*T + 5*pow(rho, 4)*(A[11]*T + A[12]) + 4*pow(rho, 3)*(A[10] + A[9]*T)
        + 3*pow(rho, 2)*(A[6]*T + A[7] + A[8]/T)
        + 2*rho*(A[1]*T + A[2] + (A[3] + (A[4] + A[5]/T)/T)/T)
        + 5*pow(rho, 4)*(A[17] + (A[18] + A[19]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 2)
        + 3*pow(rho, 2)*(A[14] + (A[15] + A[16]/T)/T)*exp(-A[20]*pow(rho, 2))/pow(T, 2);
}

double brg_temperature(double rho, double p, double R, const std::vector<double> &A, int &status)
{
    // Evaluate temperature from density and pressure. Must solve EOS iteratively.
    // Temperature from ideal gas EOS is a good first guess.
    double T_guess = p / (rho * R);
    int i = 0;
    double T_temp;
    status = SUCCESS;
    do { // Newtons method to solve for temperature.
        if (i >= BRG_MAX_ITERATIONS) {
            status = ITERATION_ERROR;
            cout << "brg_temperature():\n";
            cout << "    Iterations did not converge.\n";
            return T_guess;
        }
        T_temp = T_guess;
        T_guess -= (brg_pressure(rho, T_guess, R, A) - p)/brg_dpdT(rho, T_guess, R, A);
        i++;
    } while (fabs(T_temp - T_guess) > BRG_PROPS_CONVERGE_TOL);
    return T_guess;
}

double brg_density(double T, double p, double R, const std::vector<double> &A, int &status)
{
    // Evaluate density from temperature and pressure. Must solve EOS iteratively.
    // Density from ideal gas EOS is a good first guess.
    double rho_guess = p / (R * T);
    int i = 0;
    double rho_temp;
    status = SUCCESS;
    do { // Newtons method to solve for density.
        if (i >= BRG_MAX_ITERATIONS) {
            status = ITERATION_ERROR;
            cout << "brg_density():\n";
            cout << "    Iterations did not converge.\n";
            return rho_guess;
        }
        rho_temp = rho_guess;
        rho_guess -= (brg_pressure(rho_guess, T, R, A) - p)/brg_dpdrho(rho_guess, T, R, A);
        i++;
    } while (fabs(rho_temp - rho_guess) > BRG_PROPS_CONVERGE_TOL);
    return rho_guess;
}

double brg_integral_const_T_energy(double rho, double T, double R, const std::vector<double> &A)
{
    // Integral of (rho^-2)*(P - T(dP/dT)) from zero density to the
    // current density, with respect to density. Generated by sympy from the
    // utility script Bender-gas-equations.py.
    // For use in the evaluation of internal energy.
    return A[10]*pow(rho, 3)/3 + A[12]*pow(rho, 4)/4 + A[13]*pow(rho, 5)/5
        + 3*A[14]/(2*A[20]*pow(T, 2)) - 3*A[14]*exp(-A[20]*pow(rho, 2))/(2*A[20]*pow(T, 2))
        + 2*A[15]/(A[20]*pow(T, 3)) - 2*A[15]*exp(-A[20]*pow(rho, 2))/(A[20]*pow(T, 3))
        + 5*A[16]/(2*A[20]*pow(T, 4)) - 5*A[16]*exp(-A[20]*pow(rho, 2))/(2*A[20]*pow(T, 4))
        - 3*A[17]*pow(rho, 2)*exp(-A[20]*pow(rho, 2))/(2*A[20]*pow(T, 2))
        + 3*A[17]/(2*pow(A[20], 2)*pow(T, 2))
        - 3*A[17]*exp(-A[20]*pow(rho, 2))/(2*pow(A[20], 2)*pow(T, 2))
        - 2*A[18]*pow(rho, 2)*exp(-A[20]*pow(rho, 2))/(A[20]*pow(T, 3))
        + 2*A[18]/(pow(A[20], 2)*pow(T, 3))
        - 2*A[18]*exp(-A[20]*pow(rho, 2))/(pow(A[20], 2)*pow(T, 3))
        - 5*A[19]*pow(rho, 2)*exp(-A[20]*pow(rho, 2))/(2*A[20]*pow(T, 4))
        + 5*A[19]/(2*pow(A[20], 2)*pow(T, 4))
        - 5*A[19]*exp(-A[20]*pow(rho, 2))/(2*pow(A[20], 2)*pow(T, 4))
        + A[2]*rho + 2*A[3]*rho/T + 3*A[4]*rho/pow(T, 2) + 4*A[5]*rho/pow(T, 3)
        + A[7]*pow(rho, 2)/2 + A[8]*pow(rho, 2)/T;
}

double brg_integral_const_T_entropy(double rho, double T, double R, const std::vector<double> &A)
{
    // Integral of (rho^-2)*(rho*R - (dP/dT)) from zero density to the
    // current density, with respect to density. Generated by sympy from the
    // utility script Bender-gas-equations.py.
    // For use in the evaluation of entropy.
    return -A[1]*rho - A[11]*pow(rho, 4)/4 + A[14]/(A[20]*pow(T, 3))
        - A[14]*exp(-A[20]*pow(rho, 2))/(A[20]*pow(T, 3)) + 3*A[15]/(2*A[20]*pow(T, 4))
        - 3*A[15]*exp(-A[20]*pow(rho, 2))/(2*A[20]*pow(T, 4)) + 2*A[16]/(A[20]*pow(T, 5))
        - 2*A[16]*exp(-A[20]*pow(rho, 2))/(A[20]*pow(T, 5))
        - A[17]*pow(rho, 2)*exp(-A[20]*pow(rho, 2))/(A[20]*pow(T, 3))
        + A[17]/(pow(A[20], 2)*pow(T, 3)) - A[17]*exp(-A[20]*pow(rho, 2))/(pow(A[20], 2)*pow(T, 3))
        - 3*A[18]*pow(rho, 2)*exp(-A[20]*pow(rho, 2))/(2*A[20]*pow(T, 4))
        + 3*A[18]/(2*pow(A[20], 2)*pow(T, 4))
        - 3*A[18]*exp(-A[20]*pow(rho, 2))/(2*pow(A[20], 2)*pow(T, 4))
        - 2*A[19]*pow(rho, 2)*exp(-A[20]*pow(rho, 2))/(A[20]*pow(T, 5))
        + 2*A[19]/(pow(A[20], 2)*pow(T, 5))
        - 2*A[19]*exp(-A[20]*pow(rho, 2))/(pow(A[20], 2)*pow(T, 5))
        + A[3]*rho/pow(T, 2) + 2*A[4]*rho/pow(T, 3) + 3*A[5]*rho/pow(T, 4)
        - A[6]*pow(rho, 2)/2 + A[8]*pow(rho, 2)/(2*pow(T, 2)) - A[9]*pow(rho, 3)/3;
}
