#!/usr/bin/env python
# nenzfr_sensitivity.py
#
# This script calculates the sensitivity and uncertainty in 
# each nozzle exit flow property due to the various input
# parameters. The calculation follows that of:
#	Mee, D. (1993) 'Uncertainty Analsysi of conditions 
#       in the test section of the T4 Shock Tunnel', UQ 
#       Mechanical Engineering Departmental Report No. 4/1993
# and is based on a set of perturbed nenzfr calculations 
# generated by "nenzfr_perturbed.py"
# 
# Luke Doherty
# School of Mechancial and Mining Engineering
# The University of Queensland

VERSION_STRING = "24-May-2012"

import shlex, string
import sys, os
import optparse
import numpy as np #import array
np.seterr(divide='ignore',invalid='ignore')
from nenzfr_utils import run_command, quote, read_case_summary, \
     read_nenzfr_outfile, read_estcj_outfile
from nenzfr_input_utils import input_checker, nenzfr_perturbed_input_checker, nenzfr_sensitivity_input_checker
E3BIN = os.path.expandvars("$HOME/e3bin")
sys.path.append(E3BIN)

#---------------------------------------------------------------
def perturb_CoreRadiusFraction(var, perturbedVariables,\
                               DictOfCases, levels):
    """
    Perturbation of the CoreRadiusFraction may be completed
    as a post-processing step using the nominal condition
    flow solution. We don't need to compute separate solutions.

    This function copies the nominal condition solution to a 
    new case file and then runs nenzfr with the --just-stats
    option and the perturbed CoreRadiusFraction value. 
    """
    
    for kk in range(levels):
        if kk != 0:
            caseString = 'case'+"{0:02}".format(\
                 perturbedVariables.index(var))+\
                 "{0:01}".format(kk)
            # Only if required to we proceed with copying the
            # nominal case data and calling 'nenzfr.py'
            if not os.path.exists(caseString):
                print "Perturbing "+var
                #command_text = 'rm -r '+caseString
                #run_command(command_text)
                
                # Copy nominal case data into a new case
                # directory
                command_text = 'cp -r case000 '+caseString
                run_command(command_text)
                # Change into new directory and call nenzfr --just-stats
                os.chdir(caseString)
                command_text = 'nenzfr.py --just-stats --CoreRadiusFraction='+\
                  str(DictOfCases[caseString][perturbedVariables.index(var)])
                run_command(command_text)
                os.chdir('../')

def get_values(dict, propertyList):
    """
    Adapted from Peter Jacob's function "get_fractions" which
    may be found within "cea2_gas.py".
    """
    valueList = []
    #print propertyList
    for s in propertyList:
        #print s
        if s in dict.keys():
            #print s
            #print dict[s]
            valueList.append(dict[s])
        else:
            valueList.append(0.0)
            print "WARNING: "+s+"was not found in the current case dictionary."
    return valueList

def add_extra_variables(data, var):
    """
    We add some additional variables that of are interest to 
    the input dictionary and list.

    data: dictionary of data
    var: list of variables
    """
    U_squared = data['vel.x']*data['vel.x'] + data['vel.y']*data['vel.y']
    U = U_squared**0.5
    # Dynamic Pressure
    data['q'] = 0.5 * data['rho'] * U_squared
    var.append('q')
    # Mass flow rate per unit area
    data['m_dot'] = data['rho'] * U
    var.append('m_dot')
    # Unit Reynolds number
    data['Re_u'] = data['m_dot'] / data['mu']
    var.append('Re_u')
    # Pressure coefficient
    data['p/q'] = data['p'] / data['q']
    var.append('p/q')
    
    return data, var


def write_sensitivity_summary(sensitivity, perturbedVariables, exitVar, type):
    """
    Write out a file summarising the sensitivity of each exit flow 
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>13}', 'T1':'{0:{fill}>13}',
                       'Vs':'{0:{fill}>13}', 'pe':'{0:{fill}>13}', 
                       'Tw':'{0:{fill}>13}', 'BLTrans':'{0:{fill}>13}',
                       'TurbVisRatio':'{0:{fill}>14}', 
                       'TurbInten':'{0:{fill}>13}',
                       'CoreRadiusFraction':'{0:{fill}>20}'}     
    formatDict = {'p1':'{0:13.5g}', 'T1':'{0:>13.5g}', 
                  'Vs':'{0:>13.5g}', 'pe':'{0:>13.5g}', 
                  'Tw':'{0:>13.5g}', 'BLTrans':'{0:>13.5g}',
                  'TurbVisRatio':'{0:>14.5g}', 
                  'TurbInten':'{0:>13.5g}',
                  'CoreRadiusFraction':'{0:>20.5g}'}
    if type in ['relative']:
        fout = open('sensitivities.dat','w')
    elif type in ['absolute']:
        fout = open('sensitivities_abs.dat','w')
    
    # Write header information
    fout.write('{0:}\n'.format(type+' sensitivities'))
    fout.write('{0:>13}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->13}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data
    for k in exitVar:
        fout.write('{0:>13}'.format(k))
        for kk in perturbedVariables:
            X_kk = sensitivity[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
        fout.write('\n')
    
    fout.close()


def write_uncertainty_summary(uncertainty, perturbedVariables, \
                              exitVar, inputUncertainties):
    """
    Write out a file summarising the sensitivity of each exit flow
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>10}', 'T1':'{0:{fill}>10}',
                       'Vs':'{0:{fill}>10}', 'pe':'{0:{fill}>10}',
                       'Tw':'{0:{fill}>10}', 'BLTrans':'{0:{fill}>10}',
                       'TurbVisRatio':'{0:{fill}>14}',
                       'TurbInten':'{0:{fill}>11}',
                       'CoreRadiusFraction':'{0:{fill}>20}'}
    formatDict = {'p1':'{0:10.2%}', 'T1':'{0:>10.2%}', 
                  'Vs':'{0:>10.2%}', 'pe':'{0:>10.2%}',
                  'Tw':'{0:>10.2%}', 'BLTrans':'{0:>10.2%}',
                  'TurbVisRatio':'{0:>14.2%}',
                  'TurbInten':'{0:>11.2%}',
                  'CoreRadiusFraction':'{0:>20.2%}'}
    
    fout = open('uncertainties.dat','w')

    # Write header information
    fout.write('{0:>19}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('{0:>10}'.format('total'))
    fout.write('\n')
    # Write out the uncertainty for each perturbed variable
    fout.write('{0:>19}'.format('(input uncertainty)'))
    for k in perturbedVariables:
        fout.write(formatDict[k].format(inputUncertainties[k]))
    fout.write('{0:>10}'.format(''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->29}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data. We also calculate and write out the 
    # total uncertainty in each exit flow variable due to the contributions
    # from all input values.
    for k in exitVar:
        fout.write('{0:>19}'.format(k))
        X_total = 0.0
        for kk in perturbedVariables:
            X_kk = uncertainty[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
            X_total += X_kk**2
        fout.write('{0:10.2%}'.format(X_total**0.5))
        fout.write('\n')

    fout.close()

def main(cfg={}):
    """
    Examine the command-line options and then calculate the sensitivties
    and uncertainties of each nozzle exit flow property based on a set of 
    Nenzfr results generated by "nenzfr_perturbed.py".
    """
    op = optparse.OptionParser(version=VERSION_STRING)
    op.add_option('-c', '--config_file', dest='config_file',
                  help=("filename for the config file"))
    opt, args = op.parse_args()
    config_file = opt.config_file
       
    if not cfg: #if the configuration dictionary has not been filled up already, load it from a file
        try: #from Rowan's onedval program
            execfile(config_file, globals(), cfg)
        except IOError as e:
	    print "Error {0}".format(str(e)) 
            print "There was a problem reading the config file: '{0}'".format(config_file)
            print "Check that it conforms to Python syntax."
            print "Bailing out!"
            sys.exit(1)
            
    #check inputs using original nenzfr input checker first
 
    cfg['bad_input'] = False
   
    cfg = input_checker(cfg)
    
    # add default pertubations and check new nenzfr perturbed inputs
    
    # Set the default relative perturbation values (as percentages)
    cfg['defaultPerturbations'] = {'p1':2.5, 'T1':2.5, 'Vs':2.5, 'pe':2.5, 
                           'Tw':2.5, 'BLTrans':2.5, 'TurbVisRatio':2.5,
                           'TurbInten':2.5, 'CoreRadiusFraction':2.5}
    
    cfg = nenzfr_perturbed_input_checker(cfg)
    
    #Relative uncertainties below based on uncertainties in Rainer's thesis.
    
    cfg['default_rel_uncertainties'] = {'p1':0.0325, 'T1':0.02, 'Vs':0.05, 'pe':0.025, 
                           'Tw':0.04, 'BLTrans':1.00, 'TurbVisRatio':1.00,
                           'TurbInten':0.8, 'CoreRadiusFraction':0.05}    
    
    cfg = nenzfr_sensitivity_input_checker(cfg)
   
    #bail out here if there is an issue
    if cfg['bad_input']:
        return -2
 
    # Read the sensitivity_case_summary file to get the perturbed
    # variables and their various values
    perturbedVariables, DictOfCases = read_case_summary()
    
    # Pull the variable of the uncertainties for each perturbed variable from
    # the config dictionary.
    inputUncertainties = cfg['inputUncertainties']
    
    # Define the name of the nominal case and load the exit plane data
    nominal = 'case000'
    nominalData, exitVar = read_nenzfr_outfile('./'+nominal+'/'+\
                                               cfg['jobName']+'-exit.stats')
    # Load the nozzle supply data
    nominalSupply = read_estcj_outfile('./'+nominal+'/'+cfg['jobName']+'-estcj.dat')
    # Now add the relevant supply data (T, h) to the nominalData dictionary
    nominalData['supply_rho'] = nominalSupply['rho']
    nominalData['supply_T'] = nominalSupply['T']
    nominalData['supply_h'] = nominalSupply['h']
    # Add the supply variables to the exitVar list
    exitVar.insert(0,'supply_rho')
    exitVar.insert(1,'supply_T')
    exitVar.insert(2,'supply_h')
    # Add extra variables of interest (q, Re_u, m_dot)
    nominalData, exitVar = add_extra_variables(nominalData, exitVar)
     
    nominalValues = get_values(nominalData, exitVar)
    #print nominalValues
     
    # Loop through each of the perturbed variables
    sensitivity = {}
    sensitivity_abs = {}
    uncertainty = {}
    for k in range(len(perturbedVariables)):
        var = perturbedVariables[k]
        
        if var == 'CoreRadiusFraction':
            perturb_CoreRadiusFraction(var, perturbedVariables,\
                                       DictOfCases, cfg['levels'])
        # Define the name of the relevant perturbed cases and load the 
        # associated data
        high = 'case'+"{0:02}".format(k)+'1'
        highData, dontNeed  = read_nenzfr_outfile('./'+high+'/'+\
                                                  cfg['jobName']+'-exit.stats')
        highSupply = read_estcj_outfile('./'+high+'/'+cfg['jobName']+'-estcj.dat')
        highData['supply_rho'] = highSupply['rho']
        highData['supply_T'] = highSupply['T']
        highData['supply_h'] = highSupply['h']
        highData, dontNeed = add_extra_variables(highData, [])
        
        low = 'case'+"{0:02}".format(k)+'2'
        lowData, dontNeed = read_nenzfr_outfile('./'+low+'/'+\
                                                cfg['jobName']+'-exit.stats')
        lowSupply = read_estcj_outfile('./'+low+'/'+cfg['jobName']+'-estcj.dat')
        lowData['supply_rho'] = lowSupply['rho']
        lowData['supply_T'] = lowSupply['T']
        lowData['supply_h'] = lowSupply['h']
        lowData, dontNeed = add_extra_variables(lowData, [])
        
        #print low, nominal, high
        
        # Values of the freestream properties at the perturbed conditions
        highValues = get_values(highData,exitVar)
        lowValues = get_values(lowData,exitVar)
        # Values of the perturbed input values
        highX = DictOfCases[high][perturbedVariables.index(var)]
        lowX = DictOfCases[low][perturbedVariables.index(var)]
        nominalX = DictOfCases[nominal][perturbedVariables.index(var)]
   
        if cfg['levels'] == 3: 
            # As the perturbations may not be centered on the nominal
            # condition we caculate the gradient by taking a weighted
            # average of the forward and backward derivatives. The 
            # weightings are such that the truncation error associated 
            # with this gradient estimate is O(3) or higher (i.e. the 
            # weightings are such that the second order terms in the Taylor 
            # series expansion cancel. Thanks to D.Petty for this theory.)
            highWeighting = (nominalX - lowX)/(highX - lowX)
            lowWeighting = (highX - nominalX)/(highX - lowX)
            
            #sensitivity[var] = ( highWeighting*(np.array(highValues)-\
            #                                    np.array(nominalValues))/\
            #                                   (highX - nominalX) + \
            #                     lowWeighting*(np.array(nominalValues)-\
            #                                   np.array(lowValues))/\
            #                                  (nominalX - lowX)     )*\
            #                    nominalX/np.array(nominalValues)
            sensitivity_abs[var] = ( highWeighting*(np.array(highValues)-\
                                                np.array(nominalValues))/\
                                               (highX - nominalX) + \
                                 lowWeighting*(np.array(nominalValues)-\
                                               np.array(lowValues))/\
                                              (nominalX - lowX)     )
            
            sensitivity[var] = sensitivity_abs[var]*nominalX/np.array(nominalValues)
            #print sensitivity[var]
        elif cfg['levels'] == 5:
            # For 5 levels per variable we have additional cases 
            # that need to be loaded. Again we do not assume that
            # the levels are equally spaced around the nominal. 
            # The weightings are such that the truncation error 
            # associated with this estimate is O(4) or higher.
            tooHigh = 'case'+"{0:02}".format(k)+'3'
            tooHighData,dontNeed = \
                  read_nenzfr_outfile('./'+tooHigh+'/'+cfg['jobName']+'-exit.stats')
            tooHighSupply = read_estcj_outfile('./'+tooHigh+'/'+cfg['jobName']+'-estcj.dat')
            tooHighData['supply_rho'] = tooHighSupply['rho']
            tooHighData['supply_T'] = tooHighSupply['T']
            tooHighData['supply_h'] = tooHighSupply['h']
            tooHighData, dontNeed = add_extra_variables(tooHighData, [])
            
            tooLow = 'case'+"{0:02}".format(k)+'4'
            tooLowData,dontNeed = \
                  read_nenzfr_outfile('./'+tooLow+'/'+cfg['jobName']+'-exit.stats')
            tooLowSupply = read_estcj_outfile('./'+tooLow+'/'+cfg['jobName']+'-estcj.dat')
            tooLowData['supply_rho'] = tooLowSupply['rho']
            tooLowData['supply_T'] = tooLowSupply['T']
            tooLowData['supply_h'] = tooLowSupply['h']
            tooLowData, dontNeed = add_extra_variables(tooLowData, [])
            
            #print tooHigh, high, nominal, low, tooLow
            
            # Values of the freestream properties at the perturbed conditions
            tooHighValues = get_values(tooHighData,exitVar)
            tooLowValues = get_values(tooLowData,exitVar)
            # Values of the perturbed input values
            tooHighX = DictOfCases[tooHigh][perturbedVariables.index(var)]
            tooLowX = DictOfCases[tooLow][perturbedVariables.index(var)]
            
            tooHighDeltaX = tooHighX - nominalX
            highDeltaX = highX - nominalX
            tooLowDeltaX = tooLowX - nominalX
            lowDeltaX = lowX - nominalX
            weighting = (tooHighX - tooLowX)/(highX - lowX)
            
            denom = 1/tooHighDeltaX - 1/tooLowDeltaX -\
                   (1/highDeltaX - 1/lowDeltaX)*weighting
            numer =  np.array(tooHighValues)/tooHighDeltaX**2 -\
                     np.array(tooLowValues)/tooLowDeltaX**2 -\
                    ( np.array(highValues)/highDeltaX**2 -\
                      np.array(lowValues)/lowDeltaX**2 )*weighting -\
                     np.array(nominalValues)*\
                       ( 1/tooHighDeltaX**2 - 1/tooLowDeltaX**2 - \
                         ( 1/highDeltaX**2 - 1/lowDeltaX**2 )*weighting )
            
            sensitivity_abs[var] = numer/denom
            sensitivity[var] = sensitivity_abs[var]*nominalX/np.array(nominalValues)

        # Now calculate the uncertainty in each exit flow variable
        # due to the uncertainty in the current (perturbed)
        # input variable
        uncertainty[var] = sensitivity[var]*inputUncertainties[var]
   
    # Write out a file of the sensitivities
    write_sensitivity_summary(sensitivity, perturbedVariables, exitVar, 'relative')
    write_sensitivity_summary(sensitivity_abs, perturbedVariables, exitVar, 'absolute')
    
    # Write out a file of the uncertainties
    write_uncertainty_summary(uncertainty, perturbedVariables, exitVar,\
                              inputUncertainties)
    
    return 0

#---------------------------------------------------------------

if __name__ == '__main__':
    if len(sys.argv) <= 1:
        print "NENZFr Sensitivity:\n Calculate Sensitivity of Shock Tunnel Test Flow Conditions for a varying inputs"
        print "   Version:", VERSION_STRING
        print "   To get some useful hints, invoke the program with option --help."
        sys.exit(0)
    return_flag = main()
    sys.exit(return_flag)
