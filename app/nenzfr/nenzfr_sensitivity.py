#!/usr/bin/env python
# nenzfr_sensitivity.py
#
# This script calculates the sensitivity and uncertainty in 
# each nozzle exit flow property due to the various input
# parameters. The calculation follows that of:
#	Mee, D. (1993) 'Uncertainty Analsysi of conditions 
#       in the test section of the T4 Shock Tunnel', UQ 
#       Mechanical Engineering Departmental Report No. 4/1993
# and is based on a set of perturbed nenzfr calculations 
# generated by "nenzfr_perturbed.py"
# 
# Luke Doherty
# School of Mechancial and Mining Engineering
# The University of Queensland

VERSION_STRING = "24-May-2012"

import shlex, string
import sys, os
import optparse
from numpy import array
from nenzfr_utils import run_command, quote, read_case_summary, \
     read_nenzfr_outfile, read_estcj_outfile
E3BIN = os.path.expandvars("$HOME/e3bin")
sys.path.append(E3BIN)

#---------------------------------------------------------------
def perturb_CoreRadiusFraction(var, perturbedVariables,\
                               DictOfCases, levels):
    """
    Perturbation of the CoreRadiusFraction may be completed
    as a post-processing step using the nominal condition
    flow solution. We don't need to compute separate solutions.

    This function copies the nominal condition solution to a 
    new case file and then runs nenzfr with the --just-stats
    option and the perturbed CoreRadiusFraction value. 
    """
    
    for kk in range(levels):
        if kk != 0:
            caseString = 'case'+"{0:02}".format(\
                 perturbedVariables.index(var))+\
                 "{0:01}".format(kk)
            # Only if required to we proceed with copying the
            # nominal case data and calling 'nenzfr.py'
            if not os.path.exists(caseString):
                print "Perturbing "+var
                #command_text = 'rm -r '+caseString
                #run_command(command_text)
                
                # Copy nominal case data into a new case
                # directory
                command_text = 'cp -r case000 '+caseString
                run_command(command_text)
                # Change into new directory and call nenzfr --just-stats
                os.chdir(caseString)
                command_text = 'nenzfr.py --just-stats --CoreRadiusFraction='+\
                  str(DictOfCases[caseString][perturbedVariables.index(var)])
                run_command(command_text)
                os.chdir('../')

def get_values(dict, propertyList):
    """
    Adapted from Peter Jacob's function "get_fractions" which
    may be found within "cea2_gas.py".
    """
    valueList = []
    #print propertyList
    for s in propertyList:
        #print s
        if s in dict.keys():
            #print s
            #print dict[s]
            valueList.append(dict[s])
        else:
            valueList.append(0.0)
            print "WARNING: "+s+"was not found in the current case dictionary."
    return valueList

def write_sensitivity_summary(sensitivity, perturbedVariables, exitVar, type):
    """
    Write out a file summarising the sensitivity of each exit flow 
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>13}', 'T1':'{0:{fill}>13}',
                       'Vs':'{0:{fill}>13}', 'pe':'{0:{fill}>13}', 
                       'Tw':'{0:{fill}>13}', 'BLTrans':'{0:{fill}>13}',
                       'TurbVisRatio':'{0:{fill}>14}', 
                       'TurbInten':'{0:{fill}>13}',
                       'CoreRadiusFraction':'{0:{fill}>20}'}     
    formatDict = {'p1':'{0:13.5g}', 'T1':'{0:>13.5g}', 
                  'Vs':'{0:>13.5g}', 'pe':'{0:>13.5g}', 
                  'Tw':'{0:>13.5g}', 'BLTrans':'{0:>13.5g}',
                  'TurbVisRatio':'{0:>14.5g}', 
                  'TurbInten':'{0:>13.5g}',
                  'CoreRadiusFraction':'{0:>20.5g}'}
    if type in ['relative']:
        fout = open('sensitivities.dat','w')
    elif type in ['absolute']:
        fout = open('sensitivities_abs.dat','w')
    
    # Write header information
    fout.write('{0:}\n'.format(type+' sensitivities'))
    fout.write('{0:>13}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->13}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data
    for k in exitVar:
        fout.write('{0:>13}'.format(k))
        for kk in perturbedVariables:
            X_kk = sensitivity[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
        fout.write('\n')
    
    fout.close()


def write_uncertainty_summary(uncertainty, perturbedVariables, \
                              exitVar, inputUncertainties):
    """
    Write out a file summarising the sensitivity of each exit flow
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>10}', 'T1':'{0:{fill}>10}',
                       'Vs':'{0:{fill}>10}', 'pe':'{0:{fill}>10}',
                       'Tw':'{0:{fill}>10}', 'BLTrans':'{0:{fill}>10}',
                       'TurbVisRatio':'{0:{fill}>14}',
                       'TurbInten':'{0:{fill}>11}',
                       'CoreRadiusFraction':'{0:{fill}>20}'}
    formatDict = {'p1':'{0:10.2%}', 'T1':'{0:>10.2%}', 
                  'Vs':'{0:>10.2%}', 'pe':'{0:>10.2%}',
                  'Tw':'{0:>10.2%}', 'BLTrans':'{0:>10.2%}',
                  'TurbVisRatio':'{0:>14.2%}',
                  'TurbInten':'{0:>11.2%}',
                  'CoreRadiusFraction':'{0:>20.2%}'}
    
    fout = open('uncertainties.dat','w')

    # Write header information
    fout.write('{0:>19}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('{0:>10}'.format('total'))
    fout.write('\n')
    # Write out the uncertainty for each perturbed variable
    fout.write('{0:>19}'.format('(input uncertainty)'))
    for k in perturbedVariables:
        fout.write(formatDict[k].format(inputUncertainties[k]))
    fout.write('{0:>10}'.format(''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->29}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data. We also calculate and write out the 
    # total uncertainty in each exit flow variable due to the contributions
    # from all input values.
    for k in exitVar:
        fout.write('{0:>19}'.format(k))
        X_total = 0.0
        for kk in perturbedVariables:
            X_kk = uncertainty[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
            X_total += X_kk**2
        fout.write('{0:10.2%}'.format(X_total**0.5))
        fout.write('\n')

    fout.close()



def main():
    """
    Examine the command-line options and then calculate the sensitivties
    and uncertainties of each nozzle exit flow property based on a set of 
    Nenzfr results generated by "nenzfr_perturbed.py".
    """
    op = optparse.OptionParser(version=VERSION_STRING)

    op.add_option('--run-defaults', dest='runDefaults', action='store_true',
                  default=True, help="calculate sensitivities and "
                  "uncertainties using all the default values.")
    
    op.add_option('--exitStatsFile', dest='exitStatsFileName',
                  default='nozzle-exit.stats',
                  help="file that holds the averaged nozzle-exit "
                       "data and is to be read in for each perturbation "
                       "case [default: %default]")
    op.add_option('--estcjFile', dest='estcjFile', default='nozzle-estcj.dat',
                  help="file that holds the estcj result and is to be read in "
                       "for each perturbation case. [default: %default]")
     
    op.add_option('--levels', dest='levels', default=3,choices=[3,5],
                  help=("specify how many points are to be used in the "
                        "calculation of the gradient. Includes the nominal.  "
                        "Options: 3, 5 [default: %default]"))
    
    # The default values for the following inputs are based on those given in 
    # Rainer Kirchhartz' PhD Thesis (Appendix B)
    op.add_option('--Xp1', dest='p1', default=0.0325,
                  help=("relative uncertainty in shock tube fill pressure. "
                        "[default: %default]" ))
    op.add_option('--XT1', dest='T1', default=0.02,
                  help=("relative uncertainty in shock tube fill temperature. "
                        "[default: %default]"))
    op.add_option('--XVs', dest='Vs', default=0.05,
                  help=("relative uncertainty in the incident shock speed. "
                        "[default: %default]"))
    op.add_option('--Xpe', dest='pe', default=0.025,
                  help=("relative uncertainty in the equilibrium pressure "
                        "(after shock reflection). [default: %default]"))
    # The default values for the following inputs are guestimates :)
    op.add_option('--XTwall', dest='Tw', default=0.04,
                  help=("relative uncertainty in nozzle wall temperature. "
                        "[default: %default]"))
    op.add_option('--XBLTrans', dest='BLTrans', default=1.00,
                  help=("relative uncertainty in the boundary layer "
                        "transition location. [default: %default]"))
    op.add_option('--XTurbVisRatio', dest='TurbVisRatio', default=1.00,
                  help=("relative uncertainty in turbulent-to-laminar "
                        "viscosity ratio at the throat. "
                        "[default: %default]"))
    op.add_option('--XTurbIntensity', dest='TurbInten', default=0.8,
                  help=("relative uncertainty in turbulence intensity "
                        "at the throat. [default: %default]"))
    op.add_option('--XCoreRadiusFraction', dest="coreRfraction", default=0.05,
                  help=("relative uncertainty in the core flow radius "
                        "fraction. [default: %default]")) 
    opt, args = op.parse_args()
 
    # Convert to integer
    opt.levels = int(opt.levels)

    # Read the sensitivity_case_summary file to get the perturbed
    # variables and their various values
    perturbedVariables, DictOfCases = read_case_summary()
    
    # Create a dictionary of the relative uncertainties of each 
    # variable that may have been perturbed
    inputUncertainties = {'p1':opt.p1, 'T1':opt.T1, 'Vs':opt.Vs, 'pe':opt.pe,
                          'Tw':opt.Tw, 'TurbVisRatio':opt.TurbVisRatio,
                          'TurbInten':opt.TurbInten, 'BLTrans':opt.BLTrans,
                          'CoreRadiusFraction':opt.coreRfraction}
    
    # Define the name of the nominal case and load the exit plane data
    nominal = 'case000'
    nominalData, exitVar = read_nenzfr_outfile('./'+nominal+'/'+\
                                               opt.exitStatsFileName)
    # Load the nozzle supply data
    nominalSupply = read_estcj_outfile('./'+nominal+'/'+opt.estcjFile)
    # Now add the relevant supply data (T, h) to the nominalData dictionary
    nominalData['supply_T'] = nominalSupply['T']
    nominalData['supply_h'] = nominalSupply['h']
    # Add the supply variables to the exitVar list
    exitVar.insert(0,'supply_T')
    exitVar.insert(1,'supply_h')
    
    nominalValues = get_values(nominalData, exitVar)
    
    # Loop through each of the perturbed variables
    sensitivity = {}
    sensitivity_abs = {}
    uncertainty = {}
    for k in range(len(perturbedVariables)):
        var = perturbedVariables[k]
        
        if var == 'CoreRadiusFraction':
            perturb_CoreRadiusFraction(var, perturbedVariables,\
                                       DictOfCases, opt.levels)
        # Define the name of the relevant perturbed cases and load the 
        # associated data
        high = 'case'+"{0:02}".format(k)+'1'
        highData, dontNeed  = read_nenzfr_outfile('./'+high+'/'+\
                                                  opt.exitStatsFileName)
        highSupply = read_estcj_outfile('./'+high+'/'+opt.estcjFile)
        highData['supply_T'] = highSupply['T']
        highData['supply_h'] = highSupply['h']
        
        low = 'case'+"{0:02}".format(k)+'2'
        lowData, dontNeed = read_nenzfr_outfile('./'+low+'/'+\
                                                opt.exitStatsFileName)
        lowSupply = read_estcj_outfile('./'+low+'/'+opt.estcjFile)
        lowData['supply_T'] = lowSupply['T']
        lowData['supply_h'] = lowSupply['h']
        
        #print low, nominal, high
        
        # Values of the freestream properties at the perturbed conditions
        highValues = get_values(highData,exitVar)
        lowValues = get_values(lowData,exitVar)
        # Values of the perturbed input values
        highX = DictOfCases[high][perturbedVariables.index(var)]
        lowX = DictOfCases[low][perturbedVariables.index(var)]
        nominalX = DictOfCases[nominal][perturbedVariables.index(var)]
   
        if opt.levels == 3: 
            # As the perturbations may not be centered on the nominal
            # condition we caculate the gradient by taking a weighted
            # average of the forward and backward derivatives. The 
            # weightings are such that the truncation error associated 
            # with this gradient estimate is O(3) or higher (i.e. the 
            # weightings are such that the second order terms in the Taylor 
            # series expansion cancel. Thanks to D.Petty for this theory.)
            highWeighting = (nominalX - lowX)/(highX - lowX)
            lowWeighting = (highX - nominalX)/(highX - lowX)
            
            #sensitivity[var] = ( highWeighting*(array(highValues)-\
            #                                    array(nominalValues))/\
            #                                   (highX - nominalX) + \
            #                     lowWeighting*(array(nominalValues)-\
            #                                   array(lowValues))/\
            #                                  (nominalX - lowX)     )*\
            #                    nominalX/array(nominalValues)
            sensitivity_abs[var] = ( highWeighting*(array(highValues)-\
                                                array(nominalValues))/\
                                               (highX - nominalX) + \
                                 lowWeighting*(array(nominalValues)-\
                                               array(lowValues))/\
                                              (nominalX - lowX)     )
            sensitivity[var] = sensitivity_abs[var]*nominalX/array(nominalValues)
            #print sensitivity[var]
        else:
            # For 5 levels per variable we have additional cases 
            # that need to be loaded. Again we do not assume that
            # the levels are equally spaced around the nominal. 
            # The weightings are such that the truncation error 
            # associated with this estimate is O(4) or higher.
            tooHigh = 'case'+"{0:02}".format(k)+'3'
            tooHighData,dontNeed = \
                  read_nenzfr_outfile('./'+tooHigh+'/'+opt.exitStatsFileName)
            tooHighSupply = read_estcj_outfile('./'+tooHigh+'/'+opt.estcjFile)
            tooHighData['supply_T'] = tooHighSupply['T']
            tooHighData['supply_h'] = tooHighSupply['h']
            
            tooLow = 'case'+"{0:02}".format(k)+'4'
            tooLowData,dontNeed = \
                  read_nenzfr_outfile('./'+tooLow+'/'+opt.exitStatsFileName)
            tooLowSupply = read_estcj_outfile('./'+tooLow+'/'+opt.estcjFile)
            tooLowData['supply_T'] = tooLowSupply['T']
            tooLowData['supply_h'] = tooLowSupply['h']
            
            #print tooHigh, high, nominal, low, tooLow
            
            # Values of the freestream properties at the perturbed conditions
            tooHighValues = get_values(tooHighData,exitVar)
            tooLowValues = get_values(tooLowData,exitVar)
            # Values of the perturbed input values
            tooHighX = DictOfCases[tooHigh][perturbedVariables.index(var)]
            tooLowX = DictOfCases[tooLow][perturbedVariables.index(var)]
            
            
            tooHighDeltaX = tooHighX - nominalX
            highDeltaX = highX - nominalX
            tooLowDeltaX = tooLowX - nominalX
            lowDeltaX = lowX - nominalX
            weighting = (tooHighX - tooLowX)/(highX - lowX)
            
            denom = 1/tooHighDeltaX - 1/tooLowDeltaX -\
                   (1/highDeltaX - 1/lowDeltaX)*weighting
            numer =  array(tooHighValues)/tooHighDeltaX**2 -\
                     array(tooLowValues)/tooLowDeltaX**2 -\
                    ( array(highValues)/highDeltaX**2 -\
                      array(lowValues)/lowDeltaX**2 )*weighting -\
                     array(nominalValues)*\
                       ( 1/tooHighDeltaX**2 - 1/tooLowDeltaX**2 - \
                         ( 1/highDeltaX**2 - 1/lowDeltaX**2 )*weighting )
            sensitivity[var] = numer/denom*nominalX/array(nominalValues) 
            sensitivity_abs[var] = numer/denom
        # Now calculate the uncertainty in each exit flow variable
        # due to the uncertainty in the current (perturbed)
        # input variable
        uncertainty[var] = sensitivity[var]*inputUncertainties[var]
   
    # Write out a file of the sensitivities
    write_sensitivity_summary(sensitivity, perturbedVariables, exitVar, 'relative')
    write_sensitivity_summary(sensitivity_abs, perturbedVariables, exitVar, 'absolute')
    
    # Write out a file of the uncertainties
    write_uncertainty_summary(uncertainty, perturbedVariables, exitVar,\
                              inputUncertainties)
    
    return 0

#---------------------------------------------------------------

if __name__ == '__main__':
    if len(sys.argv) <= 1:
        print "NENZFr Sensitivity:\n Calculate Sensitivity of Shock Tunnel Test Flow Conditions for a varying inputs"
        print "   Version:", VERSION_STRING
        print "   To get some useful hints, invoke the program with option --help."
        sys.exit(0)
    return_flag = main()
    sys.exit(return_flag)
