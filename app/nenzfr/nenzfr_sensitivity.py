#!/usr/bin/env python
# nenzfr_sensitivity.py
#
# This script calculates the sensitivity and uncertainty in 
# each nozzle exit flow property due to the various input
# parameters. The calculation follows that of:
#	Mee, D. (1993) 'Uncertainty Analsysi of conditions 
#       in the test section of the T4 Shock Tunnel', UQ 
#       Mechanical Engineering Departmental Report No. 4/1993
# and is based on a set of perturbed nenzfr calculations 
# generated by "nenzfr_perturbed.py"
# 
# Luke Doherty
# School of Mechancial and Mining Engineering
# The University of Queensland

VERSION_STRING = "23-April-2012"

import shlex, subprocess, string
from subprocess import PIPE
import sys, os, gzip
import optparse
#import numpy
from numpy import array, mean, logical_and, zeros
import copy
E3BIN = os.path.expandvars("$HOME/e3bin")
sys.path.append(E3BIN)

#---------------------------------------------------------------
    
def run_command(cmdText):
    """
    Run the command as a subprocess.
    """
    print "About to run cmd:", cmdText
    args = shlex.split(cmdText)
    p = subprocess.Popen(args)
    # wait until the subprocess is finished
    stdoutData, stderrData = p.communicate() 
    return

def quote(str):
    """
    Put quotes around a string.
    """
    return '"' + str + '"'

def read_case_summary():
    """
    Reads the file "sensitivity_cases.dat" to determine which variables
    have been perturbed and values for the perturbed variables for each
    case consituting the sensitivity calculation.
    
    :returns: perturbedVariables - a list of variable names
            : DictOfCases - a dictionary with the case names as keys 
                            and the values of each perturbed variable.
    """
    fp = open('perturbation_cases.dat','r')
    
    varList = fp.readline().strip().split(" ")
    perturbedVariables = [k for k in varList if k!="#" and k!=""]
    fp.readline()
    DictOfCases = {}
    for line in fp.readlines():
        caseData = line.strip().split(" ")
        caseName = caseData[0]
        DictOfCases[caseName] = [float(k) for k in caseData \
                                 if k!=caseName and k!=""]
    fp.close()
    return perturbedVariables, DictOfCases

def perturb_CoreRadiusFraction(var, perturbedVariables,\
                               DictOfCases, gradient):
    """
    Perturbation of the CoreRadiusFraction may be completed
    as a post-processing step using the nominal condition
    flow solution. We don't need to compute separate solutions.

    This function copies the nominal condition solution to a 
    new case file and then runs nenzfr with the --just-stats
    option and the perturbed CoreRadiusFraction value. 
    """
    if gradient == "linear":
        perturbCount = 3
    else:
        perturbCount = 5
    
    for kk in range(perturbCount):
        if kk != 0:
            caseString = 'case'+"{0:02}".format(\
                 perturbedVariables.index(var))+\
                 "{0:01}".format(kk)
            # Only if required to we proceed with copying the
            # nominal case data and calling 'nenzfr.py'
            if not os.path.exists(caseString):
                print "Perturbing "+var
                #command_text = 'rm -r '+caseString
                #run_command(command_text)
                
                # Copy nominal case data into a new case
                # directory
                command_text = 'cp -r case000 '+caseString
                run_command(command_text)
                # Change into new directory and call nenzfr --just-stats
                os.chdir(caseString)
                command_text = 'nenzfr.py --just-stats --CoreRadiusFraction='+\
                  str(DictOfCases[caseString][perturbedVariables.index(var)])
                run_command(command_text)
                os.chdir('../')

def read_nenzfr_outfile(FileToRead):
    """
    Reads the nenzfr out-file containing the statistics of the 
    exit flow properties.
    
    :FileToRead: the name of the file to be read. Default should be 
                 something like "nozzle-exit.stats"
    :returns: a list of all the exit flow properties and a dictionary
              of the mean-values.
    """
    fp = open(FileToRead,'r')
    # Collumn titles
    titles = fp.readline().strip().split(" ")
    titleList = [k for k in titles if k!="" and k!="variable"]
    
    fp.readline() # This is a row of "-"
    exitDataDict = {}
    fileLines = fp.readlines()
    del fileLines[-1] # Get rid of the last line which is just a row of "-"
    exitProperty = []
    # Now read in the rest of the data
    for line in fileLines:
        data = line.strip().split(" ")
        values = [k for k in data if k!=""]
        variable = values[0]
        exitProperty.append(variable)
        exitDataDict[variable] = float(values[1])
    fp.close()
    return exitDataDict, exitProperty

def read_estcj_outfile(FileToRead):
    """
    Read just the line in the estcj output file that contains 
    the nozzle supply temperature and enthalpy.
    """
    supplyDict = {}
    lineToRead = 0
    
    fp = open(FileToRead,'r')
    for line in fp.readlines():
        # We only want to read one line in the file
        if lineToRead == 1: 
            for data in line.split(','):
                # Data is a list of strings with one string for 
                # each property. The form of the strings is 
                # 'property: value unit'. We split the list and 
                # create "values" which is a list of lists of the 
                # form
                #     values = [[property],[value, unit]]
                # We then put this into a dictionary.
                values = [x.split() for x in data.split(':')]
                supplyDict[values[0][0]] = float(values[1][0])
            lineToRead = 0
            
        if line.strip() in \
            ['State 5s: equilibrium condition (relaxation to pe)',]:
            # We want to read the next line
            lineToRead = 1
    fp.close()
    return supplyDict

def get_values(dict, propertyList):
    """
    Adapted from Peter Jacob's function "get_fractions" which
    may be found within "cea2_gas.py".
    """
    valueList = []
    #print propertyList
    for s in propertyList:
        #print s
        if s in dict.keys():
            #print s
            #print dict[s]
            valueList.append(dict[s])
        else:
            valueList.append(0.0)
            print "WARNING: "+s+"was not found in the current case dictionary."
    return valueList

def write_sensitivity_summary(sensitivity, perturbedVariables, exitVar):
    """
    Write out a file summarising the sensitivity of each exit flow 
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>13}', 'T1':'{0:{fill}>10}',
                       'Vs':'{0:{fill}>11}', 'pe':'{0:{fill}>15}', 
                       'Tw':'{0:{fill}>10}', 'BLTrans':'{0:{fill}>10}',
                       'TurbVisRatio':'{0:{fill}>14}', 
                       'TurbInten':'{0:{fill}>11}',
                       'CoreRadiusFraction':'{0:{fill}>20}'}     
    formatDict = {'p1':'{0:13.4f}', 'T1':'{0:>10.4f}', 
                  'Vs':'{0:>11.4f}', 'pe':'{0:>15.4f}', 
                  'Tw':'{0:>10.4f}', 'BLTrans':'{0:>10.4f}',
                  'TurbVisRatio':'{0:>14.4f}', 
                  'TurbInten':'{0:>11.4f}',
                  'CoreRadiusFraction':'{0:>20.4f}'}

    fout = open('sensitivities.dat','w')
    
    # Write header information
    fout.write('{0:>13}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->13}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data
    for k in exitVar:
        fout.write('{0:>13}'.format(k))
        for kk in perturbedVariables:
            X_kk = sensitivity[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
        fout.write('\n')
    
    fout.close()


def write_uncertainty_summary(uncertainty, perturbedVariables, \
                              exitVar, inputUncertainties):
    """
    Write out a file summarising the sensitivity of each exit flow
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>10}', 'T1':'{0:{fill}>10}',
                       'Vs':'{0:{fill}>10}', 'pe':'{0:{fill}>10}',
                       'Tw':'{0:{fill}>10}', 'BLTrans':'{0:{fill}>10}',
                       'TurbVisRatio':'{0:{fill}>14}',
                       'TurbInten':'{0:{fill}>11}',
                       'CoreRadiusFraction':'{0:{fill}>20}'}
    formatDict = {'p1':'{0:10.2%}', 'T1':'{0:>10.2%}', 
                  'Vs':'{0:>10.2%}', 'pe':'{0:>10.2%}',
                  'Tw':'{0:>10.2%}', 'BLTrans':'{0:>10.2%}',
                  'TurbVisRatio':'{0:>14.2%}',
                  'TurbInten':'{0:>11.2%}',
                  'CoreRadiusFraction':'{0:>20.2%}'}
    
    fout = open('uncertainties.dat','w')

    # Write header information
    fout.write('{0:>19}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('{0:>10}'.format('total'))
    fout.write('\n')
    # Write out the uncertainty for each perturbed variable
    fout.write('{0:>19}'.format('(input uncertainty)'))
    for k in perturbedVariables:
        fout.write(formatDict[k].format(inputUncertainties[k]))
    fout.write('{0:>10}'.format(''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->29}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data. We also calculate and write out the 
    # total uncertainty in each exit flow variable due to the contributions
    # from all input values.
    for k in exitVar:
        fout.write('{0:>19}'.format(k))
        X_total = 0.0
        for kk in perturbedVariables:
            X_kk = uncertainty[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
            X_total += X_kk**2
        fout.write('{0:10.2%}'.format(X_total**0.5))
        fout.write('\n')

    fout.close()



def main():
    """
    Examine the command-line options and then calculate the sensitivties
    and uncertainties of each nozzle exit flow property based on a set of 
    Nenzfr results generated by "nenzfr_sensitivity.py".
    """
    op = optparse.OptionParser(version=VERSION_STRING)

    op.add_option('--run-defaults', dest='runDefaults', action='store_true',
                  default=True, help="calculate sensitivities and "
                  "uncertainties using all the default values.")
    
    op.add_option('--exitStatsfile', dest='exitStatsFileName',
                  default='nozzle-exit.stats',
                  help="file that holds the averaged nozzle-exit "
                       "data and is to be read in for each perturbation "
                       "case [default: %default]")
    op.add_option('--estcjFile', dest='estcjFile', default='nozzle-estcj.dat',
                  help="file that holds the estcj result and is to be read in "
                       "for each perturbation case. [default: %default]")
     
    op.add_option('--gradient', dest='gradient', default='linear',
                  choices=['linear','quadratic'],
                  help=("specify whether the gradient is to be calculated "
                        "using a linear or quadratic equation. "
                        "Options: linear, quadratic [default: %default]"))
    
    # The default values for the following inputs are based on those given in 
    # Rainer Kirchhartz' PhD Thesis (Appendix B)
    op.add_option('--Xp1', dest='p1', default=0.0325,
                  help=("relative uncertainty in shock tube fill pressure. "
                        "[default: %default]" ))
    op.add_option('--XT1', dest='T1', default=0.02,
                  help=("relative uncertainty in shock tube fill temperature. "
                        "[default delta: %default]"))
    op.add_option('--XVs', dest='Vs', default=0.05,
                  help=("relative uncertainty in the incident shock speed. "
                        "[default delta: %default]"))
    op.add_option('--Xpe', dest='pe', default=0.025,
                  help=("equilibrium pressure (after shock reflection), "
                        "in Pa and its perturbation/s as a list. "
                        "[default: 5%]"))
    # The default values for the following inputs are guestimates :)
    op.add_option('--XTwall', dest='Tw', default=0.04,
                  help=("relative uncertainty in nozzle wall temperature. "
                        "[default: %default]"))
    op.add_option('--XBLTrans', dest='BLTrans', default=1.00,
                  help=("relative uncertainty in the boundary layer "
                        "transition location. [default: %default]"))
    op.add_option('--XTurbVisRatio', dest='TurbVisRatio', default=1.00,
                  help=("relative uncertainty in turbulent-to-laminar "
                        "viscosity ratio at the throat. "
                        "[default: %default]"))
    op.add_option('--XTurbIntensity', dest='TurbInten', default=0.8,
                  help=("relative uncertainty in turbulence intensity "
                        "at the throat. [default: %default]"))
    op.add_option('--XCoreRadiusFraction', dest="coreRfraction", default=0.05,
                  help=("relative uncertainty in the core flow radius "
                        "fraction. [default: %default]")) 
    opt, args = op.parse_args()

    # Read the sensitivity_case_summary file to get the perturbed
    # variables and their various values
    perturbedVariables, DictOfCases = read_case_summary()
    
    # Create a dictionary of the relative uncertainties of each 
    # variable that may have been perturbed
    inputUncertainties = {'p1':opt.p1, 'T1':opt.T1, 'Vs':opt.Vs, 'pe':opt.pe,
                          'Tw':opt.Tw, 'TurbVisRatio':opt.TurbVisRatio,
                          'TurbInten':opt.TurbInten, 'BLTrans':opt.BLTrans,
                          'CoreRadiusFraction':opt.coreRfraction}
    
    # Define the name of the nominal case and load the exit plane data
    nominal = 'case000'
    nominalData, exitVar = read_nenzfr_outfile('./'+nominal+'/'+\
                                               opt.exitStatsFileName)
    # Load the nozzle supply data
    nominalSupply = read_estcj_outfile('./'+nominal+'/'+opt.estcjFile)
    # Now add the relevant supply data (T, h) to the nominalData dictionary
    nominalData['supply_T'] = nominalSupply['T']
    nominalData['supply_h'] = nominalSupply['h']
    # Add the supply variables to the exitVar list
    exitVar.insert(0,'supply_T')
    exitVar.insert(1,'supply_h')
    
    nominalValues = get_values(nominalData, exitVar)
    
    # Loop through each of the perturbed variables
    sensitivity = {}
    uncertainty = {}
    for k in range(len(perturbedVariables)):
        var = perturbedVariables[k]
        
        if var == 'CoreRadiusFraction':
            perturb_CoreRadiusFraction(var, perturbedVariables,\
                                       DictOfCases, opt.gradient)
        # Define the name of the relevant perturbed cases and load the 
        # associated data
        high = 'case'+"{0:02}".format(k)+'1'
        highData, dontNeed  = read_nenzfr_outfile('./'+high+'/'+\
                                                  opt.exitStatsFileName)
        highSupply = read_estcj_outfile('./'+high+'/'+opt.estcjFile)
        highData['supply_T'] = highSupply['T']
        highData['supply_h'] = highSupply['h']
        
        low = 'case'+"{0:02}".format(k)+'2'
        lowData, dontNeed = read_nenzfr_outfile('./'+low+'/'+\
                                                opt.exitStatsFileName)
        lowSupply = read_estcj_outfile('./'+low+'/'+opt.estcjFile)
        lowData['supply_T'] = lowSupply['T']
        lowData['supply_h'] = lowSupply['h']
        
        #print low, nominal, high
        
        # Values of the freestream properties at the perturbed conditions
        highValues = get_values(highData,exitVar)
        lowValues = get_values(lowData,exitVar)
        # Values of the perturbed input values
        highX = DictOfCases[high][perturbedVariables.index(var)]
        lowX = DictOfCases[low][perturbedVariables.index(var)]
        nominalX = DictOfCases[nominal][perturbedVariables.index(var)]
   
        if opt.gradient == "linear": 
            # As the perturbations may not be centered on the nominal
            # condition we caculate the gradient by taking a weighted
            # average of the forward and backward derivatives. The 
            # weightings are such that the truncation error associated 
            # with this gradient estimate is O(3) or higher (i.e. the 
            # weightings are such that the second order terms in the Taylor 
            # series expansion cancel. Thanks to D.Petty for this theory.)
            highWeighting = (nominalX - lowX)/(highX - lowX)
            lowWeighting = (highX - nominalX)/(highX - lowX)
            
            sensitivity[var] = ( highWeighting*(array(highValues)-\
                                                array(nominalValues))/\
                                               (highX - nominalX) + \
                                 lowWeighting*(array(nominalValues)-\
                                               array(lowValues))/\
                                              (nominalX - lowX)     )*\
                                nominalX/array(nominalValues)
            #print sensitivity[var]
        else:
            # For quadratic curve fit we have additional cases 
            # that need to be loaded
            tooHigh = 'case'+"{0:02}".format(k)+'3'
            tooHighData,dontNeed = \
                  read_nenzfr_outfile('./'+tooHigh+'/'+opt.exitStatsFileName)
            tooHighSupply = read_estcj_outfile('./'+tooHigh+'/'+opt.estcjFile)
            tooHighData['supply_T'] = tooHighSupply['T']
            tooHighData['supply_h'] = tooHighSupply['h']
            
            tooLow = 'case'+"{0:02}".format(k)+'4'
            tooLowData,dontNeed = \
                  read_nenzfr_outfile('./'+tooLow+'/'+opt.exitStatsFileName)
            tooLowSupply = read_estcj_outfile('./'+tooLow+'/'+opt.estcjFile)
            tooLowData['supply_T'] = tooLowSupply['T']
            tooLowData['supply_h'] = tooLowSupply['h']
            
            #print tooHigh, high, nominal, low, tooLow
            
            # Values of the freestream properties at the perturbed conditions
            tooHighValues = get_values(tooHighData,exitVar)
            tooLowValues = get_values(tooLowData,exitVar)
            # Values of the perturbed input values
            tooHighX = DictOfCases[tooHigh][perturbedVariables.index(var)]
            tooLowX = DictOfCases[tooLow][perturbedVariables.index(var)]
            
            
            tooHighDeltaX = tooHighX - nominalX
            highDeltaX = highX - nominalX
            tooLowDeltaX = tooLowX - nominalX
            lowDeltaX = lowX - nominalX
            weighting = (tooHighX - tooLowX)/(highX - lowX)
            
            denom = 1/tooHighDeltaX - 1/tooLowDeltaX -\
                   (1/highDeltaX - 1/lowDeltaX)*weighting
            numer =  array(tooHighValues)/tooHighDeltaX**2 -\
                     array(tooLowValues)/tooLowDeltaX**2 -\
                    ( array(highValues)/highDeltaX**2 -\
                      array(lowValues)/lowDeltaX**2 )*weighting -\
                     array(nominalValues)*\
                       ( 1/tooHighDeltaX**2 - 1/tooLowDeltaX**2 - \
                         ( 1/highDeltaX**2 - 1/lowDeltaX**2 )*weighting )
            sensitivity[var] = numer/denom*nominalX/array(nominalValues) 
            
        # Now calculate the uncertainty in each exit flow variable
        # due to the uncertainty in the current (perturbed)
        # input variable
        uncertainty[var] = sensitivity[var]*inputUncertainties[var]
   
    # Write out a file of the sensitivities
    write_sensitivity_summary(sensitivity, perturbedVariables, exitVar)
    # Write out a file of the uncertainties
    write_uncertainty_summary(uncertainty, perturbedVariables, exitVar,\
                              inputUncertainties)
    
    return 0

#---------------------------------------------------------------

if __name__ == '__main__':
    if len(sys.argv) <= 1:
        print "NENZFr Sensitivity:\n Calculate Sensitivity of Shock Tunnel Test Flow Conditions for a varying inputs"
        print "   Version:", VERSION_STRING
        print "   To get some useful hints, invoke the program with option --help."
        sys.exit(0)
    return_flag = main()
    sys.exit(return_flag)
