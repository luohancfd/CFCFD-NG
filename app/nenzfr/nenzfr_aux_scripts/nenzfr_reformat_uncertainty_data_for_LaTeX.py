#!/usr/bin/env python
# nenzfr_reformat_uncertainty_data_for_LaTeX.py
# 
# This script loads ...
#
#
# Luke Doherty
# 28-March-2013

VERSION_STRING = "28-March-2013"

import string
import sys, os
import numpy as np
E3BIN = os.path.expandvars("$HOME/e3bin")
sys.path.append(E3BIN)

#-------------------------------------------------------------------
def read_uncertainty_data(FileToRead):
    """
    Function that reads an uncertainty file
    produced using 'nenzfr_sensitivity.py'
    
    Input: FileToRead - obvious (I hope)
    Outputs: exitVar - a list of the exit variable
                       names
             perturbVar - a list of the input variables
                     that were perturbed
             inputUncert - a dictionary of the uncertainties
                     assigned to the input variables
             uncertDict - a dictionary summarising the 
                     percentage uncertainty of each
                     exitVar due to each perturbVar
    """
    fp = open(FileToRead,'r')
    # Perturbed variables
    line = fp.readline()
    perturbVar = [k for k in line.strip().split() if k!='variable']
    # Input uncertainties for perturbed variables
    line = fp.readline()
    inputUncert = {}
    temp = [float(k.strip('%')) for k in line.strip().split() \
                    if k not in ['(input','uncertainty)']]
    for k in range(len(temp)):
        inputUncert[perturbVar[k]] = temp[k]
    line = fp.readline() # a line of -----
    # Read remainder of file
    data = fp.readlines()
    # Assemble dictionary of the data
    uncertDict = {}
    exitVar = []
    for line in data:
        lineList = line.strip().split()
        eV = lineList[0]
        exitVar.append(eV)
        uncertDict[eV] = {}
        for k in range(len(perturbVar)):
             uncertDict[eV][perturbVar[k]] = float(lineList[k+1].strip('%'))

    return exitVar, perturbVar, inputUncert, uncertDict

def read_grid_convergence_data(FileToRead):
    """
    Function to read grid convergence error file produced
    by 'nenzfr_GCI.py'
    
    Input: FileToRead - obvious (I hope)
    Outputs: exitVar - a list of the exit variable
                       names
             gridName - a list of the grids that were
                       analysed.
             uncertDict - a dictionary summarising the
                     percentage error of each exitVar
                     for each grid
    """
    fp = open(FileToRead)
    fp.readline() # dont need the first line (description)
    # Safety factor
    line = fp.readline()
    safetyFactor = float(line.strip().split()[-1])
    # Read names of simulations used for grid convergence
    line = fp.readline()
    gridName = [k.strip(':').strip('./').strip('/') for k in \
                line.strip().split() if k not in ['#','property:']]
    # Read remainder of file
    data = fp.readlines()
    # Assemble a dictionary of the data
    gridErrors = {}
    exitVar = []
    for line in data:
        lineList = line.strip().split()
        eV = lineList[0]
        exitVar.append(eV)
        gridErrors[eV] = {}
        for k in range(len(gridName)):
            gridErrors[eV][gridName[k]] = float(lineList[k+1])
    
    return exitVar, gridName, gridErrors, safetyFactor

def read_variation_over_core_data(FileToRead):
    """
    Function to read summary file generated by 
    'nenzfr_examine_variation_over_core.py'.
    
    Inputs: FileToRead
    Outputs: exitVar - a list of the exit variable
                       names
             caseName - a list of the cases used to
                        examine flow variation
             coreVariation - a dictionary of the
                      percentage variation over the 
                      core for each exit variable for
                      each case
             coreRadiusFraction - obvious
    """
    fp = open(FileToRead)
    fp.readline() # dont need the first line (description)
    # Core Radius Fraction
    line = fp.readline()
    coreRadiusFraction = float(line.strip().split()[-1])
    # Read the column names
    line = fp.readline()
    caseName = [k for k in line.strip().split() if k not in ['#','Property']]
    fp.readline() # don't need this line (empty)
    # Read remainder of file
    data = fp.readlines()
    # Assemble a dictionary of the data
    coreVariation = {}
    exitVar = []
    for line in data:
        lineList = line.strip().split()
        eV = lineList[0]
        exitVar.append(eV)
        coreVariation[eV] = {}
        for k in range(len(caseName)):
            coreVariation[eV][caseName[k]] = float(lineList[k+1])
    
    return exitVar, caseName, coreVariation, coreRadiusFraction

def read_RSA_error_data(FileToRead):
    """
    Function to read the residual summary file generated by
    'nenzfr_evaluate_RSA.py'
    
    Inputs: FileToRead
    Outputs: exitVar - a list of the exit variable
                       names
             caseName - a list of the cases used to
                        examine RSA error
             RSAresidual - a dictionary of the
                      percentage error in each exit
                      variable for each case
    """
    fp = open(FileToRead)
    # Get case names
    line = fp.readline()
    caseName = [k for k in line.strip().split() \
                if k not in ['variable','Root-Sum-']]
    caseName.append('RSS')
    # Don't need the next three lines
    fp.readline()
    fp.readline()
    fp.readline()
    # Read the remainder of the file
    data = fp.readlines()
    # Assemble a dictionary of the data
    RSAresidual = {}
    exitVar = []
    for line in data:
        lineList = line.strip().split()
        #print lineList
        eV = lineList[0]
        exitVar.append(eV)
        RSAresidual[eV] = {}
        #print caseName
        #print range(len(caseName))
        for k in range(len(caseName)):
            RSAresidual[eV][caseName[k]] = float(lineList[k+1])
    
    return exitVar, caseName, RSAresidual 
    
#-------------------------------------------------------------------
def main():
    condition = 'lp'
    
    # (1): Load uncertainties due to nenzfr inputs
    exitVar, perturbVars, inputUncert, uncertDict = \
        read_uncertainty_data('sensitivity_'+condition+'_air/uncertainties.dat')
            
    # (2): Load uncertainties due to grid convergence (or
    #      lack thereof)
    # Note: I only completed a grid convergence study for the hp
    #       condition so I use its results for the lp condition
    exitVar2, gridName, gridErrors, safetyFactor = \
         read_grid_convergence_data('grid_convergence_hp_air/grid-convergence-errors-linear-fit.dat')
    nominal_grid_name = 'response_surface_hp_air/case00'
        
    # (3): Load uncertainties due to spatial variation over
    #      the core
    exitVar3, caseName, coreVariation, coreRadiusFraction = \
         read_variation_over_core_data('response_surface_'+condition+'_air/summary_of_variation_across_core.dat')
         
    # (4): Load uncertainties due to useage of a Response
    #      Surface
    # Note: I only evaluated the RS for the hp condition so I must
    #       use its results for the lp condition
    exitVar4, caseName, RSAresidual = \
         read_RSA_error_data('rsa_evaluation_hp_air/residual_summary.dat')
    

    # I hardcode the exit variables so that the order in which they
    # get written out is what I want for my thesis.
    exitVars = ['supply_T','supply_h','p','T[0]','rho','vel.x','vel.y',\
                'a','M_local','pitot_p','total_p','total_h','q','m_dot',\
                'Re_u','p/q','mu','k[0]','e[0]','massf[0]-N2','massf[1]-O2',\
                'massf[2]-N','massf[3]-O','massf[4]-NO','mu_t','k_t','tke',\
                'omega'] # Don't include dt_chem
    
    # Now begin writing out summary file
    fp = open(condition+'_uncertainty_summary.dat','w')
    fp.write('# Total-1 includes only uncertainties due to input variables.\n')
    fp.write('# Total-2 includes all uncertainties.\n')
    fp.write('# Total-3 excludes RSA error\n')
    fp.write('# Totals are calculated using Root-Sum-Square.\n#\n')
    fp.write('# CoreRadiusFraction: {0:.6f}\n'.format(coreRadiusFraction))
    fp.write('# Grid-Error Safety Factor: {0:.2f}\n'.format(safetyFactor))
    fp.write('# Nominal Grid: {0:s}\n'.format(nominal_grid_name))
    fp.write('#\n')
    fp.write('#   Property\t')
    for pV in perturbVars:
        if pV not in ['total']:
            fp.write('{0:s}\t'.format(pV))
        else:
            fp.write('{0:s}\t'.format('Total-1'))
    fp.write('Core-Variation\tGrid-Error\tRSA-Error\tTotal-2\tTotal-3\n')
    fp.write('Input Uncert\t')
    for pV in perturbVars:
        if pV not in ['total']:
            fp.write('{0: 6.3f}\t'.format(inputUncert[pV]))
    fp.write('n/a\tn/a\tn/a\tn/a\tn/a\tn/a\n')
    # Write out data
    for eV in exitVars:
        sum1 = 0.
        sum2 = 0.
        fp.write('{0:>12s}\t'.format(eV))
        # (1)
        for pV in perturbVars:
            if pV not in ['total']:
               fp.write('{0: 6.3f}\t'.format(uncertDict[eV][pV]))
               sum1 += np.power(uncertDict[eV][pV], 2)
               sum2 += np.power(uncertDict[eV][pV], 2)
            else:
               fp.write('{0: 6.3f}\t'.format(uncertDict[eV][pV]))
        if eV not in ['supply_T','supply_h']:
            # (3)
            fp.write('{0: 6.3f}\t'.format(coreVariation[eV]['mean']))
            sum1 += np.power(coreVariation[eV]['mean'], 2)
            sum2 += np.power(coreVariation[eV]['mean'], 2)
            # (2)
            fp.write('{0: 6.3f}\t'.format(gridErrors[eV][nominal_grid_name]))
            sum1 += np.power(gridErrors[eV][nominal_grid_name], 2)
            sum2 += np.power(gridErrors[eV][nominal_grid_name], 2)
            # (4)
            fp.write('{0: 6.3f}\t'.format(RSAresidual[eV]['RSS'])) 
            sum1 += np.power(RSAresidual[eV]['RSS'], 2)
        else:
            fp.write('{0: 6.3f}\t{0: 6.3f}\t{0: 6.3f}\t'.format(0.,0.,0.))
        # Total-1
        total_1 = np.sqrt(sum1)
        fp.write('{0:6.3f}\t'.format(total_1))
        # Total-2
        total_2 = np.sqrt(sum2)
        fp.write('{0:6.3f}\n'.format(total_2))
    fp.close()

if __name__ == '__main__':
    return_flag = main()
    sys.exit(return_flag)

