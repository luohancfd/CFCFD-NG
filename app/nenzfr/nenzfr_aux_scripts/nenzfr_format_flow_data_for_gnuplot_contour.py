#!/usr/bin/env python
# nenzfr_format_flow_data_for_gnuplot_contour.py
#
# This script reads in the final solution files of a nenzfr
# nozzle simulation and then writes the data out to a "slice"
# file that is suitable for use with gnuplot's "splot" plotting
# function.
# 
# Notes on ouput file format:
#    - "blocks" of data are separated by a blank line
#    - each "block" of data represents j=const data from
#      the complete flow solution
#    - each row within a "block" represents i=const
#    - each collumn represents a different flow variable
#      as described in the header line
#
#   (- i,j are indices in the x,y directions respectively)
#
#
# Luke Doherty
# School of Mechanical and Mining Engineering
# The University of Queensland

VERSION_STRING = "17-Jan-2013"

import sys, os, glob, gzip
import optparse
from nenzfr_stats import get_slice_data
from e3_flow import StructuredGridFlow
import math

E3BIN = os.path.expandvars("$HOME/e3bin")
sys.path.append(E3BIN)

def main():
    """
    """
    #op = optparse.OptionParser(version=VERSION_STRING)
    #
    #op.add_option('--FileToRead',dest='inputFile',default='None',
    #              help="")
    #op.add_option('--nnj',dest='nnj',default=100.0,
    #              help="")
    #op.add_option('--FileToWrite',dest='outputFile',default='None',
    #              help="")
    #opt, args = op.parse_args()
    
    test_section_data = True
    
    if test_section_data is False:
        outputFile = "nozzle.data"
    elif test_section_data is True:
        outputFile = "test-section-slice.data"

    # Read in the data
    fileList = glob.glob("./flow/t9999/*.gz")
    GridFlowData = []
    for f in fileList:
        f1 = gzip.open(f,"r")
        GridFlowData.append(StructuredGridFlow())
        GridFlowData[-1].read(f1)
        GridFlowData[-1].add_aux_variables(cmdLineDict={'--add-pitot-p':1,\
                         '--add-mach':1,'--add-total-p':1,'--add-total-enthalpy':1})
        f1.close()
    variable_list = GridFlowData[0].vars
    variable_list.append('log10-p') # We calculate this later
    
    #variable_list = ['pos.x','pos.y','M_local']
    # Write out the header line
    fout = open(outputFile,'w')
    fout.write('# This file generated by "nenzfr_format_flow_data_for_gnuplot_contour.py"\n#\n')
    fout.write('# Variables: ')
    count = 0
    
    for var in variable_list:
        count += 1
        fout.write('{0:d}:{1:} '.format(count,var))
    fout.write('\n')
    
    
    # Number of blocks in radial direction
    nbj = 4
    # Total number of blocks 
    if test_section_data is False:
        nb = int(len(fileList))
        r = range(nbj)
    elif test_section_data is True:
        # For the test-section simulation, modify as required. 
        # This number should be the total number of blocks in the
        # INNER portion of the test section. The OUTER portion is
        # treated separately later
        nb = 68
        r = range(nbj,nbj+nbj)
    
    #print GridFlowData[0].ni
    #print GridFlowData[0].nj    
    
    # Write out the data with strips of j=const. separated
    # by a blank line
    
    #for bj in range(nbj):
    #for bj in range(nbj,nbj+nbj): # For test-section
    for bj in r:
        print "bj=",bj
        for j in range(GridFlowData[bj].nj):
            for b in range(bj,nb,nbj): # Row of blocks
                if j == 0:
                    print "b=",b
                for i in range(GridFlowData[b].ni):
                    for var in variable_list: # Each variable
                        if var in ['log10-p',]:
                            fout.write( '{0:.6e} '.format(\
                                math.log10( float(GridFlowData[b].data['p'][i,j,0]) )))
                        else:
                            #print "bj=",bj
                            #print "j=",j
                            #print "bi=",bi
                            #print "i=",i
                            #print "var=",var
                            #print GridFlowData[bi].data[var][i,j,0]
                            #break 
                            fout.write( '{0:.6e} '.format(\
                                float(GridFlowData[b].data[var][i,j,0])) )
                    fout.write('\n')
            fout.write('\n')

    if test_section_data is True:
        # For test-section simulation we write out the outer portion of
        # the test-section last (separately to above loop)
        start = nb
        nb = 84
        for bj in [start,]:
            print "bj=",bj
            for j in  range(GridFlowData[bj].nj):
                for b in range(bj,nb): # Row of blocks
                    if j == 0:
                        print "b=",b
                    for i in range(GridFlowData[b].ni):
                        for var in variable_list: # Each variable
                            if var in ['log10-p',]:
                                fout.write( '{0:.6e} '.format(\
                                    math.log10( float(GridFlowData[b].data['p'][i,j,0]) )))
                            else:
                                fout.write( '{0:.6e} '.format(\
                                    float(GridFlowData[b].data[var][i,j,0])) )
                        fout.write('\n')
                fout.write('\n')
    fout.close()
                



            

    ## Read in the data
    #variable_list, SliceData = get_slice_data(inputFile)
    #
    ## Write out the data with a format suitable
    ## for gnuplot contour plotting
    #variable_list = ['pos.x', 'pos.y', 'M_local']
    #fout = open(outputFile,'w')
    #count = 0
    #fout.write('# Variables: ')
    #for var in variable_list:
    #    count += 1
    #    fout.write('{0:d}:{1:} '.format(count,var))
    #fout.write('\n')
    #count = 0
    #L = len(SliceData['pos.x'])
    #for j in range(L):
    #    count += 1
    #    for var in variable_list:
    #        fout.write('{0:.6e} '.format(SliceData[var][j]))
    #    if count == nnj:
    #        fout.write('\n')
    #        count = 0
    #    fout.write('\n')
    #fout.close()
        
    
if __name__ == '__main__':
    return_flag = main()
    sys.exit(return_flag)


