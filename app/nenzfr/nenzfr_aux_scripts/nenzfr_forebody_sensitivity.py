#!/usr/bin/env python
# nenzfr_forebody_sensitivity.py
#
# This script calculates the sensitivity and uncertainty in 
# the post-forebody shock conditions due to the various input
# parameters to nenzfr. The calculation follows that of:
#	Mee, D. (1993) 'Uncertainty Analsysi of conditions 
#       in the test section of the T4 Shock Tunnel', UQ 
#       Mechanical Engineering Departmental Report No. 4/1993
# and is based on a set of perturbed nenzfr calculations 
# generated by "nenzfr_perturbed.py"
#
# Annex 4-C of AGARD-AR-304 details why it is important that
# the uncertainty in derived parameters (in this case forebody
# properties) be calculated with respect to the independent 
# parameters (in this case inputs to nenzfr) and not dependent 
# parameters (in this case nenzfr freestream properties).
#
# This script is essentially a modified version of 
# "nenzfr_sensitivity.py".
#
# If the nenzfr simulations were completed using a chemically
# reacting mixture of thermally perfect gases then the oblique
# shock calculation is completed assuming a FROZEN mixture of 
# thermally perfect gases.
#  
# Luke Doherty
# School of Mechancial and Mining Engineering
# The University of Queensland

VERSION_STRING = "08-August-2012"

import shlex, string
import sys, os
import optparse, copy, math
from numpy import array, sqrt
from nenzfr_utils import run_command, quote, read_case_summary, \
     read_nenzfr_outfile, read_estcj_outfile, \
     read_gmodelFile_from_config
from libprep3 import create_gas_model, Gas_data, set_massf
import cfpylib.gasdyn.gas_flow as gf
from cfpylib.nm.zero_solvers import secant

E3BIN = os.path.expandvars("$HOME/e3bin")
sys.path.append(E3BIN)

#---------------------------------------------------------------
# The following class was modifed from Peter Blyton's libgas_gas.py
# script which may be found in cfpylib/gasdyn/. 
#
# We use this gas class so that we can easily use the cfpylib/gasdyn/gas_flow.py
# functions using the same gas model that the main nenzfr simulation was 
# computed with.
class Gas(object):
    """
    Provides the place to hold the libgas gas data object and gas model object.
    """
    def __init__(self, name=None, speciesDict=None, gasModelFile=None, \
                       gasModelType='thermally perfect mixture'):
        """
        Set up the libgas model.

        :param speciesDict: dictionary of species names and mass fractions
        :param gasModelFile: an appropriate file name for a gas model
        :param gasModelType: the particular libgas gas model type
        """
        if gasModelFile is None:
           raise StandardError("gasModelFile name is not valid")
        if speciesDict is None: 
           raise StandardError("speciesDict is not valid")
           
        self.name = name
        self.speciesDict = speciesDict
        self.gasModelFile = gasModelFile
        self.gasModelType = gasModelType
        self.gasModel = create_gas_model(gasModelFile)
        self.gasData = Gas_data(self.gasModel)
        set_massf(self.gasData, self.gasModel, speciesDict)
        self.set_pT(100.0e3, 300.0)
        return

    def clone(self):
        """
        Clone the current Gas object to make another, just the same.

        :returns: the new Gas object.
        """
        other = Gas(self.name, self.speciesDict, self.gasModelFile,\
                    self.gasModelType)
        other.set_pT(self.p, self.T)
        return other
    
    def set_pT(self, p, T, transProps=True):
        """
        Compute the thermodynamic state from given pressure and temperature.

        :param p: pressure, Pa
        :param T: temperature, K
        :param transProps: if True, compute transport properties as well.
        """
        self.p = p
        self.gasData.p = p
        self.T = T
        self.gasData.T[0] = T
        # Calculate density, sound speed, internal energy and quality if available
        self.gasModel.eval_thermo_state_pT(self.gasData)
        self.rho = self.gasData.rho
        self.a = self.gasData.a
        #self.son = self.a
        self.u = self.gasData.e[0]
        self.e = self.u
        self.quality = self.gasData.quality
        # Manually call methods to calculate other thermodynamic properties
        self.h = self.gasModel.mixture_enthalpy(self.gasData)
        self.s = self.gasModel.mixture_entropy(self.gasData)
        self.R = self.gasModel.R(self.gasData)
        self.C_p = self.gasModel.Cp(self.gasData)
        self.C_v = self.gasModel.Cv(self.gasData)
        self.gam = self.gasModel.gamma(self.gasData)
        if transProps:
            self.gasModel.eval_transport_coefficients(self.gasData)
            self.mu = self.gasData.mu
            self.k = self.gasData.k[0]
        else:
            self.mu = 0.0
            self.k = 0.0
        return

    def set_rhoT(self, rho, T, transProps=True):
        """
        Compute the thermodynamic state from given density and temperature.

        :param rho: density, kg/m**3
        :param T: temperature, K
        :param transProps: if True, compute transport properties as well.
        """
        self.gasData.rho = rho
        self.gasData.T[0] = T
        self.gasModel.eval_thermo_state_rhoT(self.gasData)
        return self.set_pT(self.gasData.p, T, transProps)

    def set_ps(self, p, s, transProps=True):
        """
        Compute the thermodynamic state from given pressure and entropy
    
        :param p: pressure, Pa
        :param s: entropy, J/(kg.K)
        :param transProps: if True, compute transport properties as well.
        """
        # The libgas library does not have a pressure-entropy thermodynamic
        # state solver, so we need to do the iterative calculation ourselves.
        #print 
        #print "s_in=",s
        #print "p_in=",p
        def entropy_solve(temp):
            self.set_pT(p, temp) # calculate density
            entropy = self.gasModel.mixture_entropy(self.gasData) # entropy from temp and density
            #print "s-entropy=",s-entropy
            return s - entropy
        T = secant(entropy_solve, 250.0, 260.0, tol=1.0e-4)
        #print "T_out=",T
        if T == "FAIL": raise Exception("Secant solver failed, bailing out!")
        return self.set_pT(p, T, transProps)

    def write_state(self, strm):
        """
        Writes the gas state data to the specified stream.
        """
        strm.write('    p: %g Pa, T: %g K, rho: %g kg/m**3, e: %g J/kg, h: %g J/kg, a: %g m/s\n'
                   % (self.p, self.T, self.rho, self.u, self.h, self.a) )
        strm.write('    R: %g J/(kg.K), gam: %g, Cp: %g J/(kg.K), mu: %g Pa.s, k: %g W/(m.K)\n'
                   % (self.R, self.gam, self.C_p, self.mu, self.k) )
        strm.write('    name: %s\n' % self.name)
        return

#---------------------------------------------------------------
def perturb_CoreRadiusFraction(var, perturbedVariables,\
                               DictOfCases, levels):
    """
    Perturbation of the CoreRadiusFraction may be completed
    as a post-processing step using the nominal condition
    flow solution. We don't need to compute separate solutions.

    This function copies the nominal condition solution to a 
    new case file and then runs nenzfr with the --just-stats
    option and the perturbed CoreRadiusFraction value. 
    """
    
    for kk in range(levels):
        if kk != 0:
            caseString = 'case'+"{0:02}".format(\
                 perturbedVariables.index(var))+\
                 "{0:01}".format(kk)
            # Only if required to we proceed with copying the
            # nominal case data and calling 'nenzfr.py'
            if not os.path.exists(caseString):
                print "Perturbing "+var
                #command_text = 'rm -r '+caseString
                #run_command(command_text)
                
                # Copy nominal case data into a new case
                # directory
                command_text = 'cp -r case000 '+caseString
                run_command(command_text)
                # Change into new directory and call nenzfr --just-stats
                os.chdir(caseString)
                command_text = 'nenzfr.py --just-stats --CoreRadiusFraction='+\
                  str(DictOfCases[caseString][perturbedVariables.index(var)])
                run_command(command_text)
                os.chdir('../')

def get_values(dict, propertyList):
    """
    Adapted from Peter Jacob's function "get_fractions" which
    may be found within "cea2_gas.py".
    """
    valueList = []
    #print propertyList
    for s in propertyList:
        #print s
        if s in dict.keys():
            #print s
            #print dict[s]
            valueList.append(dict[s])
        else:
            valueList.append(0.0)
            print "WARNING: "+s+" was not found in the current case dictionary."
    return valueList

def add_extra_variables(data, var):
    """
    We add some additional variables that of are interest to 
    the input dictionary and list. These variables include the 
    dynamic pressure (q), mass flow per unit area (m_dot), the 
    unit Reynolds number (Re_u) and the pressure coefficient 
    (p/q)

    data: dictionary of data
    var: list of variables
    """
    U_squared = data['vel.x']*data['vel.x'] + data['vel.y']*data['vel.y']
    U = U_squared**0.5
    # Dynamic Pressure
    data['q'] = 0.5 * data['rho'] * U_squared
    var.append('q')
    # Mass flow rate per unit area
    data['m_dot'] = data['rho'] * U
    var.append('m_dot')
    # Unit Reynolds number
    data['Re_u'] = data['m_dot'] / data['mu']
    var.append('Re_u')
    # Pressure coefficient
    data['p/q'] = data['p'] / data['q']
    var.append('p/q')
    
    return data, var

def calculate_forebody(data, theta, gmodelFile):
    """
    Calculate the conditions behind an oblique forebody shock
    using the same gas model that the nenzfr simulations used.
    
    data: dictionary of freestream data
    theta: angle of the forebody (in degrees) with respect to 
        the coordinate system of the nozzle (x is axial, y is
        radial/vertical).
    gmodelFile: suitable gas model file name
    """
    
    # Define the list of forebody variables that we will be 
    # returning.
    #
    # Note that beta is the shock angle
    fbVar = ['rho','vel.x','vel.y','p','a','mu','k[0]',\
             'T[0]','M_local','pitot_p','total_p','total_h',\
             'beta']
    
    ## Calculate the deflection angle of the incoming flow
    #thetaD = math.atan(data['vel.y']/data['vel.x'])
    
    # Convert forebody wedge angle to radians
    theta_rad = theta*math.pi/180.0
    
    ## Calculate the total angle that the forebody makes relative 
    ## to the direction of the incoming flow
    #thetaTotal = thetaD - theta_rad
    
    # Extract a species dictionary from the input data 
    speciesKeys = [k for k in data.keys() if k.startswith("mass")]
    speciesMassFrac = [data[k] for k in speciesKeys]
    speciesDict = dict([(k.split('-')[1],v) for k,v in zip(speciesKeys,speciesMassFrac)])    
    # Create a Gas object for current state
    state = Gas(name='air5species',speciesDict=speciesDict,gasModelFile=gmodelFile) 
    state.set_pT(p=data['p'],T=data['T[0]'])

    # Sanity check on density and viscosity
    #assert abs(state.rho - data['rho']) < 1e-6
    #assert abs(state.mu - data['mu']) < 1e-8
    #assert abs(state.k - data['k[0]']) < 1e-6 
    
    # Now set about calculating the post-forebody shock
    # conditions. 
    # 
    # The incoming flow is axisymmetric however we ignore
    # any divergence (non-zero vel.y) and just treat the 
    # total velocity as an axial component to calculate 
    # the forebody shock.
    vel = sqrt(data['vel.x']*data['vel.x'] + data['vel.y']*data['vel.y'])
    beta = gf.beta_oblique(state, vel, theta_rad)
    theta_out, fbV, fbState = gf.theta_oblique(state, vel, beta)
    
    ## Convert shock angle to be relative to centreline of nozzle
    ## and in the correct direction
    #beta_final =  math.copysign(beta,theta) + thetaD
    
    # Calculate the velocity components
    fbV_x = fbV*math.cos(theta_rad)
    fbV_y = fbV*math.sin(theta_rad)
    
    # Calculate the total pressure behind the forebody shock
    fbTotal = gf.total_condition(fbState, fbV)
    # Calculate the pitot pressure behind the forebody shock
    fbPitot = gf.pitot_condition(fbState, fbV)
    
    # Now create and populate the forebody data dictionary
    fbData = {} 
    fbData['p'] = fbState.p; fbData['rho'] = fbState.rho;
    fbData['T[0]'] = fbState.T; fbData['a'] = fbState.a;
    fbData['M_local'] = fbV/fbData['a']; 
    fbData['mu'] = fbState.mu; fbData['k[0]'] = fbState.k; 
    fbData['vel.x'] = fbV_x; fbData['vel.y'] = fbV_y;
    fbData['total_h'] = fbState.p/fbState.rho + fbState.e + 0.5*fbV*fbV
    fbData['total_p'] = fbTotal.p; fbData['pitot_p'] = fbPitot.p
    fbData['beta'] = beta; #fbData['thetaD'] = thetaD
     
    # Some more sanity checks
    assert fbData['M_local'] < data['M_local']
    assert fbData['T[0]'] > data['T[0]']
    assert fbData['p'] > data['p']
    
    # Add extra variables of interest (q, Re_u, m_dot)
    fbData, fbVar = add_extra_variables(fbData, fbVar)
     
    return fbData, fbVar

def write_forebody_summary(data, var, caseName):
    """
    Write out the forebody properties to a file so that we
    have a record. 
    """
    titleFormatDict = {'rho':'{0:{fill}>10}','vel.x':'{0:{fill}>8}',
                       'vel.y':'{0:{fill}>8}','p':'{0:{fill}>8}',
                       'a':'{0:{fill}>7}','mu':'{0:{fill}>11}', 
                       'k[0]':'{0:{fill}>9}','T[0]':'{0:{fill}>7}',
                       'M_local':'{0:{fill}>8}','total_h':'{0:{fill}>11}',
                       'total_p':'{0:{fill}>11}','pitot_p':'{0:{fill}>11}',
                       'beta':'{0:{fill}>9}','thetaD':'{0:{fill}>11}',
                       'q':'{0:{fill}>12}','m_dot':'{0:{fill}>8}',
                       'Re_u':'{0:{fill}>11}','p/q':'{0:{fill}>10}'}

    formatDict = {'rho':'{0:10.5g}', 'vel.x':'{0:>8.5g}',
                  'vel.y':'{0:>8.4g}', 'p':'{0:>8.5g}',
                  'a':'{0:>7.4g}', 'mu':'{0:>11.4g}',
                  'k[0]':'{0:>9.4g}','T[0]':'{0:>7.4g}',
                  'M_local':'{0:>8.4g}','total_h':'{0:>11.4g}',
                  'total_p':'{0:>11.4g}','pitot_p':'{0:>11.4g}',
                  'beta':'{0:>9.4g}','thetaD':'{0:>11.4g}',
                  'q':'{0:>12.5g}','m_dot':'{0:>8.5g}',
                  'Re_u':'{0:>11.4g}','p/q':'{0:>10.5g}'}
    
    if not os.path.exists('forebody_conditions.dat'):
        fout = open('forebody_conditions.dat','w')
        
        # Write header information out first time we open the file
        fout.write('{0:>7}'.format('#'))
        for k in tuple(var):
            fout.write(titleFormatDict[k].format(k,fill=''))
        fout.write('\n')
        # Underline the title
        for k in var:
            fout.write(titleFormatDict[k].format('-',fill='-'))
        fout.write('{0:->7}'.format('-'))
        fout.write('\n')  
        
    else:
        fout = open('forebody_conditions.dat','a')
    
    # Write case name
    fout.write('{0:>7}'.format(caseName))
    # Write out the data
    for k in var:
        fout.write(formatDict[k].format(data[k]))
    fout.write('\n') 
    fout.close()
    
    return
    
def write_sensitivity_summary(sensitivity, perturbedVariables, exitVar,\
                              prefix, type):
    """
    Write out a file summarising the sensitivity of each exit flow 
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>13}', 'T1':'{0:{fill}>13}',
                       'Vs':'{0:{fill}>13}', 'pe':'{0:{fill}>13}', 
                       'Tw':'{0:{fill}>13}', 'BLTrans':'{0:{fill}>13}',
                       'TurbVisRatio':'{0:{fill}>14}', 
                       'TurbInten':'{0:{fill}>13}',
                       'CoreRadiusFraction':'{0:{fill}>20}',
                       'fbAngle':'{0:{fill}>13}',
                       'vel.x':'{0:{fill}>13}','vel.y':'{0:{fill}>13}',
                       'p':'{0:{fill}>13}','mu_t':'{0:{fill}>13}',
                       'k_t':'{0:{fill}>13}','tke':'{0:{fill}>13}',
                       'omega':'{0:{fill}>13}','massf[0]-N2':'{0:{fill}>13}',
                       'massf[1]-O2':'{0:{fill}>13}','massf[2]-N':'{0:{fill}>13}',
                       'massf[3]-O':'{0:{fill}>13}','massf[4]-NO':'{0:{fill}>13}',
                       'T[0]':'{0:{fill}>13}'} 
    formatDict = {'p1':'{0:13.5g}', 'T1':'{0:>13.5g}', 
                  'Vs':'{0:>13.5g}', 'pe':'{0:>13.5g}', 
                  'Tw':'{0:>13.5g}', 'BLTrans':'{0:>13.5g}',
                  'TurbVisRatio':'{0:>14.5g}', 
                  'TurbInten':'{0:>13.5g}',
                  'CoreRadiusFraction':'{0:>20.5g}',
                  'fbAngle':'{0:>13.5g}',
                  'vel.x':'{0:>13.5g}','vel.y':'{0:>13.5g}',
                  'p':'{0:>13.5g}','mu_t':'{0:>13.5g}',
                  'k_t':'{0:>13.5g}','tke':'{0:>13.5g}',
                  'omega':'{0:>13.5g}','massf[0]-N2':'{0:>13.5g}',
                  'massf[1]-O2':'{0:>13.5g}','massf[2]-N':'{0:>13.5g}',
                  'massf[3]-O':'{0:>13.5g}','massf[4]-NO':'{0:>13.5g}',
                  'T[0]':'{0:>13.5g}'}
    # Open file
    if type in ['relative']:
        suffix = ''
    elif type in ['absolute']:
        suffix = '_abs'
    if prefix in ['']:
        prefix = 'forebody_'
    fout = open(prefix+'sensitivities'+suffix+'.dat','w')
    
    # Write header information
    if prefix in ['fb_to_fs_']:
        fout.write('{0:}\n'.format('forebody-to-freestream '+type+' sensitivities'))
    else:
        fout.write('{0:}\n'.format(type+' sensitivities'))
    fout.write('{0:>13}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->13}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data
    for k in exitVar:
        fout.write('{0:>13}'.format(k))
        for kk in perturbedVariables:
            #if prefix in ['fb_to_fs_']:
                #print k, kk
            X_kk = sensitivity[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
        fout.write('\n')
    
    fout.close()


def write_uncertainty_summary(uncertainty, perturbedVariables, \
                              exitVar, inputUncertainties):
    """
    Write out a file summarising the sensitivity of each exit flow
    parameter to each of the input parameters.
    """
    titleFormatDict = {'p1':'{0:{fill}>10}', 'T1':'{0:{fill}>10}',
                       'Vs':'{0:{fill}>10}', 'pe':'{0:{fill}>10}',
                       'Tw':'{0:{fill}>10}', 'BLTrans':'{0:{fill}>10}',
                       'TurbVisRatio':'{0:{fill}>14}',
                       'TurbInten':'{0:{fill}>11}',
                       'CoreRadiusFraction':'{0:{fill}>20}',
                       'fbAngle':'{0:{fill}>9}'}
    formatDict = {'p1':'{0:10.2%}', 'T1':'{0:>10.2%}', 
                  'Vs':'{0:>10.2%}', 'pe':'{0:>10.2%}',
                  'Tw':'{0:>10.2%}', 'BLTrans':'{0:>10.2%}',
                  'TurbVisRatio':'{0:>14.2%}',
                  'TurbInten':'{0:>11.2%}',
                  'CoreRadiusFraction':'{0:>20.2%}',
                  'fbAngle':'{0:>9.2%}'}
    
    fout = open('forebody_uncertainties.dat','w')

    # Write header information
    fout.write('{0:>19}'.format('variable'))
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format(k,fill=''))
    fout.write('{0:>10}'.format('total'))
    fout.write('\n')
    # Write out the uncertainty for each perturbed variable
    fout.write('{0:>19}'.format('(input uncertainty)'))
    for k in perturbedVariables:
        fout.write(formatDict[k].format(inputUncertainties[k]))
    fout.write('{0:>10}'.format(''))
    fout.write('\n')
    for k in perturbedVariables:
        fout.write(titleFormatDict[k].format('-',fill='-'))
    fout.write('{0:->29}'.format('-'))
    fout.write('\n')
    
    # Now write out all the data. We also calculate and write out the 
    # total uncertainty in each exit flow variable due to the contributions
    # from all input values.
    for k in exitVar:
        fout.write('{0:>19}'.format(k))
        X_total = 0.0
        for kk in perturbedVariables:
            X_kk = uncertainty[kk][exitVar.index(k)]
            fout.write(formatDict[kk].format(X_kk))
            X_total += X_kk**2
        fout.write('{0:10.2%}'.format(X_total**0.5))
        fout.write('\n')

    fout.close()



def main():
    """
    Examine the command-line options and then calculate the sensitivties
    and uncertainties of each forebody flow property based on a set of 
    nenzfr results generated by "nenzfr_perturbed.py".
    """
    op = optparse.OptionParser(version=VERSION_STRING)

    op.add_option('--run-defaults', dest='runDefaults', action='store_true',
                  default=True, help="calculate sensitivities and "
                  "uncertainties using all the default values.")
    
    op.add_option('--job', dest='jobName', default='nozzle',
                  help="base name for Eilmer3 files [default: %default]")
    op.add_option('--exitStatsFile', dest='exitStatsFileName',
                  default='nozzle-exit.stats',
                  help="file that holds the averaged nozzle-exit "
                       "data and is to be read in for each perturbation "
                       "case [default: %default]")
    op.add_option('--estcjFile', dest='estcjFile', default='nozzle-estcj.dat',
                  help="file that holds the estcj result and is to be read in "
                       "for each perturbation case. [default: %default]")
     
    op.add_option('--levels', dest='levels', default=3,choices=[3,5],
                  help=("specify how many points are to be used in the "
                        "calculation of the gradient. Includes the nominal.  "
                        "Options: 3, 5 [default: %default]"))
    
    # The default values for the following inputs are based on those given in 
    # Rainer Kirchhartz' PhD Thesis (Appendix B)
    op.add_option('--Xp1', dest='p1', default=0.0325, type='float',
                  help=("relative uncertainty in shock tube fill pressure. "
                        "[default: %default]" ))
    op.add_option('--XT1', dest='T1', default=0.02, type='float',
                  help=("relative uncertainty in shock tube fill temperature. "
                        "[default: %default]"))
    op.add_option('--XVs', dest='Vs', default=0.05, type='float',
                  help=("relative uncertainty in the incident shock speed. "
                        "[default: %default]"))
    op.add_option('--Xpe', dest='pe', default=0.025, type='float',
                  help=("relative uncertainty in the equilibrium pressure "
                        "(after shock reflection). [default: %default]"))
    # The default values for the following inputs are guestimates :)
    op.add_option('--XTwall', dest='Tw', default=0.04, type='float',
                  help=("relative uncertainty in nozzle wall temperature. "
                        "[default: %default]"))
    op.add_option('--XBLTrans', dest='BLTrans', default=1.00, type='float',
                  help=("relative uncertainty in the boundary layer "
                        "transition location. [default: %default]"))
    op.add_option('--XTurbVisRatio', dest='TurbVisRatio', default=1.00,
                  type='float',
                  help=("relative uncertainty in turbulent-to-laminar "
                        "viscosity ratio at the throat. "
                        "[default: %default]"))
    op.add_option('--XTurbIntensity', dest='TurbInten', default=0.8,
                  type='float', 
                  help=("relative uncertainty in turbulence intensity "
                        "at the throat. [default: %default]"))
    op.add_option('--XCoreRadiusFraction', dest="coreRfraction", default=0.05,
                  type='float',
                  help=("relative uncertainty in the core flow radius "
                        "fraction. [default: %default]")) 
    op.add_option('--ForebodyAngle',dest='fbAngle', default=6.0, type='float',
                  help=("Angle of forebody relative to nozzle axis in "
                        "degrees [default: %default]"))
    op.add_option('--XForebodyAngle',dest='XfbAngle', default=0.0167, type='float',
                  help=("relative uncertainty in the forebody angle "
                        "[default: %default]"))
    opt, args = op.parse_args()
 
    # Convert to integer
    opt.levels = int(opt.levels)

    # Check to see if the "forebody_conditions.dat" file exists in
    # the current directory. If it does, we delete it..
    if os.path.exists("forebody_conditions.dat"):
        run_command('rm forebody_conditions.dat')

    # Read the sensitivity_case_summary file to get the perturbed
    # variables and their various values
    perturbedVariables, DictOfCases = read_case_summary()
    
    # Add the forebody angle to the list of perturbed variables
    # and to the DictOfCases. We also add two cases which represent
    # the perturbation of the forebody angle
    perturbedVariables.append('fbAngle')
    for k in DictOfCases.keys():
        DictOfCases[k].append(opt.fbAngle)
    DictOfCases['case091'] = copy.copy(DictOfCases['case000'])
    DictOfCases['case091'][-1] = opt.fbAngle*1.01
    DictOfCases['case092'] = copy.copy(DictOfCases['case000'])
    DictOfCases['case092'][-1] = opt.fbAngle*0.99
    
    # Create a dictionary of the relative uncertainties of each 
    # variable that may have been perturbed
    inputUncertainties = {'p1':opt.p1, 'T1':opt.T1, 'Vs':opt.Vs, 'pe':opt.pe,
                          'Tw':opt.Tw, 'TurbVisRatio':opt.TurbVisRatio,
                          'TurbInten':opt.TurbInten, 'BLTrans':opt.BLTrans,
                          'CoreRadiusFraction':opt.coreRfraction,
                          'fbAngle':opt.XfbAngle}
    
    # Define the name of the nominal case and load the exit plane data
    nominal = 'case000'
    nominalData, exitVar = read_nenzfr_outfile('./'+nominal+'/'+\
                                               opt.exitStatsFileName)
    
    # Define the file name for gas model
    gmodelFile = read_gmodelFile_from_config('./'+nominal+'/'+opt.jobName)
    if not os.path.exists(gmodelFile):
        run_command('cp ./'+nominal+'/'+gmodelFile+' ./')
    
    # Calculate forebody flow properties for nominal condition 
    fbNomData, fbVar = calculate_forebody(nominalData, \
                    DictOfCases[nominal][-1], gmodelFile)
    # Write out the data to summary file 
    write_forebody_summary(fbNomData, fbVar, nominal) 
    
    nominalValues = get_values(fbNomData, fbVar)
    
    # Loop through each of the perturbed variables
    sensitivity = {}
    sensitivity_abs = {}
    uncertainty = {}
    for k in range(len(perturbedVariables)):
        var = perturbedVariables[k]
        
        if var == 'CoreRadiusFraction':
            perturb_CoreRadiusFraction(var, perturbedVariables,\
                                       DictOfCases, opt.levels)
        # Define the name of the relevant perturbed cases and load the 
        # associated data
        if var not in ['fbAngle']:
            high = 'case'+"{0:02}".format(k)+'1'
            highData, dontNeed  = read_nenzfr_outfile('./'+high+'/'+\
                                                      opt.exitStatsFileName)
            fbHighData, dontNeed = calculate_forebody(highData, \
                                          DictOfCases[high][-1], gmodelFile)
            # Write out the data to summary file
            write_forebody_summary(fbHighData, fbVar, high)
            
            low = 'case'+"{0:02}".format(k)+'2'
            lowData, dontNeed = read_nenzfr_outfile('./'+low+'/'+\
                                                    opt.exitStatsFileName)
            fbLowData, dontNeed = calculate_forebody(lowData, \
                                         DictOfCases[low][-1], gmodelFile)
            # Write out the data to summary file
            write_forebody_summary(fbLowData, fbVar, low)
            
        else: 
            # For perturbation of fb_angle we just use the nominalData and
            # calculate forebody properties with a different angle
            high = 'case'+"{0:02}".format(k)+'1'
            fbHighData, dontNeed = calculate_forebody(nominalData, \
                                         DictOfCases[high][-1], gmodelFile)
            # Write out the data to summary file
            write_forebody_summary(fbHighData, fbVar, high)
            
            low = 'case'+"{0:02}".format(k)+'2'
            fbLowData, dontNeed = calculate_forebody(nominalData, \
                                         DictOfCases[low][-1], gmodelFile)
            # Write out the data to summary file
            write_forebody_summary(fbLowData, fbVar, low)
        
        # Values of the freestream properties at the perturbed conditions
        highValues = get_values(fbHighData,fbVar)
        lowValues = get_values(fbLowData,fbVar)
        # Values of the perturbed input values
        highX = DictOfCases[high][perturbedVariables.index(var)]
        lowX = DictOfCases[low][perturbedVariables.index(var)]
        nominalX = DictOfCases[nominal][perturbedVariables.index(var)]
   
        if opt.levels == 3: 
            # As the perturbations may not be centered on the nominal
            # condition we caculate the gradient by taking a weighted
            # average of the forward and backward derivatives. The 
            # weightings are such that the truncation error associated 
            # with this gradient estimate is O(3) or higher (i.e. the 
            # weightings are such that the second order terms in the Taylor 
            # series expansion cancel. Thanks to D.Petty for this theory.)
            highWeighting = (nominalX - lowX)/(highX - lowX)
            lowWeighting = (highX - nominalX)/(highX - lowX)
            
            sensitivity_abs[var] = ( highWeighting*(array(highValues)-\
                                                array(nominalValues))/\
                                               (highX - nominalX) + \
                                 lowWeighting*(array(nominalValues)-\
                                               array(lowValues))/\
                                              (nominalX - lowX)     )
            sensitivity[var] = sensitivity_abs[var]*nominalX/array(nominalValues)
            
        else:
            # For 5 levels per variable we have additional cases 
            # that need to be loaded. Again we do not assume that
            # the levels are equally spaced around the nominal. 
            # The weightings are such that the truncation error 
            # associated with this estimate is O(4) or higher.
            if var not in ['fbAngle']:
                tooHigh = 'case'+"{0:02}".format(k)+'3'
                tooHighData,dontNeed = \
                      read_nenzfr_outfile('./'+tooHigh+'/'+opt.exitStatsFileName)
                fbTooHighData,dontNeed = calculate_forebody(tooHighData, \
                                            DictOfCases[tooHigh][-1], gmodelFile)
                # Write out the data to summary file
                write_forebody_summary(fbTooHighData, fbVar, tooHigh)
                
                tooLow = 'case'+"{0:02}".format(k)+'4'
                tooLowData,dontNeed = \
                      read_nenzfr_outfile('./'+tooLow+'/'+opt.exitStatsFileName)
                fbTooLowData,dontNeed = calculate_forebody(tooLowData, \
                                            DictOfCases[tooLow][-1], gmodelFile)
                # Write out the data to summary file
                write_forebody_summary(fbTooLowData, fbVar, tooLow)
            else:
                # For perturbation of fb_angle we just use the nominalData and
                # calculate forebody properties with a different angle
                tooHigh = 'case'+"{0:02}".format(k)+'1'
                fbTooHighData, dontNeed = calculate_forebody(nominalData, \
                                           DictOfCases[tooHigh][-1], gmodelFile)
                # Write out the data to summary file
                write_forebody_summary(fbTooHighData, fbVar, tooHigh)

                tooLow = 'case'+"{0:02}".format(k)+'2'
                fbTooLowData, dontNeed = calculate_forebody(nominalData, \
                                           DictOfCases[tooLow][-1], gmodelFile)
                # Write out the data to summary file
                write_forebody_summary(fbTooLowData, fbVar, tooLow)
            
            # Values of the freestream properties at the perturbed conditions
            tooHighValues = get_values(fbTooHighData,fbVar)
            tooLowValues = get_values(fbTooLowData,fbVar)
            # Values of the perturbed input values
            tooHighX = DictOfCases[tooHigh][perturbedVariables.index(var)]
            tooLowX = DictOfCases[tooLow][perturbedVariables.index(var)]
            
            tooHighDeltaX = tooHighX - nominalX
            highDeltaX = highX - nominalX
            tooLowDeltaX = tooLowX - nominalX
            lowDeltaX = lowX - nominalX
            weighting = (tooHighX - tooLowX)/(highX - lowX)
            
            denom = 1/tooHighDeltaX - 1/tooLowDeltaX -\
                   (1/highDeltaX - 1/lowDeltaX)*weighting
            numer =  array(tooHighValues)/tooHighDeltaX**2 -\
                     array(tooLowValues)/tooLowDeltaX**2 -\
                    ( array(highValues)/highDeltaX**2 -\
                      array(lowValues)/lowDeltaX**2 )*weighting -\
                     array(nominalValues)*\
                       ( 1/tooHighDeltaX**2 - 1/tooLowDeltaX**2 - \
                         ( 1/highDeltaX**2 - 1/lowDeltaX**2 )*weighting )
            sensitivity[var] = numer/denom*nominalX/array(nominalValues) 
            sensitivity_abs[var] = numer/denom
        # Now calculate the uncertainty in each exit flow variable
        # due to the uncertainty in the current (perturbed)
        # input variable
        uncertainty[var] = sensitivity[var]*inputUncertainties[var]
   
    # Write out a file of the sensitivities
    write_sensitivity_summary(sensitivity, perturbedVariables, fbVar, '', 'relative')
    write_sensitivity_summary(sensitivity_abs, perturbedVariables, fbVar, '', 'absolute')
    
    # Write out a file of the uncertainties
    write_uncertainty_summary(uncertainty, perturbedVariables, fbVar,\
                              inputUncertainties)
    
    #--------------------------------------------------------------------------------
    # Each of the freestream properties has a total bias error associated with 
    # the convergence of the grid, the spatial variation of the exit flow over the 
    # core region and the use of a response surface. 
    #
    # In order to be able to propagate these bias errors through to the forebody 
    # properties we need to calculate the sensitivities of each forebody property to
    # each freestream property.
    #
    sensitivity_fb_to_fs = {}
    sensitivity_fb_to_fs_abs = {}
    varList = []
    #print exitVar
    #print nominalData
    exclude_list = ['rho','mu','k[0]','M_local','pitot_p','total_p','total_h','dt_chem',
                    'e[0]','a','omega','tke','k_t','mu_t']
    # Loop over each freestream variable
    for k in range(len(exitVar)):
        var = exitVar[k]
        
        if var not in exclude_list:
            varList.append(var)
            # Values of the perturbed freestream values
            highX = nominalData[var]*1.02
            lowX =  nominalData[var]*0.98
            nominalX = nominalData[var]
            
            # Create a copy of the nominal data and up-date the relevant variable with the
            # perturbed value
            highData = copy.copy(nominalData); highData[var] = highX
            lowData = copy.copy(nominalData);  lowData[var] = lowX
            #print "var=",var,";  highX=",highX,";  nominalX=",nominalX,";  lowX=",lowX
            
            # Now calculate the forebody conditions
            theta = DictOfCases[nominal][-1] # forebody angle
            fbHighData, dontNeed = calculate_forebody(highData, theta, gmodelFile)
            fbLowData, dontNeed = calculate_forebody(lowData, theta, gmodelFile)
            
            #print fbHighData 
            highValues = get_values(fbHighData, fbVar)
            lowValues = get_values(fbLowData, fbVar) 
            #print nominalValues
            #print fbVar
            
            #assert -1 > 0
            # Now calculate the sensitivity
            if nominalX != 0.0:
                highWeighting = (nominalX - lowX)/(highX - lowX)
                lowWeighting = (highX - nominalX)/(highX - lowX)

                sensitivity_fb_to_fs_abs[var] = ( highWeighting*(array(highValues)-\
                                                    array(nominalValues))/\
                                                   (highX - nominalX) + \
                                     lowWeighting*(array(nominalValues)-\
                                                   array(lowValues))/\
                                                  (nominalX - lowX)     )
                sensitivity_fb_to_fs[var] = sensitivity_fb_to_fs_abs[var]*nominalX/array(nominalValues)
            else:
                sensitivity_fb_to_fs_abs[var] = array(nominalValues)*float('nan')
                sensitivity_fb_to_fs[var] = array(nominalValues)*float('nan')
    #print "perturbed variables, varList=",varList
    #print 
    #print "forebody variables, fbVar=",fbVar
    #print
    #print sensitivity_fb_to_fs
    #print 
    # Write out a summary file
    write_sensitivity_summary(sensitivity_fb_to_fs, varList, fbVar,\
                              'fb_to_fs_','relative')
    write_sensitivity_summary(sensitivity_fb_to_fs_abs, varList, fbVar,\
                              'fb_to_fs_','absolute')
    
    #print sensitivity_fb_to_fs
        
    #print varList
        
    return 0

#---------------------------------------------------------------

if __name__ == '__main__':
    if len(sys.argv) <= 1:
        print "NENZFr Forebody Sensitivity:\n Calculate Sensitivity of Flow Properties behind an oblique shock\n based on Shock Tunnel Test Flow Conditions"
        print "   Version:", VERSION_STRING
        print "   To get some useful hints, invoke the program with option --help."
        sys.exit(0)
    return_flag = main()
    sys.exit(return_flag)
