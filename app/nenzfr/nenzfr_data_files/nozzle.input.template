# nozzle.input.template
# Supersonic part of a shock tunnel nozzle.
# Which particular nozzle is determined by the contour file.
#
# PJ, 14-Mar-2011, 19-Apr-2011,
# adapted from Rainer Kirchhartz 2009 simulation files.
# 
# LukeD June-2011, modifications include
# - a second call to estcj to produce an output summary file (requires
#   a modified version of estcj.py)
# - the option/ability to import a PointWise plot3d grid (requires a
#   modified version of e3_grid.py)
# - automatic selection of the appropriate cea-lut based on $gasName
# - automatic selection of the area_ratio for the estcj calculation 
#   based on $areaRatio
# - implementation of frozen and non-equilibrium gas models
# - introduction of air5species gas
# - adjustment of the mass fractions that are read in from CEA to ensure
#   they sum one (scale by their summation)
# - modification of the commands used to build the nozzle geometry to 
#   be appropriate for the M10 nozzle contour file
# LukeD August-2011, modifications include
# - altered how we construct the grid for the Mach 4, 6 and 8 nozzles 
#   in order to ensure that the sharp corner at the end of the throat/
#   start of the divergence section is properly captured. Number of 
#   cells and clustering in the throat block is automatically selected
#   based on the values for the divergence section.
# LukeD February-2012, modifications include
# - altered how we define throat species to use the new estcj, cea2
#   dictionaries
#
# Wilson Chan, May-2012
# - all nozzle contours are now specified using Bezier curves. The input
#   data files must contain the control points for the Bezier curves.
# - script now uses Eilmer3's PyFunctionSurface() to build grids that
#   are orthogonal to the nozzle wall and axis in the nozzle expansion
#   region.
#
#---------------------------------------------------------------------
import string, fileinput
from estcj import reflected_shock_tube_calculation as rstc
from cfpylib.gasdyn.cea2_gas import Gas, make_gas_from_name
from operator import indexOf
from cfpylib.nm.zero_solvers import secant
from string import upper, lower
from numpy import arange
from cfpylib.nm.roberts import roberts
from math import tan, atan
import os

#---------------------------------------------------------------------
# Utility functions
def round_list(list, precision):
    for k in range(len(list)):
        list[k] = round(list[k], precision)
    return list

def massFraction_check(species):
    # The mass fractions we get from CEA do not always sum to one within
    # the tolerance expected by Eilmer3. When this is the case, and the 
    # difference from one is not too great, we scale the mass fractions
    # by their summation
    #
    # NB. 'species' should be a dictionary of species names and mass
    # fractions.
    pass_flag = 0;
    massf_error = abs(1.0-sum(species.values()))
    if massf_error<=1.0e-6:
        pass_flag = 1
    elif 1.0e-6 < massf_error <= 1.0e-4:
        totalMass = sum(species.values())
        for var in species.keys():
            species[var] = species[var]/totalMass
        pass_flag = 1
    else:
        print "Mass fractions DO NOT sum to one. Error is >1.0e-4"
    if pass_flag == 1:
        return species
    else:
        return 0

#--------------------------------------------------------------------
gdata.title = "Flow through a shock tunnel nozzle."

DEBUG_flag = 0

# Shock tube conditions define flow condition at the nozzle throat.
# This throat condition is used as the input to the simulation of
# the nozzle expansion.
estc_result = rstc($gasName, $p1, $T1, $Vs, $pe, None, area_ratio=$areaRatio, task='stn')
throat = estc_result['state6']
throat_V = estc_result['V6']
print "Flow condition at nozzle throat:"
throat.write_state(sys.stdout)

# Estimate turbulence quantities for free stream
# by specifying the intensity as 0.05 and estimating the
# turbulence viscosity as 100 times the laminar viscosity.
throat_tke = 1.5 * (throat_V * $TurbInten)**2
throat_mu_t = $TurbVisRatio * throat.mu
throat_omega = throat.rho * throat_tke / throat_mu_t
print "Inflow turbulence: tke=", throat_tke, "omega=", throat_omega


gastype = $gasName
if gastype in ['n2', 'N2']:
    gastype = upper(gastype)
if DEBUG_flag:
    print "Test gas is "+gastype


# Define the temperature and pressure of the intial gas sitting in the nozzle/
# dump tank
initial = {};
initial['p'] = 106.4;
initial['T'] = 300.0;

if gastype in ['air', 'Air']:
    #
    # Test gas is Air (CEA species)
    #

    # Equilibrium...
    if $chemModel in ['eq']:
        print 60*'-'
        print "Nozzle expansion uses Equilibrium Air (CEA LUT)"
        print 60*'-'

        select_gas_model(fname="cea-lut-air.lua.gz")
        throat_massf = [1.,]
        initial_massf = [1.,]
    
    # Non-equilibrium or Frozen...
    elif $chemModel in ['neq','frz','frz1']:  
        # Change to an air5species model for the nozzle expansion.
        gasState = make_gas_from_name('air5species')
        gasState.set_pT(p=throat.p, T=throat.T)
        select_gas_model(model='thermally perfect gas', species=gasState.onlyList)        

        #
        # The species have changed across the throat due to CEA air considering a wider
        # range of species than the 5 we must now consider for the nozzle calculation. 
        # Therefore assume that the pressure is constant and adjust the temperature at 
        # the throat to conserve the mass, momentum and energy fluxes.
        #
        print 60*"-"
        print "Changing from CEA air to 5-species air mixture for nozzle calculation."
        print 60*"-"
        print "Adjusting throat temperature to conserve mass, momentum and energy."
        def enthalpy_error(x, p1=throat.p, h1=throat.h, a1=throat.a, state=gasState):
            state.set_pT(p=p1, T=x)
            return state.e + state.R*x - h1
        new_T = secant(enthalpy_error, 0.9*throat.T, 1.1*throat.T, tol=0.002/100*throat.h)
        if new_T in ['Fail','FAIL',]:
            print "Failed to find throat temperature for which the 5-species mixture conserves mass, momentum and energy"
            new_T = throat.T
        print 'New throat temperature: ', new_T

        gasState.set_pT(p=throat.p, T=new_T)
        
        # Some checks...
        print 'Enthalpy CEA air: ', throat.h
        print 'Enthalpy 5-species air: ', gasState.h
        print 'Enthalpy error: ', gasState.h - throat.h
        print 'Enthalpy percent error: ', (gasState.h - throat.h)/throat.h*100
        print 'Mass flux CEA air: ', throat.rho*throat.a
        print 'Mass flux 5-species air: ', gasState.rho*gasState.a
        print 'Mass flux error: ', gasState.rho*gasState.a - throat.rho*throat.a
        print 'Mass flux percent error: ', (gasState.rho*gasState.a - throat.rho*throat.a)/(throat.rho*throat.a)*100
        print 'Momentum flux CEA air: ', throat.p + throat.rho*throat.a**2
        print 'Momentum flux 5-species air: ', gasState.p + gasState.rho*gasState.a**2
        print 'Momentum flux error: ', gasState.p + gasState.rho*gasState.a**2 - throat.p - throat.rho*throat.a**2
        print 'Momentum flux percent error: ', (gasState.p + gasState.rho*gasState.a**2 - throat.p - throat.rho*throat.a**2)/\
                                 (throat.p + throat.rho*throat.a**2)*100

        if $chemModel in ['frz']:
            print 60*"-"
            print "Nozzle expansion uses Frozen Air (5 species)"
            print 60*"-"
        else:
            print 60*"-"
            print "Nozzle expansion uses Non-Equilibrium Air (5 species)"
            print 60*"-"
            set_reaction_update('gupta_etal_air_reactions.lua')
            
            # Check that the reaction file is present in the current working directory
            if not os.path.exists('gupta_etal_air_reactions.lua'):
                fp = open(os.path.expandvars('$HOME/cfcfd3/lib/gas/reaction-schemes/air/gupta_etal_air_reactions.lua'),'r')
                fout = open('./gupta_etal_air_reactions.lua','w')
                for line in fp.readlines():
                    items = line.strip().split()
                    if len(items)>0 and items[0] == 'NO_SPECIES' and items[-1] is not 5:
                        fout.write('NO_SPECIES = 5\n')
                    else:
                        fout.write('%s' % line)
                fout.close()
        
        print "Flow species at nozzle throat:"
        print "Note that if required, the equilibrium massf values have been scaled by their summation"
        gasState.species = massFraction_check(gasState.species)
        throat_massf = gasState.get_fractions(gasState.onlyList)
        print gasState.species
        
        # Define the composition for the gas initially in the nozzle/dump tank
        gasState.set_pT(p=initial['p'], T=initial['T'])
        initial_massf = gasState.get_fractions(gasState.onlyList)
        print "Initial flow species:"
        print gasState.species

    # Frozen-2...    
    elif $chemModel in ['frz2']:
        # Use CEA species present at the throat and perform a frozen calculation. At standard
        # conditions CEA air is assumed to be formed from those species given in the basicSpecies
        # list (see NASA RP-1311-P2 pg. 84)
        basicSpecies = ['N2','O2','Ar','CO2']
        for var in basicSpecies:
            if not sum( array(throat.species.keys())==var )==1:
                throat.species[var] = 0.0
        select_gas_model('thermally perfect gas', species=throat.species.keys())
        
        print 60*"-"
        print "Nozzle expansion uses Frozen Air (CEA species)"
        print 60*"-"
        print "Flow species at nozzle throat:"
        print "Note that if required, the equilibrium massf values have been scaled by their summation"
        throat.species = massFraction_check(throat.species)
        throat_massf = throat.get_fractions(throat.species.keys())
        print throat.species
        
        # Define the composition for the gas initially in the nozzle/dump tank
        gasState = make_gas_from_name('air')
        gasState.set_pT(p=initial['p'], T=initial['T'])
        initial_massf = gasState.get_fractions(throat.species)
        print "Initial flow species:"
        print gasState.species

elif gastype in ['air5species', 'N2']:
    #
    # Test gas is either 5-species Air or 2-species Nitrogen
    #

    # Frozen or Non-equilibrium...
    if $chemModel not in ['eq']:
        select_gas_model(model='thermally perfect gas', species=throat.onlyList)
        
        if $chemModel in ['frz','frz2']:
            print 60*"-"
            print "Nozzle expansion uses Frozen "+gastype
            print 60*"-"
        else:
            print 60*"-"
            print "Nozzle expansion uses Non-equlibrium "+gastype
            print 60*"-"
            
            if gastype in ['air5species']:
                set_reaction_update('gupta_etal_air_reactions.lua')
                # Check that the reaction file is present in the current directory
                if not os.path.exists('gupta_etal_air_reactions.lua'):
                    fp = open(os.path.expandvars('$HOME/cfcfd3/lib/gas/reaction-schemes/air/gupta_etal_air_reactions.lua'),'r')
                    fout = open('./gupta_etal_air_reactions.lua','w')
                    for line in fp.readlines():
                        items = line.strip().split()
                        if len(items)>0 and items[0] == 'NO_SPECIES' and items[-1] is not 5:
                            fout.write('NO_SPECIES = 5\n')
                        else:
                            fout.write('%s' % line)
                    fout.close()
            else:
                set_reaction_update('nitrogen-5sp-6r.lua')
                # Check that the reaction file is present in the current directory
                if not os.path.exists('nitrogen-5sp-6r.lua'):
                    fp = open(os.path.expandvars('$HOME/cfcfd3/lib/gas/reaction-schemes/nitrogen/nitrogen-5sp-6r.lua'),'r')
                    fout = open('./nitrogen-5sp-6r.lua','w')
                    for line in fp.readlines():
                        items = line.strip().split()
                        if len(items)>0 and items[0] == 'WITH_IONIZATION' and items[-1] is not 'false':
                            fout.write('WITH_IONIZATION = false\n')
                        else:
                            fout.write('%s' % line)
                    fout.close()
        
        print "Flow species at nozzle throat:"
        print "Note that if required, the equilibrium massf values have been scaled by their summation"
        throat.species = massFraction_check(throat.species)
        throat_massf = throat.get_fractions(throat.onlyList)
        print throat.species
            
        # Define the composition for the gas initially in the nozzle/dump tank
        gasState = make_gas_from_name(lower(gastype))
        gasState.set_pT(p=initial['p'], T=initial['T'])
        initial_massf = gasState.get_fractions(gasState.onlyList)
        print "Initial flow species:"
        print gasState.species
      
    # Equilibrium...
    else:
        print 60*"-"
        print "Nozzle expansion uses Equilibrium "+gastype
        print 60*"-"
    
        select_gas_model(fname="cea-lut-"+gastype+".lua.gz")
        throat_massf = [1.,]
        initial_massf = [1.,]
else:
    print "Unknown gas type specified"


# Now set the inflow and intial flow conditions
inflow=FlowCondition(p=throat.p, u=throat_V, v=0.0, T=throat.T,
                       massf=throat_massf, tke=throat_tke,
                       omega=throat_omega)
initial=FlowCondition(p=initial['p'], u=0.0, v=0.0, T=initial['T'],
                       massf=initial_massf, tke=0.0, omega=1.0,
                       label="initial")


# When no gridFileName is given we use the provided (or default) contourFile
if $gridFileName in ['None']:
    # Read in file for the particular nozzle.
    x_c = []; y_c = []
    fp = open($contourFileName, 'r')
    for line in fp.readlines():
        items = line.strip().split()
        if len(items) == 0: continue  # skip blank lines
        if items[0] == '#': continue  # skip header lines
        x_c.append(float(items[0]))
        y_c.append(float(items[1]))
    
    # Bezier control points that make up the nozzle contour. 
    if $contourFileName in ['Bezier-control-pts-t4-m8.data',\
                            'Bezier-control-pts-t4-m10.data']:
        # For the T4 Mach 8 and Mach 10 nozzles, the control points 
        # start from the first pair of coordinates in the given data 
        # file.
        bezCtrlPts = [Vector(x_c[i],y_c[i]) for i in range(len(x_c))]
    else:
        # The first pair of coordinates in the given data file for 
        # the other nozzles are not Bezier control points.
        bezCtrlPts = [Vector(x_c[i],y_c[i]) for i in range(1, len(x_c))]
    
    # Create nodes
    if $contourFileName in ['Bezier-control-pts-t4-m10.data']:
        Lthr = 0.010
        Lnoz = 1.633197
    else:
        Lthr = y_c[0]
        Lnoz = x_c[-1]
    throat_axis = Node(-Lthr, 0.0) 
    throat_wall = Node(-Lthr, y_c[0])
    divergence_axis = Node(0.0, 0.0)
    divergence_wall = Node(0.0, y_c[0])
    nozzle_end_axis = Node(x_c[-1], 0.0)
    nozzle_end_wall = Node(x_c[-1], y_c[-1])
        
    # Define the lines making up the patch for the throat ..
    t_south = Line(throat_axis, divergence_axis)
    t_north = Line(throat_wall, divergence_wall)
    t_west = Line(throat_axis, throat_wall)
    t_east = Line(divergence_axis, divergence_wall)
    # .. and the expansion region.
    if $contourFileName in ['Bezier-control-pts-t4-m7.data',\
                            'Bezier-control-pts-t4-m8.data',\
                            'Bezier-control-pts-t4-m10.data']:
        n_north = Bezier(bezCtrlPts)
        
        # For the Mach 10 nozzle the Bezier curve is longer than 
        # the actual nozzle so we must truncate it.
        if $contourFileName in ['Bezier-control-pts-t4-m10.data']:
            def truncate_time(x, curve=n_north, L=Lnoz):
                return curve.eval(x).x - L
            tstar = secant(truncate_time,0.5,0.6,tol=1.0e-6,limits=[0.0,1.0])
            n_north.t1 = tstar
            # Redefine relevant nodes for nozzle exit
            nozzle_end_axis = Node(n_north.eval(1.0).x,0.0)
            nozzle_end_wall = Node(n_north.eval(1.0).x,n_north.eval(1.0).y) 
    else:
        n_north = Polyline([Line(divergence_wall,bezCtrlPts[0]), Bezier(bezCtrlPts)])
    n_west = Line(divergence_axis, divergence_wall)
    n_east = Line(nozzle_end_axis, nozzle_end_wall)
    
    # Write out the nozzle area ratio 
    area_ratio = (n_north.eval(1).y/n_north.eval(0).y)**2
    print "nozzle area ratio=", area_ratio

    # Define the expansion_region using a specialised Surface Function.
    # For viscous simulations, it is necessary to keep the cells near
    # the non-slip walls as orthogonal to the walls as possible. However,
    # because the "AO" option in make_patch() does not give a grid that is 
    # good enough for the nozzle geometry, a specialised surface function
    # has to be used. Points in the grid along the north, east and west
    # edges follow that specified by n_north, n_east and n_west. The rest
    # of the other points in the grid are built by creating strips of 
    # quadratic Bezier curves that run from the nozzle wall to the axis.
    # The use of quadratic Bezier curves allows the generated points to
    # be orthogonal to the wall near the nozzle wall and orthogonal to
    # the axis near the axis.
    def make_expansion_region_grid(r, s):
        global n_north, n_west, n_east
        if r == 0.0:
            x = n_north.eval(r).x
            y = n_west.eval(s).y
        elif r == 1.0:
            x = n_north.eval(r).x
            y = n_east.eval(s).y
        elif s == 1.0:
            x = n_north.eval(r).x
            y = n_north.eval(r).y
        else:
            # Wall point (Bezier control point 1)
            wall_pt_x = n_north.eval(r).x
            wall_pt_y = n_north.eval(r).y
            # Angle perpendicular to the wall at wall point
            wall_angle = atan((n_north.eval(r+0.0001).y - n_north.eval(r-0.0001).y) /\
                              (n_north.eval(r+0.0001).x - n_north.eval(r-0.0001).x))
            # If the expansion region starts sharply from the throat, then we
            # need some way of transitioning from the grid in the throat region
            # to the expansion region. To do so, we tweak the wall_angle in a
            # small starting region in the nozzle (say, 2% of the length of the
            # expansion region). The wall_angle starts from 0 degrees at the
            # start of this small region and smooths it out to the actual
            # wall_angle at the end of this small region.
            north_length = n_north.eval(1.0).x - n_north.eval(0.0).x
            if (n_north.eval(r).x - n_north.eval(0.0).x) <= (0.02 * north_length):
                wall_angle = (n_north.eval(r).x - n_north.eval(0.0).x) / \
                             (0.02 * north_length) * wall_angle
            # Do the same for a small region at the end of the nozzle. This is
            # to accommodate to nozzles that have been a non-zero gradient at
            # at the nozzle exit (which is brought about by nozzle truncation).
            if (n_north.eval(r).x - n_north.eval(0.0).x) >= (0.98 * north_length):
                wall_angle = (n_north.eval(1.0).x - n_north.eval(r).x) / \
                             (0.02 * north_length) * wall_angle
            # Mid point (Bezier control point 2).
            mid_pt_y = n_north.eval(r).y / 2.0
            mid_pt_x = wall_pt_x + (mid_pt_y * tan(wall_angle))
            # Axis point (Bezier control point 3).
            axis_pt_x = mid_pt_x
            axis_pt_y = 0.0
            # Generate t for quadratic Bezier curve equation.
            t = (1.0 - s)
            # Generate point on quadratic Bezier curve.
            x = (1-t)*(1-t)*wall_pt_x + 2*t*(1-t)*mid_pt_x + t*t*axis_pt_x
            y = (1-t)*(1-t)*wall_pt_y + 2*t*(1-t)*mid_pt_y + t*t*axis_pt_y
        return (x, y, 0.0)
    #
    expansion_region = PyFunctionSurface(make_expansion_region_grid)    

    # Define the clustering and grid resolution parameters for the "nozzle_blk". 
    # We define these here like this as they may be needed to define the 
    # "throat_blk" for the Mach 4, 6 and 8 nozzles
    nnj = $nnj   # number of radial cells
    nni = $nni   # number of axial cells
    nbi = $nbi   # number of axial blocks for the divergence section (nozzle_blk)
    nbj = $nbj   # number of radial blocks
    bx = $bx     # clustering in the axial direction
    by = $by     # clustering in the radial direction
    if $contourFileName in ['Bezier-control-pts-t4-m7.data',\
                            'Bezier-control-pts-t4-m8.data',\
                            'Bezier-control-pts-t4-m10.data']:
        # To accomodate for the natural clustering induced by the Bezier curves
        # for these nozzle we only cluster towards the nozzle exit.
        x_clust = RobertsClusterFunction(0, 1, bx)
    else:
        x_clust = RobertsClusterFunction(1, 1, bx)
    y_clust = RobertsClusterFunction(0, 1, by)
    cf_list = [x_clust, y_clust, x_clust, y_clust]

    # Define boundary conditions
    Twall = $Tw
    bc_list = [FixedTBC(Twall), ExtrapolateOutBC(), SlipWallBC(), SupInBC(inflow)]

    # Now, we also make a block for the throat region. We must define this
    # block here BEFORE the "nozzle_blk" in order to ensure that the blocks are
    # numbered in sequence in order to allow space-marching in the simulation.
    #
    # The number of cells in the axial direction and clustering for
    # this block are automatically calculated based on the clustering and 
    # resolution of "nozzle_blk" as specified above. We try to ensure that the 
    # spacing across the interface of the "throat_blk" and "nozzle_blk" is even
    # and an appropriate number of cells/blocks are used in the throat.
    #     Luke D. 21-Aug-2011
    throat_region = make_patch(t_north, t_east, t_south, t_west)
     
    # We need to know the axial spacing of the first grid point in 
    # "nozzle_blk" in order to calculate the required clustering. 
    # The following code isn't very elegant but it works.
    delta = 1.0/float(nni) # Intial uniform spacing
    # Non-uniform spacing in logical space for the SOUTH boundary of "nozzle_blk"
    if $contourFileName in ['Bezier-control-pts-t4-m7.data',\
                            'Bezier-control-pts-t4-m8.data',\
                            'Bezier-control-pts-t4-m10.data']:
        logical_noz = roberts(arange(0.0, 1.+delta, delta), 0.0, bx)
    else:
        logical_noz = roberts(arange(0.0, 1.+delta, delta), 0.5, bx)
    # Acutal grid points
    actual_noz = [make_expansion_region_grid(r,0)[0] for r in logical_noz]
    # First cell width
    diff = make_expansion_region_grid(logical_noz[1], 0)[0]

    # Calculate the number of cells required on the NORTH/SOUTH boundaries of the 
    # "throat_blk" based on how many cells there are in the "nozzle_blk" over the 
    # same physical length. NB. If you are clustering very strongly in the x-direction 
    # (x_clust, bx specified above) you may want to include a factor here to reduce
    # the number of cells in the throat region.
    nni_throat = [indexOf(actual_noz, x) for x in actual_noz if x < Lthr][-1] + 1
    delta2 = 1./nni_throat # Intial uniform spacing
    logical_throat = arange(0.0, 1.+delta2, delta2)
            
    # Define a function which calculates the difference in the grid
    # spacing on either side of the "throat_blk"/"nozzle_blk" boundary
    def spacing_error(x, L=Lthr, diff=diff, orig=logical_throat):
        new = L * roberts(orig, 0.5, x)
        return (new[1]-new[0] - diff)/diff
    bx_throat = secant(spacing_error, 1.0001, 1.002, tol=1.0e-2,\
                      limits=[1.0001,5])
    if bx_throat in ['Fail','FAIL',]:
        print "Failed to find throat clustering parameter"
        print "Setting bx_throat == bx"
        bx_throat = bx
    # Infer the number of blocks from how many we set for "nozzle_blk"
    nbi_throat = int(round(float(nbi)/float(nni)*float(nni_throat)))
    if nbi_throat > 1:
        nbi_throat = nbi_throat - 1
    # We need at least 1 block for the throat region
    if nbi_throat < 1:
        nbi_throat = 1
    
    # Display the calculated data
    print "nni_throat=",nni_throat
    print "nbi_throat=",nbi_throat
    print "Clustering, bx_throat=",bx_throat 
    
    # Now set the clustering and define the "throat_blk"
    x_clust_throat = RobertsClusterFunction(1, 1, bx_throat)
    cf_list_throat = [x_clust_throat, y_clust, x_clust_throat, y_clust]
    
    # Now define the throat block
    throat_blk = SuperBlock2D(throat_region, nni=nni_throat, nnj=nnj,
                              nbi=nbi_throat, nbj=nbj, 
                              bc_list=bc_list, cf_list=cf_list_throat, 
                              fill_condition=initial, label="throat")
    
    # Finally, define the main nozzle block
    nozzle_blk = SuperBlock2D(expansion_region, nni=nni, nnj=nnj,
                              nbi=nbi, nbj=nbj,
                              bc_list=bc_list, cf_list = cf_list,
                              fill_condition=initial, label="nozzle")
    #
    identify_block_connections()

else:
    print "Importing specified grid...." 
    scaleFactor = 1000.0 # Use this to alter the dimensions of your grid
    importedGrid = read_plot3d_grid_from_pointwise($gridFileName, 3, scaleFactor)
    nblocks =  len(importedGrid)
    print "Finished importing grids."
    print "Sanity check .. number of block = ", nblocks
    
    # Define the blocks, boundary conditions
    blockList = []
    
    Twall = $Tw
    for count in range(nblocks):
       blk = Block2D(nni=importedGrid[count].ni-1, nnj=importedGrid[count].nj-1,
                     # minus 1 for nni because nni=number-of-cell-centres & ni=number-of-nodes
                     fill_condition=initial, label="block-"+str(count), 
                     grid=importedGrid[count],
                     bc_list=[FixedTBC(Twall), SlipWallBC(), # NORTH, EAST, SOUTH, WEST
                              SlipWallBC(), SlipWallBC()])
       # Attach 1 block of the imported multi-block grid
       #blk.attach_grid(importedGrid[count])
       # Append block to list of blocks
       blockList.append(blk)
    blockList[0].bc_list[WEST] = SupInBC(inflow)
    blockList[nblocks-1].bc_list[EAST] = ExtrapolateOutBC()
     
    identify_block_connections()

    
# Define the turbulent portion of the nozzle
point0=Vector($BLTrans, 0.000, 0.000)
point1=Vector(x_c[-1]*2.0, y_c[-1]*2.0, 0.000)
TurbulenceZone(point0, point1, label="Turbulent")
    
# Attributes for the space-marching simulation.
gdata.dimensions = 2
gdata.sequence_blocks = $seq_blocks
gdata.axisymmetric_flag = 1
gdata.viscous_flag = 1
gdata.flux_calc = ADAPTIVE
gdata.max_time = $max_time  # seconds
gdata.max_step = $max_step
gdata.dt = 0.2e-9
gdata.cfl = 0.4
gdata.cfl_count = 5
gdata.dt_plot = 0.04e-3
gdata.dt_history = 10.0e-6
gdata.turbulence_flag = 1
gdata.turbulence_model = 'k_omega'

sketch.xaxis(0.0, 1.2, 0.1, 0.)
sketch.yaxis(0.0, 0.4, 0.1, 0.)
sketch.window(0.0, 0.0, 1.0, 1.0, 0.015, 0.015, 0.15, 0.15)
