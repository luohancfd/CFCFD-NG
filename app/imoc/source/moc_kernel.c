/** \file moc_kernel.c
 * \ingroup imoc
 * \brief Method-of-Characteristics program, 1998, 1999
 *
 * This set of functions forms the computational and
 * data storage kernel for the MOC program.
 * Interaction with the user is handled by the set of
 * Tcl/Tk wrapper functions generated by SWIG.
 * The wrapper functions are set up such that they have the
 * same Tcl command name as the C function name.  
 * The Tcl commands also accept the same number and type of
 * formal arguments and return the same type of result
 * as the corresponding C function.
 *
 * \author PA Jacobs
 *
 * \version 26-Sep-1998 : Initial hack
 * \version 01-Jan-1999 : resumed work
 * \version 07-Jan-2000 : Added Mach-number<--> Prandtl-Meyer conversion
 *               when storing node data
 * \version 09-Jan-2000 : Added CZeroUp and CZeroDown fields.
 * \version 17-Jan-2000 : Split ListNodesNear into two parts (the new one 
 *               is FindNodesNear().
 * \version 17-Sep-2000 : Rename SetGamma, SetDebugLevel, SetAxiFlag (add _C)
 *
 */

/*-----------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "moc_kernel.h"
#include "moc_gasdynamic.h"

/*-----------------------------------------------------*/

/*
 * We shall store the flow-field data in 
 * an array of NodeData structures.
 */
#define MAX_NODES 1000
struct NodeData *Node[MAX_NODES];  /* Just an array of pointers */
int NumberOfNodes;              /* Keep a count of filled nodes */

int MOCDebugLevel;
double RatioOfSpecificHeats;
double AxiSymmetric; /* 1 = axisymmetric geometry, 0 = 2D planar */

/*-----------------------------------------------------*/

/*
 * Functions to access global data variables.
 * (Readers and Writers for the variables.)
 */

/* @function */
int SetDebugLevel_C( int value ) { 
   /** 
    A value of 0 turns off debug code. <BR>
    (Available from the Tcl interpreter.) 
   */
   MOCDebugLevel = value; 
   return MOCDebugLevel;
} /* end function SetDebugLevel_C */


/* @function */
int GetDebugLevel( void ) { 
   /** 
    Used primarily in the C functions. <BR>
    (Available from the Tcl interpreter.) 
   */
   return MOCDebugLevel;
} /* end function GetDebugLevel */


/* @function */
int SetGamma_C( double value ) { 
   /** 
    Sets the ratio of specific heats.  
    For air, use a value of 1.4. 
    <BR>
    (Available from the Tcl interpreter.) 
   */
   RatioOfSpecificHeats = value; 
   return MOC_OK;
} /* end function SetGamma_C */


/* @function */
double GetGamma( void ) { 
   /**
    Returns the currently set ratio of specific heats. <BR>
    (Available from the Tcl interpreter.) 
   */
   return RatioOfSpecificHeats;
} /* end function GetGamma */


/* @function */
int SetAxiFlag_C( int value ) { 
   /** 
    A value of 0 indicates 2D planar flow, 
    and a value of 1 indicates axisymmetric flow.
    The axis of symmetry is along the x-axis. <BR>
    (Available from the Tcl interpreter.) 
    */
   AxiSymmetric = value; 
   return MOC_OK;
} /* end function SetSetAxiFlag_C */


/* @function */
int GetAxiFlag( void ) { 
   /** 
    Returns 0 for 2D planar flow, 1 for axisymmetric flow. <BR>
    (Available from the Tcl interpreter.) 
    */
   return AxiSymmetric;
} /* end function GetAxiFlag */


/* @function */
int GetNumberOfNodes( void ) { 
   /** 
    Returns the number of nodes with valid data. <BR>
    (Available from the Tcl interpreter.) 
    */
   return NumberOfNodes;
} /* end function GetNumberOfNodes */


/* @function */
int ValidNode( int id ) {
   /** 
    Returns a value of 1 if the node id is within range 
    and the pointer is valid, 0 otherwise. <BR>
    (Available from the Tcl interpreter.) 
    */
   if ( id >= MAX_NODES ) return NO; 
   if ( Node[id] != NULL ) {
      return YES;
   } else {
      return NO;
   } /* end if */
} /* end function ValidNode */

/*-----------------------------------------------------*/

/*
 * Initialisation function
 */

/* @function */
int InitMOC( void ) {
   /**
    Called by the Tcl initialization procedure to set up the
    data storage and the initial value of some of the kernel 
    variables. <BR>
    (Available from the Tcl interpreter.) 
   */
   int i;

   MOCDebugLevel = 0;

   NumberOfNodes = 0;
   for ( i = 0; i < MAX_NODES; ++i ) {
      Node[i] = (struct NodeData *) NULL;
   } /* end for */

   RatioOfSpecificHeats = 1.4;
   AxiSymmetric = NO;

   return MOC_OK;
} /* end function InitMOC */

/*-----------------------------------------------------*/

/*
 * Basic manipulation functions for a node.
 */

/* @function */
int CreateNode( int id ) {
   /**
    Input: <BR>
    id <  0 : Select the next available location.<BR>
    id >= 0 : Use a specific location.<BR>
    Output: <BR>
    Returns the index of the created node.
    A value of -1 is returned on failure.<BR>
    (Available from the Tcl interpreter.) 
    */
   int foundSpace;

   if ( id > MAX_NODES ) return MOC_ERROR;

   if ( id < 0 ) {
      /* 
       * Search for first available space in the pointer array
       * and put the new node there. 
       */
      foundSpace = NO;
      for ( id = 0; id < MAX_NODES; ++id ) {
         if ( Node[id] == NULL ) {
            foundSpace = YES;
            break;
         } /* end if */
      } /* end for */

      if ( foundSpace == NO ) {
         if ( MOCDebugLevel >= 1 ) {
            printf( "Node pointer array is already full.\n" );
         } /* end if */
         return -2;
      } /* end if */ 
      /*
       * At this point we have selected a new value
       * for id to store the new node's address.
       */
   } else {
      /* 
       * We have been given a specific location to
       * store the new node's address.
       * If something is already there, destroy it.
       */
      if ( Node[id] != NULL ) DeleteNode( id );
   } /* end if */  

   Node[id] = calloc(1, sizeof(struct NodeData));
   if (Node[id] != NULL) {
      /* Memory allocation was successful. */
      ++NumberOfNodes;
      Node[id]->X          = 0.0;
      Node[id]->Y          = 0.0;
      Node[id]->Nu         = 0.0;
      Node[id]->Theta      = 0.0;
      Node[id]->Mach       = 0.0;
      Node[id]->P0         = 1.0;  /* nondimensional to start */
      Node[id]->T0         = 1.0;  /* nondimensional to start */
      Node[id]->CPlusUp    = NO_NODE;
      Node[id]->CMinusUp   = NO_NODE;
      Node[id]->CZeroUp    = NO_NODE;
      Node[id]->CPlusDown  = NO_NODE;
      Node[id]->CMinusDown = NO_NODE;
      Node[id]->CZeroDown  = NO_NODE;
      return id;
   } else {
      /* CreateNode failed, memory allocation failed. */
      if ( MOCDebugLevel >= 1 ) {
         printf( "Memory allocation failed.\n" );
      } /* end if */
      return -1;
   } /* end if */
} /* end function CreateNode */


/* @function */
int DeleteNode( int id ) {
   /**
    Destroys the memory allocated to a node.
    If the node is connected to other nodes in the mesh,
    the linkages are retained between the remaining nodes. <BR>
    (Available from the Tcl interpreter.) 
    */
   int idCPlusUp, idCPlusDown;
   int idCZeroUp, idCZeroDown;
   int idCMinusUp, idCMinusDown;

   if ( id >= MAX_NODES || id < 0 ) return MOC_ERROR;

   if (Node[id] != NULL) {
      /* 
       * When removing the node from the mesh,
       * Make sure characteristic connections are maintained.
       */
      idCPlusUp   = Node[id]->CPlusUp;
      idCPlusDown = Node[id]->CPlusDown;
      if ( idCPlusUp != NO_NODE && Node[idCPlusUp] != NULL ) {
         Node[idCPlusUp]->CPlusDown = idCPlusDown;
      } /* end if */
      if ( idCPlusDown != NO_NODE && Node[idCPlusDown] != NULL ) {
         Node[idCPlusDown]->CPlusUp = idCPlusUp;
      } /* end if */

      idCZeroUp   = Node[id]->CZeroUp;
      idCZeroDown = Node[id]->CZeroDown;
      if ( idCZeroUp != NO_NODE && Node[idCZeroUp] != NULL ) {
         Node[idCZeroUp]->CZeroDown = idCZeroDown;
      } /* end if */
      if ( idCZeroDown != NO_NODE && Node[idCZeroDown] != NULL ) {
         Node[idCZeroDown]->CZeroUp = idCZeroUp;
      } /* end if */

      idCMinusUp   = Node[id]->CMinusUp;
      idCMinusDown = Node[id]->CMinusDown;
      if ( idCMinusUp != NO_NODE && Node[idCMinusUp] != NULL ) {
         Node[idCMinusUp]->CMinusDown = idCMinusDown;
      } /* end if */
      if ( idCMinusDown != NO_NODE && Node[idCMinusDown] != NULL ) {
         Node[idCMinusDown]->CMinusUp = idCMinusUp;
      } /* end if */

      /* 
       * Now destroy the node itself.
       */
      free( Node[id] );
      Node[id] = NULL; 
      --NumberOfNodes;
      return MOC_OK;
   } else {
      return MOC_ERROR;
   } /* end if */
} /* end function DeleteNode */


/* @function */
struct NodeData * GetNodePtr( int id ) {
   /**
    Returns the address of the memory allocated to the node.
    A NULL value returned indicates that the node doesn't exist
    or the index was out of range.<BR>
    For use within the C functions.
    */
   if ( id < 0 || id >= MAX_NODES ) {
      return (struct NodeData *)NULL;
   } else { 
      return (struct NodeData *)Node[id];
   } /* end if */
} /* end function GetNodePtr */

/* @function */
int SetNodeData_C( int id, char *parameter, char *valueString ) {
   /**
    Set the value for a particular node parameter.<BR>
    Input: <BR>
    id          : index to the node <BR>
    parameter   : pointer to a string specifying the parameter <BR>
    valueString : pointer to a string specifying the value <BR>
    Output: <BR>
    Returns 0 if successful, -1 on error. <BR>
    (Available from the Tcl interpreter.) 
    */
   double dvalue;
   int    ivalue;

   if ( id >= MAX_NODES || id < 0 ) return MOC_ERROR;
   if ( Node[id] == NULL ) return MOC_ERROR;

   if ( strcmp(parameter, "Mach") == 0 ) {
      dvalue = atof(valueString);
      Node[id]->Mach = dvalue;
      Node[id]->Nu   = NuFromM( dvalue, GetGamma() );
   } else if ( strcmp(parameter, "Nu") == 0 ) {
      dvalue = atof(valueString);
      Node[id]->Nu = dvalue;
      Node[id]->Mach = MFromNu( dvalue, GetGamma() );
   } else if ( strcmp(parameter, "Theta") == 0 ) {
      dvalue = atof(valueString);
      Node[id]->Theta = dvalue;
   } else if ( strcmp(parameter, "X") == 0 ) {
      dvalue = atof(valueString);
      Node[id]->X = dvalue;
   } else if ( strcmp(parameter, "Y") == 0 ) {
      dvalue = atof(valueString);
      Node[id]->Y = dvalue;
   } else if ( strcmp(parameter, "P0") == 0 ) {
      dvalue = atof(valueString);
      Node[id]->P0 = dvalue;
   } else if ( strcmp(parameter, "T0") == 0 ) {
      dvalue = atof(valueString);
      Node[id]->T0 = dvalue;
   } else if ( strcmp(parameter, "CPlusUp") == 0 ) {
      ivalue = atoi(valueString);
      Node[id]->CPlusUp = ivalue;
   } else if ( strcmp(parameter, "CMinusUp") == 0 ) {
      ivalue = atoi(valueString);
      Node[id]->CMinusUp = ivalue;
   } else if ( strcmp(parameter, "CZeroUp") == 0 ) {
      ivalue = atoi(valueString);
      Node[id]->CZeroUp = ivalue;
   } else if ( strcmp(parameter, "CPlusDown") == 0 ) {
      ivalue = atoi(valueString);
      Node[id]->CPlusDown = ivalue;
   } else if ( strcmp(parameter, "CMinusDown") == 0 ) {
      ivalue = atoi(valueString);
      Node[id]->CMinusDown = ivalue;
   } else if ( strcmp(parameter, "CZeroDown") == 0 ) {
      ivalue = atoi(valueString);
      Node[id]->CZeroDown = ivalue;
   } else {
      return MOC_ERROR; /* Unknown parameter. */
   } /* end if */

   return MOC_OK;
} /* end function SetNodeData */


/* @function */
char *GetNodeData_C( int id, char *parameter ) {
   /**
    Get the value for a particular node parameter.<BR>
    Input: <BR>
    id          : index to the node <BR>
    parameter   : pointer to a string specifying the parameter <BR>
    Output: <BR>
    Returns a pointer to the string specifying the value. <BR>
    (Available from the Tcl interpreter.) 
    */
   static char valueString[132];

   if ( id >= MAX_NODES || id < 0 ) {
      strcpy( valueString, "MOC_ERROR_Invalid_Node_Index" );
      return valueString;
   } /* end if */
   if ( Node[id] == NULL ) {
      strcpy( valueString, "MOC_ERROR_Invalid_Node" );
      return valueString;
   } /* end if */

   if ( strcmp(parameter, "Mach") == 0 ) {
      sprintf( valueString, "%g", Node[id]->Mach);
   } else if ( strcmp(parameter, "Nu") == 0 ) {
      sprintf( valueString, "%g", Node[id]->Nu);
   } else if ( strcmp(parameter, "Theta") == 0 ) {
      sprintf( valueString, "%g", Node[id]->Theta);
   } else if ( strcmp(parameter, "X") == 0 ) {
      sprintf( valueString, "%g", Node[id]->X);
   } else if ( strcmp(parameter, "Y") == 0 ) {
      sprintf( valueString, "%g", Node[id]->Y);
   } else if ( strcmp(parameter, "P0") == 0 ) {
      sprintf( valueString, "%g", Node[id]->P0);
   } else if ( strcmp(parameter, "T0") == 0 ) {
      sprintf( valueString, "%g", Node[id]->T0);
   } else if ( strcmp(parameter, "CPlusUp") == 0 ) {
      sprintf( valueString, "%d", Node[id]->CPlusUp);
   } else if ( strcmp(parameter, "CMinusUp") == 0 ) {
      sprintf( valueString, "%d", Node[id]->CMinusUp);
   } else if ( strcmp(parameter, "CZeroUp") == 0 ) {
      sprintf( valueString, "%d", Node[id]->CZeroUp);
   } else if ( strcmp(parameter, "CPlusDown") == 0 ) {
      sprintf( valueString, "%d", Node[id]->CPlusDown);
   } else if ( strcmp(parameter, "CMinusDown") == 0 ) {
      sprintf( valueString, "%d", Node[id]->CMinusDown);
   } else if ( strcmp(parameter, "CZeroDown") == 0 ) {
      sprintf( valueString, "%d", Node[id]->CZeroDown);
   } else {
      strcpy( valueString, "MOC_ERROR_Unknown_Parameter_Name" );
   } /* end if */

   return valueString;
} /* end function GetNodeData */

/*-----------------------------------------------------*/

/* @function */
int GetNextNodeId( int idStart ) {
   /**
    Search for the next node that exists. <BR>
    Input: <BR>
    idStart : the index for the start of the search
              To find the first node, send -1 as input. <BR>
    Output: <BR>
    Returns id if a valid node was found, else returns -1. <BR>
    (Available from the Tcl interpreter.) 
    */
   int id, foundNode;

   if ( idStart < -1 ) idStart = -1;
   if ( idStart >= (MAX_NODES - 1) ) return -1; /* already at end */ 

   foundNode = NO;
   for ( id = idStart + 1; id < MAX_NODES; ++id ) {
      if ( Node[id] != NULL ) {
         foundNode = YES;
         break;
      } /* end if */
   } /* end for */

   if ( foundNode == YES ) {
      return id;
   } else {
      return -1;
   } /* end if */
} /* end function GetNextNodeId */

/*-----------------------------------------------------*/

/* @function */
char * ListNodesNear( double x, double y, double tol ) {
   /** 
    Find all nodes a specified location or
    find the node nearest a given location. <BR>
    Input: <BR>
    x, y : location coordinates <BR>
    tol  : radius of interest. <BR>
   
    Output: <BR>
    For tol > 0.0, returns a string listing all nodes within
    radius tol. <BR>
    If tol <= 0.0, the nearest node will be returned. <BR>
    (Available from the Tcl interpreter.) 
    */
   int i, nodeCount, id_array[30];
   static char ListString[256];
   char idString[12];

   nodeCount = FindNodesNear( x, y, tol, id_array, 30 );

   /*
    * Add the current node id to the string that represents the list
    * (but stop adding ids once the string becomes too long.
    */
   strcpy( ListString, "" );
   for ( i = 0; i < nodeCount; ++i ) {
      sprintf( idString, "%d", id_array[i] );
      if ( strlen(ListString) + strlen(idString) + 2 < sizeof(ListString) ) {
         if (i > 0) strcat(ListString, " ");
         strcat(ListString, idString);
      } /* end if */
   } /* end for */

   return ListString;
} /* end function ListNodesNear */

/*-----------------------------------------------------*/

/* @function */
int FindNodesNear( double x, double y, double tol, 
   int id_near_array[], int maxCount ) {
   /** 
    Find all nodes a specified location or
    find the node nearest a given location. <BR>
    
    Input: <BR>
    x, y : location coordinates <BR>
    tol  : radius of interest:  <BR>
           for tol > 0.0 all nodes within radius tol will be included <BR>
           for tol <= 0.0, only the closest node will be included. <BR>
    id_near_array[] : pointer to an array which will be used to store node ids <BR>
    maxCount : maximum number of nodes that will be collected 
               in the id_near_array <BR>
    
    Output: <BR>
    For tol > 0.0, returns a string listing all nodes within
    radius tol. <BR>
    If tol <= 0.0, the nearest node will be returned.
    */
   double dx, dy, distance, distanceNear;
   int    id, idNear, nodeCount;

   nodeCount = 0;

   if ( tol <= 0.0 ) {
      /*
       * Find Nearest.
       */
      idNear = -1;
      distanceNear = 10.0e6; /* something large */
      for ( id = 0; id < MAX_NODES; ++id ) {
         if ( Node[id] == NULL ) continue;
         dx = x - Node[id]->X;
         dy = y - Node[id]->Y;
         distance = sqrt(dx * dx + dy * dy);
         if ( distance < distanceNear ) {
            distanceNear = distance;
            idNear = id;
         } /* end if */
      } /* end for */

      if ( idNear >= 0 ) {
         id_near_array[0] = idNear;
         nodeCount = 1;
      } /* end if */

   } else {
      /*
       * Build up a list of nodes within the specified range.
       */
      for ( id = 0; id < MAX_NODES; ++id ) {
         if ( Node[id] == NULL ) continue;
         dx = x - Node[id]->X;
         dy = y - Node[id]->Y;
         distance = sqrt(dx * dx + dy * dy);
         if ( distance < tol ) {
            id_near_array[nodeCount] = id;
            ++nodeCount;
            if ( nodeCount >= maxCount ) break;
         } /* end if */
      } /* end for */

   } /* end if */

   return nodeCount;
} /* end function FindNodesNear */

/*-----------------------------------------------------*/

/* @function */
int SaveNodes( char *FileName ) {
   /**
    Save all valid nodes to the specified file. <BR>
    (Available from the Tcl interpreter.) 
    */
   FILE *fp;
   int id;
   struct NodeData *np;

   fp = fopen( FileName, "w" );
   if ( fp == NULL ) {
      if ( MOCDebugLevel >= 1 ) {
         printf( "Couldn't open file %s\n", FileName );
      } /* end if */
      return MOC_ERROR; 
   } /* end if */

   fprintf( fp, "# Id   X   Y  Mach   Nu  Theta    P0   T0  ");
   fprintf( fp, "CPlusUp  CMinusUp  CZeroUp  ");
   fprintf( fp, "CPlusDown  CMinusDown  CZeroDown\n");
   for (id = 0; id < MAX_NODES; ++id) {
      np = Node[id];
      if ( np == NULL ) continue;
      fprintf( fp, "%d %e %e %e %e %e %e %e %d %d %d %d %d %d\n",
         id, np->X, np->Y, 
         np->Mach, np->Nu, np->Theta,
         np->P0, np->T0, 
         np->CPlusUp, np->CMinusUp, np->CZeroUp,
         np->CPlusDown, np->CMinusDown, np->CZeroDown );
   } /* end for */
 
   fclose( fp );
   return MOC_OK;
} /* end function SaveNodes */


/* @function */
int LoadNodes( char *FileName ) {
   /**
    Load the node data from the specified file. <BR>
    To keep the characteristic network connections intact,
    we have to read the node data back into their original 
    positions in the array. <BR>
    (Available from the Tcl interpreter.) 
    */
   FILE *fp;
   int id, i, nodeCount;
   struct NodeData *np;
   char buffer[256], *buffer_ptr;

   fp = fopen( FileName, "r" );
   if ( fp == NULL ) {
      if ( MOCDebugLevel >= 1 ) {
         printf( "Couldn't open file %s\n", FileName );
      } /* end if */
      return MOC_ERROR; 
   } /* end if */

   /* Get the header line */
   buffer_ptr = fgets( buffer, sizeof(buffer), fp);
   if ( buffer_ptr == NULL ) {
      if ( MOCDebugLevel >= 1 ) {
         printf( "File seems to be empty.\n");
      } /* end if */
      return MOC_ERROR;
   } /* end if */

   nodeCount = 0;
   for (i = 0; i < MAX_NODES; ++i) {
      /*
       * Read a whole line from the file and extract its data.
       */
      buffer_ptr = fgets( buffer, sizeof(buffer), fp);
      if ( buffer_ptr != NULL ) {
         sscanf( buffer, "%d", &id);
         if ( Node[id] != NULL ) {
            DeleteNode( id );
         } /* end if */
         CreateNode( id );
         np = Node[id];
         sscanf( buffer, "%d %lf %lf %lf %lf %lf %lf %lf %d %d %d %d %d %d",
            &id, &(np->X), &(np->Y), 
            &(np->Mach), &(np->Nu), &(np->Theta),
            &(np->P0), &(np->T0), 
            &(np->CPlusUp), &(np->CMinusUp), &(np->CZeroUp),
            &(np->CPlusDown), &(np->CMinusDown), &(np->CZeroDown) );
         ++nodeCount;
      } /* end if */
   } /* end for */

   if ( MOCDebugLevel >= 1 ) {
      printf( "%d nodes read.\n", nodeCount);
   } /* end if */

   fclose( fp );
   return MOC_OK;
} /* end function LoadNodes */

/*-----------------------------------------------------*/
