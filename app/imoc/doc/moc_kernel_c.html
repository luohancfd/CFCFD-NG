<HTML>
<!-- Don't bother editing this file; it is machine generated. -->
<HEAD>
<TITLE> Documentation extracted from  ../source/moc_kernel.c </TITLE>
</HEAD>
<BODY>
<H2> ../source/moc_kernel.c </H2>
<P>\file moc_kernel.c 
* \ingroup imoc 
* \brief Method-of-Characteristics program, 1998, 1999 
* 
* This set of functions forms the computational and 
* data storage kernel for the MOC program. 
* Interaction with the user is handled by the set of 
* Tcl/Tk wrapper functions generated by SWIG. 
* The wrapper functions are set up such that they have the 
* same Tcl command name as the C function name. 
* The Tcl commands also accept the same number and type of 
* formal arguments and return the same type of result 
* as the corresponding C function. 
* 
* \author PA Jacobs 
* 
* \version 26-Sep-1998 : Initial hack 
* \version 01-Jan-1999 : resumed work 
* \version 07-Jan-2000 : Added Mach-number<--> Prandtl-Meyer conversion 
* when storing node data 
* \version 09-Jan-2000 : Added CZeroUp and CZeroDown fields. 
* \version 17-Jan-2000 : Split ListNodesNear into two parts (the new one 
* is FindNodesNear(). 
* \version 17-Sep-2000 : Rename SetGamma, SetDebugLevel, SetAxiFlag (add _C) 
* 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int SetDebugLevel_C( int value ) </B> </CODE> </P> 
<P>A value of 0 turns off debug code. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int GetDebugLevel( void ) </B> </CODE> </P> 
<P>Used primarily in the C functions. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int SetGamma_C( double value ) </B> </CODE> </P> 
<P>Sets the ratio of specific heats. 
For air, use a value of 1.4. 
<BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
double GetGamma( void ) </B> </CODE> </P> 
<P>Returns the currently set ratio of specific heats. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int SetAxiFlag_C( int value ) </B> </CODE> </P> 
<P>A value of 0 indicates 2D planar flow, 
and a value of 1 indicates axisymmetric flow. 
The axis of symmetry is along the x-axis. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int GetAxiFlag( void ) </B> </CODE> </P> 
<P>Returns 0 for 2D planar flow, 1 for axisymmetric flow. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int GetNumberOfNodes( void ) </B> </CODE> </P> 
<P>Returns the number of nodes with valid data. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int ValidNode( int id ) </B> </CODE> </P> 
<P>Returns a value of 1 if the node id is within range 
and the pointer is valid, 0 otherwise. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int InitMOC( void ) </B> </CODE> </P> 
<P>Called by the Tcl initialization procedure to set up the 
data storage and the initial value of some of the kernel 
variables. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int CreateNode( int id ) </B> </CODE> </P> 
<P>Input: <BR> 
id < 0 : Select the next available location.<BR> 
id >= 0 : Use a specific location.<BR> 
Output: <BR> 
Returns the index of the created node. 
A value of -1 is returned on failure.<BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int DeleteNode( int id ) </B> </CODE> </P> 
<P>Destroys the memory allocated to a node. 
If the node is connected to other nodes in the mesh, 
the linkages are retained between the remaining nodes. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
struct NodeData * GetNodePtr( int id ) </B> </CODE> </P> 
<P>Returns the address of the memory allocated to the node. 
A NULL value returned indicates that the node doesn't exist 
or the index was out of range.<BR> 
For use within the C functions. 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int SetNodeData_C( int id, char *parameter, char *valueString ) </B> </CODE> </P> 
<P>Set the value for a particular node parameter.<BR> 
Input: <BR> 
id : index to the node <BR> 
parameter : pointer to a string specifying the parameter <BR> 
valueString : pointer to a string specifying the value <BR> 
Output: <BR> 
Returns 0 if successful, -1 on error. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
char *GetNodeData_C( int id, char *parameter ) </B> </CODE> </P> 
<P>Get the value for a particular node parameter.<BR> 
Input: <BR> 
id : index to the node <BR> 
parameter : pointer to a string specifying the parameter <BR> 
Output: <BR> 
Returns a pointer to the string specifying the value. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int GetNextNodeId( int idStart ) </B> </CODE> </P> 
<P>Search for the next node that exists. <BR> 
Input: <BR> 
idStart : the index for the start of the search 
To find the first node, send -1 as input. <BR> 
Output: <BR> 
Returns id if a valid node was found, else returns -1. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
char * ListNodesNear( double x, double y, double tol ) </B> </CODE> </P> 
<P>Find all nodes a specified location or 
find the node nearest a given location. <BR> 
Input: <BR> 
x, y : location coordinates <BR> 
tol : radius of interest. <BR> 
Output: <BR> 
For tol > 0.0, returns a string listing all nodes within 
radius tol. <BR> 
If tol <= 0.0, the nearest node will be returned. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int FindNodesNear( double x, double y, double tol, 
int id_near_array[], int maxCount ) </B> </CODE> </P> 
<P>Find all nodes a specified location or 
find the node nearest a given location. <BR> 
Input: <BR> 
x, y : location coordinates <BR> 
tol : radius of interest: <BR> 
for tol > 0.0 all nodes within radius tol will be included <BR> 
for tol <= 0.0, only the closest node will be included. <BR> 
id_near_array[] : pointer to an array which will be used to store node ids <BR> 
maxCount : maximum number of nodes that will be collected 
in the id_near_array <BR> 
Output: <BR> 
For tol > 0.0, returns a string listing all nodes within 
radius tol. <BR> 
If tol <= 0.0, the nearest node will be returned. 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int SaveNodes( char *FileName ) </B> </CODE> </P> 
<P>Save all valid nodes to the specified file. <BR> 
(Available from the Tcl interpreter.) 
</P>
<!-- --------------------------------------------- --> <HR>
<P> <CODE> <B> 
int LoadNodes( char *FileName ) </B> </CODE> </P> 
<P>Load the node data from the specified file. <BR> 
To keep the characteristic network connections intact, 
we have to read the node data back into their original 
positions in the array. <BR> 
(Available from the Tcl interpreter.) 
</P>
<HR>
<ADDRESS>
    Extracted by <B>docgen.awk</B>  Mon Aug 09 23:28:59 EST 2004
</ADDRESS>
</BODY>
</HTML>
